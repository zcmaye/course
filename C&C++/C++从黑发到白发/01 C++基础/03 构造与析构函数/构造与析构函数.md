# 构造与析构函数

## 概念

构造函数与析构函数是C++类中的两种特殊的成员函数，分别用于初始化对象和清理对象。

### 什么是构造函数？

**构造函数** 是一种特殊的成员函数，在创建对象时**自动调用**，用于初始化对象的数据成员。

构造函数的名称与类名相同，并且不能有返回值，甚至连void也不行。构造函数可以有参数，也可以没有参数。如果一个类中没有显式定义构造函数，编译器会自动生成一个默认的无参构造函数。

**构造函数可以重载**。

### 什么是析构函数？

**析构函数** 是一种特殊的成员函数，在对象销毁时**自动调用**，用于清理对象占用的资源。

析构函数的名称与类名相同，但前面加上波浪号（`~`），且不接受参数，也不返回值。

**析构函数只能有一个**，而且形式是固定的。

## 构造/析构函数基本使用

### 调用机制

定义一个类，写上默认析构函数和析构函数：

```cpp
class Number {
public:
	//构造函数
	Number() {
		std::println("{}",__FUNCSIG__);
	}
	//析构函数
	~Number() {
		std::println("{}",__FUNCSIG__);
	}
};
```

#### 单个对象

定义对象，测试构造函数与析构函数调用机制：

```cpp
int main()
{
	Number n;
	std::cin.get();
	return 0;
}
```

执行时，先输出了`__cdecl Number::Number(void)`也就是构造函数的打印，然后按下回车键时才会输出`__cdecl Number::~Number(void)`析构函数的打印。也就是创建对象时自动调用构造函数，销毁对象时自动调用析构函数。

其实为了更好的观察现象，用动态内存分配是最合适的。

```cpp
int main()
{
	auto n = new Number;
	std::cin.get();
	delete n;
	return 0;
}
```

效果和上面一样，但是在这里，只要你把`delete n`注释掉，析构函数将不会被调用，这就证实了析构函数确实是在对象被析构时调用的。

#### 多个对象

当定义了多个对象时，构造与析构的顺序是怎么样的呢？为了观察多个对象的构造与析构调用时机，我们需要对`Number`类进行改造：

```cpp
class Number {
public:
	//构造函数
	Number() {
		std::println("{}",__FUNCSIG__);
	}
    //构造函数重载
	Number(double v) {
        //将值赋值给成员变量
		m_value = v;
		std::println("{}:{}", __FUNCSIG__,m_value);
	}
	//析构函数
	~Number() {
		std::println("{}:{}", __FUNCSIG__,m_value);
	}
private:
	double m_value{};
};
```

然后再测试：

```cpp
int main()
{
	Number n1(0);
	Number n2(1);
	std::cin.get();
	return 0;
}
```

运行结果如下：

```cpp
__cdecl Number::Number(double):0
__cdecl Number::Number(double):1
//输入回车
__cdecl Number::~Number(void):1
__cdecl Number::~Number(void):0
```

根据输出结果，可以得出结论：

+ 先创建的对象先构造，后创建的对象后构造
+ 先创建的对象后析构，后创建的对象先析构

因为创建对象的本质就是压栈，而栈又是先进后出的结构，所以完美符合上面的结论。

### 用途展示

#### RAII

说到用途展示，就不得不提到一个机制，即`RAII`机制，RAII（**R**esource **A**cquisition **I**s **I**nitialization）是由c++之父Bjarne Stroustrup提出的，中文翻译为**资源获取即初始化**，他说：使用局部对象来管理资源的技术称为资源获取即初始化；这里的资源主要是指操作系统中有限的东西如**内存**、**网络套接字**等等，总之就是打开之后必须手动关闭的东西，局部对象是指存储在栈的对象，它的生命周期是由操作系统来管理的，无需人工介入。

#### RAII的原理

资源的使用一般经历三个步骤**a.获取资源** **b.使用资源** **c.销毁资源**，但是资源的销毁往往是程序员经常忘记的一个环节，所以程序界就想如何在程序员中让资源自动销毁呢？C++之父给出了解决问题的方案：RAII，它充分的利用了C++语言局部对象自动销毁的特性来控制资源的生命周期。给一个简单的例子来看下局部对象的自动销毁的特性：

```cpp
class ZcFile {
public:
	ZcFile() = default;
	ZcFile(const std::string& filename)
		: m_filename(filename)		//构造函数初始化列表
	{
		
	}
	~ZcFile() {
		if (m_file) {
			fclose(m_file);
			m_file = nullptr;
		}
	}

	bool open(const char* mode) {
		m_file = fopen(m_filename.c_str(), mode);
		if (!m_file) {
			m_errorMsg = std::format("open file <{}> failed", m_filename);
			return false;
		}
		return true;
	}

	void close() {
		if (m_file) {
			fclose(m_file);
			m_file = nullptr;
		}
	}

	bool isOpen() {
		return m_file != nullptr;
	}

	bool eof() {
		return feof(m_file);
	}

	std::string readLine() {
		std::string line;
		while (!feof(m_file)) {
			auto ch = fgetc(m_file);
			if (ch == EOF || ch == '\n' || ch == '\r')
				break;
			line.push_back(ch);
		}
		return line;
	}

	int write(const std::string& str) {
		return fputs(str.c_str(), m_file);
	}

	const std::string& errorMsg() {
		return m_errorMsg;
	}
private:
	FILE* m_file{};
	std::string m_filename;
	std::string m_errorMsg;
};
```

`ZcFile`类封装了`FILE*`，使用RAII机制，在对象销毁的时候自动关闭文件。

测试一下：

```cpp
int main()
{
	//测试写
	{
		ZcFile file("./hello.txt");
		if (!file.open("w")) {
			std::println("[error] {}", file.errorMsg());
			return -1;
		}
		file.write("hello world\nmaye nice");
	}

	//测试读
	{
		ZcFile file("./hello.txt");
		if (!file.open("r")) {
			std::println("[error] {}", file.errorMsg());
			return -1;
		}
		while (!file.eof()) {
			std::println("data：{}", file.readLine());
		}
	}
	return 0;
}
```

> **构造函数初始化列表**用于在对象创建时直接初始化类的成员变量，特别是对于引用类型成员变量，必须使用初始化列表来绑定引用对象。

## 构造函数分类

构造函数根据参数的不同，可以分为以下几类：

### 无参构造函数

**默认构造函数**是一种特殊的构造函数，用于在创建对象时自动初始化对象的状态。如果类中没有显式定义构造函数，编译器会自动生成一个默认构造函数。

默认构造函数的函数体通常为空，不执行任何操作，因为我们可以使用`=default`来替代`{}`。

```cpp
class Number {
public:
	//默认(无参)构造函数
	//Number(){};
    Number() = default;	//等同于上面的写法
    ...
};
```

定义对象：

```cpp
Number num;
```

注意：调用默认构造函数，不要加括号：

```cpp
Number num1();
```

因为加了括号就变成了函数的声明了！！！

### 有参构造函数

包含一个或多个参数，可以重载多个有参函数，用于通过传递参数来初始化成员变量。

#### 一个参数的构造函数

如下，定义了一个`ZcString`类，并定义了参数为一个的构造函数：

```cpp
class ZcString {
public:
	ZcString(const char* str)
		: m_str(str)
	{ 
	}
    
    ~ZcString() {

	}

	const std::string& stdString() {
		return m_str;
	}
	const char* cString() {
		return m_str.c_str();
	}
private:
	std::string m_str;
};
```

##### 构造对象

那么，调用形式可以有如下几种：

1. 使用圆括号或者花括号调用构造函数：

```cpp
ZcString str("str");
ZcString str1{ "str1" };
```

2. 通过匿名对象构造

```cpp
ZcString str2 = ZcString("str2");
```

注意，这里并没有拷贝，而是相当于直接给匿名对象`ZcString("str2")`，取了个名字；如果没有取名，则创建之后会立马销毁！！！

```cpp
ZcString("str2");
```

可以通过调试查看效果！

3. 直接使用赋值符号`=`构造对象。

```cpp
ZcString str3 = "str3";
```

这种方法，其实是为了方便我们赋值的，实际上会先将"str3"构造成ZcString临时对象，然后取名为str3，也就是说和通过临时对象构造是一样的。

##### 禁止隐式转换

`explicit`关键字是用于控制类构造函数的隐式类型转换的。当构造函数只有一个参数时，可以通过`explicit`关键字来指定该构造函数是显式的，这样就可以防止编译器自动使用该构造函数进行隐式类型转换。

如下，将ZcString的一个参数的构造函数前面加上`explicit`：

```cpp
	explicit ZcString(const char* str)
		: m_str(str)
	{ 
	}
```

当一个构造函数被声明为显式的，它就不能被用于隐式转换和拷贝初始化。这意味着，你不能将一个单一的值赋给一个类类型的对象，除非你直接调用构造函数或者使用强制类型转换。

如果你尝试使用隐式转换来创建一个`ZcString`对象，如下所示：

```cpp
ZcString s = "maye";	//错误：不能隐式转换
```

> 会报错`error C2440: “初始化”: 无法从“const char [5]”转换为“ZcString”`。

这将会导致编译错误，因为`ZcString`的构造函数是显式的。但是，你可以显式地调用构造函数：

```cpp
ZcString s("maye");	//正确：显式调用构造函数
```

或者使用强制类型转换：

```cpp
ZcString s = ZcString("maye");
```

**为什么需要explicit关键字**

使用*explicit*关键字可以避免由于隐式类型转换导致的错误和不明确的代码。在某些情况下，隐式类型转换可能会导致意外的行为，特别是当它发生在不期望的地方时。通过将构造函数声明为显式的，程序员可以确保只有在明确请求时才会进行类型转换。

##### 抑制默认构造函数生成

如果类中定义了其他类型的构造函数（如有参构造函数或拷贝构造函数），编译器将不会自动生成默认构造函数。

那么对于`ZcString`类，定义对象时就必须传递参数，如果没有传递参数，将导致报错：

```cpp
ZcString s;
```

> 报错：`error C2512: “ZcString”: 没有合适的默认构造函数可用`

所以，如果类中定义了有参构造函数或拷贝构造函数，编译器将不会自动生成默认构造函数。如果需要无参构造函数，**必须显式定义**。

#### 多个参数的构造函数

在`ZcString`类中添加如下两个构造函数：

```cpp
	ZcString(const char* str, size_t count)
		: m_str(str,count)
	{
	}

	ZcString(const std::string& str,size_t off, size_t count)
		: m_str(str, off, count)
	{
	}
```

定义对象：

```cpp
int main()
{
	ZcString s("hello", 3);
	std::println("s is {}", s.cString());

	ZcString s1("hello world", 6, 5);
	std::println("s1 is {}", s1.cString());

	return 0;
}
```

注意如果有默认参数，不要和一个参数的构造函数冲突了。

### 拷贝构造函数(赋值构造)

**拷贝构造函数**在C++中是一种特殊的构造函数，它用于创建一个新对象作为另一个同类型对象的副本。当创建一个对象的副本时，例如通过将一个对象作为参数传递给函数，或者从函数返回一个对象时，就会调用拷贝构造函数。如果类中没有显式定义拷贝构造函数，编译器会自动生成一个默认的拷贝构造函数。

#### 构造函数基本使用

在`ZcString`类中添加拷贝构造函数：

```cpp
	ZcString(const ZcString& other)
		: m_str(other.m_str)
	{
	}
```

使用案例：

```cpp
	auto s2 = s1;		//调用拷贝构造
	auto s3 = (s1);
	std::println("s2 is {}", s2.cString());
```

#### 深拷贝与浅拷贝

在拷贝构造函数的实现中，需要注意**深拷贝deepCopy**与**浅拷贝shallowCopy**的区别。默认的拷贝构造函数执行的是浅拷贝，它只会复制对象的非静态成员变量的值。如果成员变量中包含指针，并且指向动态分配的内存，浅拷贝可能会导致多个对象的指针成员指向同一块内存区域，这在对象被销毁时可能会引起问题。为了避免这种情况，需要实现深拷贝，即为指针成员分配新的内存，并复制数据。

以下是一个拷贝构造函数的实现示例：

```cpp
class ZcAny {
public:
	enum DataType {
		None,
		Int,
		Double,
		String
	};
public:
	ZcAny() = default;
	ZcAny(int v)
		: m_ptr(new int(v))
		, m_type(Int)
	{ 
	}

	ZcAny(double v)
		: m_ptr(new double(v))
		, m_type(Double)
	{
	}

	ZcAny(const std::string& v)
		: m_ptr(new std::string(v))
		, m_type(String)
	{
	}

	ZcAny(const ZcAny& other) 
		//: m_ptr(other.m_ptr)	//浅拷贝
		: m_type(other.m_type)
	{
		//深拷贝
		switch (type())
		{
			case Int:
				m_ptr = new int(*(int*)other.m_ptr);
				break;
			case Double:
				m_ptr = new double(*(double*)other.m_ptr);
				break;
			case String:
				m_ptr = new std::string(*(std::string*)other.m_ptr);
				break;
		}
		
	}

	~ZcAny() {
		if (m_ptr) {
			delete m_ptr;
			m_ptr = nullptr;
		}
	}

	DataType type() {
		return m_type;
	}

	int toInt() {
		if(m_type != Int) {
			return 0;
		}
		return *(int*)m_ptr;
	}
	double toDouble() {
		if(m_type != Double) {
			return 0;
		}
		return *(double*)m_ptr;
	}
	std::string* toStringPtr() {
		if(m_type != String) {
			return nullptr;
		}
		return (std::string*)m_ptr;
	}
private:
	void* m_ptr{};
	DataType m_type{};
};
```

测试：

```cpp
	ZcAny a(10);
	std::println("{}", a.toInt());

	ZcAny d(3.14);
	std::println("{}", d.toDouble());

	ZcAny str("hello wrold");
	std::println("{}", *str.toStringPtr());

	auto ok = d;
	std::println("{}", ok.toDouble());
```



### 移动构造函数

移动构造函数是为提升性能而引入的重要特性，它通过**右值引用**将资源所有权从一个对象转移到另一个对象，而不是进行深拷贝，从而减少内存分配与数据复制的开销。

**核心原理**是利用 *T&&*（右值引用）绑定即将销毁的临时对象，将其内部资源“窃取”给新对象，并将原对象置于可安全析构的状态（如指针置 *nullptr*）。



#### delete

对于 C++ 的类，如果程序员没有为其定义特殊成员函数，那么在需要用到某个特殊成员函数的时候，编译器会隐式的自动生成一个默认的特殊成员函数，比如拷贝构造函数，或者拷贝赋值操作符。

程序员不需要自己手动编写拷贝构造函数以及拷贝赋值操作符，依靠编译器自动生成的默认拷贝构造函数以及拷贝赋值操作符就可以实现类对象的拷贝和赋值。这在某些情况下是非常方便省事的，但是在某些情况下，假设我们不允许发生类对象之间的拷贝和赋值，可是又无法阻止编译器隐式自动生成默认的拷贝构造函数以及拷贝赋值操作符，那这就成为一个问题了。

为了能够让程序员显式的禁用某个函数，C++11 标准引入了一个新特性：deleted 函数。程序员只需在函数声明后加上“=delete;”，就可将该函数禁用。例如，我们可以将类 X 的拷贝构造函数以及拷贝赋值操作符声明为 deleted 函数，就可以禁止类 X 对象之间的拷贝和赋值。

**用法示例：禁止拷贝**

```cpp
class Int
{
private:
	int m_number;
public:
	 Int(int number) { m_number = number; }
	 Int(const Int& other) = delete;
};
int main()
{
	Int i = 2;
	Int a = i;		//error C2280: “Int::Int(const Int &)”: 尝试引用已删除的函数
	return 0;
}
```

**用法示例：禁用转换构造函数**

delete 函数特性还可用于禁用类的某些转换构造函数，从而避免不期望的类型转换。在清单 12 中，假设类 X 只支持参数为双精度浮点数 double 类型的转换构造函数，而不支持参数为整数 int 类型的转换构造函数，则可以将参数为 int 类型的转换构造函数声明为 deleted 函数。

```cpp
class Int
{
private:
	int m_number;
public:
	 Int() = default;
	 Int(double) = delete;
	 Int(int number) { m_number = number; }
};
int main()
{
	Int i = 2;
	Int d = 3.14f;		//error C2280: “Int::Int(double)”: 尝试引用已删除的函数
	return 0;
}
```
