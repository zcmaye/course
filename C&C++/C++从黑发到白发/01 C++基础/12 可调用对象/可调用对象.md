# 可调用对象(Callable object)

在C++中，可调用对象是指能够**像函数一样被调用的实体**。它们包括**普通函数**、**函数指针**、**仿函数**（重载了`operator()`运算符的类对象）、**Lambda表达式**和**std::function**。

函数和函数指针不在过多讲解，咱们直接从仿函数开始学习~

## 仿函数

**仿函数**（Functor）也叫做**函数对象**，是通过重载`operator()`使对象能够像函数一样调用的类或结构体。仿函数的引入解决了普通函数无法满足的一些需求，并在STL算法、回调机制等场景中得到了广泛应用。

### 状态存储

仿函数的一个重要优势是**状态存储**。普通函数无法存储状态，而仿函数可以通过成员变量维护状态，例如计数器或阈值。这使得仿函数在需要跨多次调用保持数据的场景中非常有用。

#### 计数器

例如，一个计数器仿函数可以记录调用次数并基于此调整计算逻辑。

```cpp
class Counter {
public:
	Counter(int init = 0)
		: _count(init)
	{ }

	int operator()() {
		return _count++;
	}
private:
	int _count;
};
```

使用方法：

```cpp
int main()
{
    //进行计数
	Counter counter;
	for (int i = 0; i < 10; i++) {
		std::println("counter is {}", counter());
	}
	std::println();
    
    //如果需要重新计数，可以再定义一个计数器
	Counter counter1;
	for (int i = 0; i < 10; i++) {
		std::println("counter1 is {}", counter1());
	}

	return 0;
}
```

仿函数还提供了**性能优化**的可能性。由于仿函数是类的实例，编译器可以通过内联优化减少函数调用的开销，从而提高运行效率。这在性能敏感的场景中尤为重要。

#### 斐波拉契数列

假如客户有一个需求摆在我们的面前，编写一个函数：函数可以获得斐波拉契数列每项的值；每调用一次便返回一个值；函数可根据需要重复使用。

> **斐波那契数列是一个由0和1开始的数列，后续每一项都是前两项之和，其数列为：0、1、1、2、3、5、8、13、21、34……**

##### 静态变量

我们之前在 C 语言中也讲过斐波拉契数列，相信这个很好实现了。那么我们就编写的程序如下

```cpp
int fibonacci()
{
	static int a = 0;  // 当前项
	static int b = 1;  // 下一项

	int ret = a;       // 保存要返回的值
	a = b;             // 更新当前项为原来的下一项
	b = ret + b;       // 计算新的下一项

	return ret;
}
int main()
{
	//第一次求数列
	for (size_t i = 0; i < 5; i++) {
		std::print("{} ", fibonacci());     //0 1 1 2 3
	}
	std::println();

	//第二次求数列，如果要从第一项开始，那是不可能的
	for (size_t i = 0; i < 5; i++) {
		std::print("{} ", fibonacci());     //5 8 13 21 34
	}
	return 0;
}
```

我们就开心的完成任务了，于是交给客户了。过两天，客户又给打回来了。说是存在几个问题：函数一但调用就无法重来，静态局部变量处于函数内部，外界无法改变。函数为全局函数，是唯一的，无法多次独立使用。无法指定某个具体的数列项作为初始值。

##### 仿函数

  让我们来思考，仿函数实现思路：

- 定义一个类，重载`operator()`；
- 构造函数指定具体数列项的起始位置；
- 多个对象相互独立的求解数列项。

​    下来我们来看看最终的解决方案：

```cpp
class Fibonacci {
private:
    int a = 0, b = 1;
public:
    //构造函数指定从第n项开始
     Fibonacci(int n = 0) 
        : a(0),b(1)
    {
        for (int i = 0; i < n; i++){
            int next = a + b;
            a = b;
            b = next;
        }
    }
    int operator()() {
        int ret = a;
        a = b;
        b = ret + b;
        return ret;
    }

    void reset() {
        a = 0;
        b = 1;
    }
};
int main()
{
    Fibonacci fib;
	//第一次求数列
	for (size_t i = 0; i < 5; i++) {
		std::print("{} ", fib());     //1 1 2 3 5
	}
	std::println();

	//第二次求数列，如果要从第一项开始，只需要调用reset()函数
    fib.reset();
	for (size_t i = 0; i < 5; i++) {
		std::print("{} ", fib());     //8 13 21 34 55
	}
	return 0;
}
```

我们看到已经实现了所有需求，并且随时想从哪个数开始都行。

这就是仿函数的妙用，怎么样，你学废了嘛？

### 作为回调

在STL中，仿函数与算法的兼容性是其另一大优势。例如，`std::sort`可以接受仿函数作为自定义排序规则。通过定义不同的仿函数，可以灵活地实现多种排序逻辑，而无需修改数据结构本身。

以下是一个简单的函数示例，用于实现自定义排序：

```cpp
//降序
bool hdy_desc(int a, int b) {
	return a > b;
}

//升序
bool hdy_asc(int a, int b) {
	return a > b;
}

int main()
{
	int nums[] = { 3,7,1,2,8 };
	//默认升序排列
	std::sort(nums, nums + 5);
	//降序排列需要指定回调
	std::sort(nums, nums + 5, hdy_desc);
	//直接打印
	std::println("{}", nums);

	return 0;
}
```

使用仿函数实现如下：

```cpp
struct HdyDesc {
	bool operator()(int a, int b) {
		return a > b;
	}
};

struct HdyAsc{
	bool operator()(int a, int b) {
		return a < b;
	}
};

int main()
{
	int nums[] = { 3,7,1,2,8 };
	//默认升序排列
	std::sort(nums, nums + 5);
	//降序排列需要指定回调
	std::sort(nums, nums + 5, HdyDesc());
	//直接打印
	std::println("{}", nums);

	return 0;
}
```



写一个简单类，除了维护类的基本成员函数外，只需要重载 operator() 运算符 。这样既可以免去对一些公共变量的维护，也可以使重复使用的代码独立出来，以便下次复用。



### 仿函数优点

如果可以用仿函数实现，那么你应该用仿函数，而不要用CallBack。原因在于：

- 仿函数可以不带痕迹地传递上下文参数。而CallBack技术通常使用一个额外的void*参数传递。这也是多数人认为CallBack技术丑陋的原因。
- 仿函数可以被编译器优化，提高效率
- 仿函数是类型安全的，可以在编译器期间进行检查
- 仿函数可以作为成员变量进行保存，而函数不行(可以使用指针，但是丑陋)
- 仿函数可以保存状态，而函数不能
- 仿函数可以作为模板参数，函数不能
- 当然，现在我们可以用lambda表达式来替代仿函数(lambda本质上就是仿函数的语法糖)

### 标准仿函数

STL 中也大量涉及到仿函数，有时仿函数的使用是为了函数拥有类的性质，以达到安全传递函数指针、依据函数生成对象、甚至是让函数之间有继承关系、对函数进行运算和操作的效果。比如 STL 中的容器 set 就使用了仿函数 less ，而 less 继承的 binary_function，就可以看作是对于一类函数的总体声明，这是函数做不到的。

C++ 针对常用的算术和逻辑运算定义了很多函数对象：

| 算术运算                                                     |                                 |
| ------------------------------------------------------------ | ------------------------------- |
| [plus](https://zh.cppreference.com/w/cpp/utility/functional/plus) | 实现 x + y 的函数对象 (类模板)  |
| [minus](https://zh.cppreference.com/w/cpp/utility/functional/minus) | 实现 x - y 的函数对象 (类模板)  |
| [multiplies](https://zh.cppreference.com/w/cpp/utility/functional/multiplies) | 实现 x * y 的函数对象 (类模板)  |
| **比较**                                                     |                                 |
| [equal_to](https://zh.cppreference.com/w/cpp/utility/functional/equal_to) | 实现 x == y 的函数对象 (类模板) |
| [not_equal_to](https://zh.cppreference.com/w/cpp/utility/functional/not_equal_to) | 实现 x != y 的函数对象 (类模板) |
| [greater](https://zh.cppreference.com/w/cpp/utility/functional/greater) | 实现 x > y 的函数对象 (类模板)  |
| [greater_equal](https://zh.cppreference.com/w/cpp/utility/functional/greater_equal) | 实现 x >= y 的函数对象 (类模板) |
| [less](https://zh.cppreference.com/w/cpp/utility/functional/less) | 实现 x < y 的函数对象 (类模板)  |
| [less_equal](https://zh.cppreference.com/w/cpp/utility/functional/less_equal) | 实现 x <= y 的函数对象 (类模板) |

## Lambda表达式

**Lambda**（或称为**lambda表达式**）是C++11引入的一种语法糖，用于定义和使用匿名函数对象

Lambda有很多叫法，有Lambda表达式、Lambda函数、匿名函数，为了方便表述统一用Lambda表达式进行叙述。

Lambda表达式主要特点包括：

- **简洁性**：lambda表达式允许在需要函数的地方直接定义函数，而无需命名。
- **灵活性**：可以在函数内部定义，适用于回调函数和算法。
- **安全性**：通过捕获外部变量，可以避免全局变量的使用。l

### Lambda表达式语法

语法如下:

```cpp
[capture list](parameters)mutable noexcept ->return type
{
    statement;
}
```

+ **捕获列表(capture list)：**捕获列表能够捕捉上下文中的变量以供Lambda函数使用。

+ **可变的(mutable)：**可以变的，和const是反义词。默认情况下Lambda函数总是一个`const`函数，`mutable`可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。

+ **异常说明(noexcept)：**用于Lamdba表达式内部函数是否可以抛出异常。
+ **返回类型(return type)：**追踪返回类型(也叫尾拖返回类型)形式声明函数的返回类型。我们可以在不需要返回值的时候也可以连同符号”->”一起省略。此外，在返回类型明确的情况下，也可以省略该部分，让编译器对返回类型进行推导。

+ **函数体(statement)：**内容与普通函数一样，不过除了可以使用参数之外，还可以使用所有捕获的变量。

#### 捕获列表

Lambda表达式与普通函数最大的区别是，除了可以使用参数以外，Lambda函数还可以通过捕获列表访问一些上下文中的数据。具体地，捕捉列表描述了上下文中哪些数据可以被Lambda使用，以及使用方式（以值传递的方式或引用传递的方式）。语法上，在“`[]`”包括起来的是捕获列表，捕获列表由多个捕获项组成，并以逗号分隔。捕获列表有以下几种形式：

+ [ ]中没有任何捕获，表示不捕获任何外部变量

  ```cpp
  auto function = ([]{
  		std::cout << "Hello World!" << std::endl;
  	}
  );
  
  function();
  ```

+ [var]表示按值捕获指定的的变量var

  ```cpp
  int num = 100;
  auto function = ([num]{
  		std::cout << num << std::endl;
  	}
  );
  
  function();
  ```

+ [=]表示值传递方式捕获所有父作用域的变量(包括this指针)

  ```cpp
  int index = 1;
  int num = 100;
  auto function = ([=]{
  			std::cout << "index: "<< index << ", " 
                  << "num: "<< num << std::endl;
  	}
  );
  
  function();
  ```

+ [&var]表示按引用捕获指定的变量var

  ```cpp
  int num = 100;
  auto function = ([&num]{
  		num = 1000;
  		std::cout << "num: " << num << std::endl;
  	}
  );
  
  function();
  ```

+ [&]表示按引用捕获所有父作用域的变量(包括this)

  ```cpp
  int index = 1;
  int num = 100;
  auto function = ([&]{
  		num = 1000;
  		index = 2;
  		std::cout << "index: "<< index << ", " 
              << "num: "<< num << std::endl;
  	}
  );
  
  function();
  ```

+ [this]表示值传递方式捕获当前的this指针

  ```cpp
  #include <iostream>
  using namespace std;
   
  class Lambda
  {
  public:
      void sayHello() {
          std::cout << "Hello" << std::endl;
      };
  
      void lambda() {
          auto function = [this]{ 
              this->sayHello(); 
          };
  
          function();
      }
  };
   
  int main()
  {
      Lambda demo;
      demo.lambda();
  }
  ```

**=、&混合搭配**

+ [=,&a,&b]表示按引用捕获变量a和b，按值捕获其他所有变量

  ```cpp
  int index = 1;
  int num = 100;
  auto function = ([=, &index, &num]{
  		num = 1000;
  		index = 2;
  		std::cout << "index: "<< index << ", " 
              << "num: "<< num << std::endl;
  	}
  );
  
  function();
  ```

+ `[=,a]`这里已经以值传递方式捕捉了所有变量，但是重复捕捉`a`了，会报错的；

+ `[&,&this]`这里`&`已经以引用传递方式捕捉了所有变量，再捕捉`this`也是一种重复。

#### 参数列表

除了捕获列表之外，Lambda还可以接受输入参数。参数列表是可选的，并且在大多数方面类似于函数的参数列表。

```cpp
auto function = [] (int first, int second){
    return first + second;
};
	
function(100, 200);
```

#### mutable

`mutable`修饰符， 默认情况下Lambda函数总是一个`const`函数，`mutable`可以取消其常量性。在使用该修饰符时，参数列表不可省略（即使参数为空）。

```cpp
#include <iostream>
using namespace std;

int main()
{
   int m = 0;
   int n = 0;
   [&, n] (int a) mutable { m = ++n + a; }(4);
   cout << m << endl << n << endl;
}
```

#### 返回类型

Lambda表达式的**返回类型会自动推导**。除非你指定了返回类型，否则不必使用关键字。返回型类似于通常的方法或函数的返回型部分。但是，返回类型必须在参数列表之后，并且必须在返回类型->之前包含类型关键字。如果Lambda主体仅包含一个`return`语句或该表达式未返回值，则可以省略Lambda表达式的`return-type`部分。如果Lambda主体包含一个`return`语句，则编译器将从`return`表达式的类型中推断出`return`类型。否则，编译器将返回类型推导为`void`。

### Lambda用途

#### 配合 STL 算法使用（最常用场景）

STL 中的排序、查找、遍历等算法（如`sort`、`for_each`、`find_if`）常常需要自定义比较 / 判断逻辑，Lambda 可以直接内联编写这些逻辑，避免编写大量命名的回调函数。

##### 自定义排序规则

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> nums = {3, 1, 4, 1, 5, 9};
    
    // 用Lambda实现降序排序（无需单独写compare函数）
    std::sort(nums.begin(), nums.end(), [](int a, int b) {
        return a > b; // 降序排序的核心逻辑
    });
    
    // 用Lambda遍历输出
    std::for_each(nums.begin(), nums.end(), [](int num) {
       	std::println("{}", num);
    });
    // 输出：9 5 4 3 1 1
    
    return 0;
}
```

##### 条件查找

```cpp
	// 查找第一个大于5的数
	auto it = std::find_if(nums.begin(), nums.end(), [](int num) {
		return num > 5;
		});
	if (it != nums.end()) {
		std::println("找到大于5的数：{}",*it); // 输出9
	}
```

#### 捕获外部变量，实现上下文感知的逻辑

Lambda 可以通过**捕获列表**（`[]`内的内容）访问当前作用域的变量，这是普通函数做不到的，能灵活结合上下文实现复杂逻辑。

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    int threshold = 5; // 外部变量：阈值
    std::vector<int> nums = {3, 1, 4, 1, 5, 9};
    
    // 按值捕获threshold，筛选大于阈值的数
    int count = std::count_if(nums.begin(), nums.end(), [threshold](int num) {
        return num > threshold;
    });
    
    std::println("大于{}的数有：{}个",threshold , count); // 输出1个
    return 0;
}
```

#### 作为函数参数 / 返回值，简化回调逻辑

很多场景需要传递回调函数（如异步操作、事件处理），Lambda 无需定义命名函数，直接传递匿名逻辑，代码更紧凑。

```cpp
#include <iostream>

// 函数接收Lambda作为参数（用std::function封装）
void process(int num, const std::function<void(int)>& callback) {
    callback(num * 2); // 执行回调逻辑
}

int main() {
    // 直接传递Lambda作为回调
    process(5, [](int res) {
        std::println("处理结果：{}",res); 	// 输出10
    });
    return 0;
}
```

####  局部封装短小逻辑，避免代码冗余

```cpp
#include <iostream>

int main() {
    // 局部封装计算圆面积的逻辑
    auto calcArea = [](double r) {
        const double PI = 3.14159;
        return PI * r * r;
    };
    
    std::println("半径为2的圆面积：{}", calcArea(2)); // 输出12.5664
    return 0;
}
```

#### 模板Lambda

```cpp
	// C++20: 模板 Lambda
	auto templateLambda = []<typename T>(T a, T b) {
		return a + b;
	};
	std::println("{}",templateLambda(1, 2)); // 输出3
```



## 函数适配器

> 头文件<functional>

函数适配器的功能是：将一种函数对象转化为另外一种符合要求的函数对象。

### 函数绑定

#### bind

bind函数用来绑定函数调用的某些参数，可以将bind函数看作一个通用的函数包装器，它接受一个可调用对象，并返回函数对象。

返回的函数对象参数从前往后，可以依次编号，从1开始；然后可以把传入的参数对原来的参数进行绑定。

##### 1. 绑定全局函数

> 全局函数是指定义在类外的函数，可以被其他文件中函数调用。

###### 1.0 绑定无参函数

对于没有参数的函数，绑定起来最简单，只需要传递一个函数名。

```cpp
 std::string myName() { return std::string("顽石老师"); }
 //exp
 auto getNmae = std::bind(myName);
 std::cout << getNmae();
```

###### 1.1 顺序绑定参数

首先，定义一个有参数的函数。

```cpp
 void show(int number, const std::string& str)
 {
     std::println("{} {}",number,str);
 }
```

然后，进行绑定并调用。

```cpp
 auto bind_show = std::bind(show, placeholders::_1, placeholders::_2);
 bind_show(2,"world");
```

###### 1.2 交换参数位置

使用`placeholders`来进行占位，`placeholders::_N` _N表示绑定之后的函数对象的参数位置。

```cpp
 auto bind_show1 = std::bind(show, placeholders::_2, placeholders::_1);
 bind_show1("world",1314520);
```

###### 1.3 绑定固定参数

```cpp
 auto bind_show3 = std::bind(show, 888,placeholders::_1);
 bind_show3("玩蛇老师");
```

##### 2. 绑定成员函数

```cpp
 struct Plus
 {
     int plus(int a, int b)
     {
         return a * b;
     }
 };  
 {
     Plus plus;
     auto func1 = std::bind(&Plus::plus, &plus, placeholders::_1, placeholders::_2); //绑定对象指针
     auto func2 = std::bind(&Plus::plus, plus, placeholders::_1, placeholders::_2);  //绑定对象或引用
     std::println("{}",func1(2, 4));
 }
```

##### 3. 绑定仿函数

```cpp
 struct Sub
 {
     int operator()(int a, int b)
     {
         return a * b;
     }
 };
 {
     auto func2 = std::bind(Sub(), placeholders::_1, placeholders::_2);
     std::println("{}",func2(3, 4));
 }
```

##### 4. 绑定lambda表达式

```cpp
 {   
     auto func3 = std::bind([](int a, int b) {return a / b; }, placeholders::_1, placeholders::_2);
     std::println("{}",func3(6 ,2));
 }
```

#### bind_front(C++20)

与bind类似，只不过是绑定前面n个参数。

```cpp
int add(int a, int b)
{
	return a + b;
}

int main()
{
	auto add_2 = std::bind_front(add, 2);
	std::println("{}",add_2(5));	//等价与 add(2,5);
}
```

#### bind_back(C++23)

与bind类似，只不过是绑定后面n个参数。

```cpp
int add(int a, int b)
{
	return a + b;
}

int main()
{
	auto add_10 = std::bind_back(add, 10);
	std::println("{}",add_10(5));	//等价与 add(5,10);
	return 0;
}
```



### ref、cref

构造一个适当的reference_wrapper类型的对象来保存对elem的引用。

- ref 普通引用
- cref 常引用

```cpp
 class Foo
 {
 public:
     int _value = 4;
     void show()
     {
         ++_value;
         std::println("{}",_value);
     }
 };
 int main()
 {
     Foo foo;
 
     auto func = std::bind(&Foo::show, std::ref(foo));
     func();
     func();
 
     foo.show();
     foo.show();
 
     return 0;
 }
```

### mem_fn

把成员函数转为函数对象，使用对象指针或对象(引用)进行绑定

```cpp
class Foo
{
public:
	int a{ 100 };
	void print()
	{
		std::println("a:{}", a);
	}
	void print2(int val) {
		std::println("{} value:{}", a, val);
	}
};

int main()
{
	Foo f;
	//把成员函数转为函数对象，使用对象指针或对象(引用)进行绑定
	auto func = std::mem_fn(&Foo::print);
	func(f);        //把对象传进去(引用)
	func(&f);       //对象指针也行
	func(Foo());    //临时对象也行

	auto func2 = std::mem_fn(&Foo::print2);
	func2(f, 520);

	return 0;
}
```

#### 示例

```cpp
struct Foo
{
	int v;
	Foo(int val = -1)
		:v(val) {
	}
	void print()
	{
		std::println("{}", v);
	}
};

int main()
{
	//让每个对象都调用指定的成员函数
	std::vector<Foo> vec(5);    //存对象
	std::for_each(vec.begin(), vec.end(), std::mem_fn(&Foo::print));

	std::println();

	//让每个对象都调用指定的成员函数
	std::vector<Foo*> vec_ptr;  //存指针
	for (int i = 0; i < 5; i++) {
		vec_ptr.push_back(new Foo(i * 3));
	}
	std::for_each(vec_ptr.begin(), vec_ptr.end(), std::mem_fn(&Foo::print));

	return 0;
}
```

### not_fn(C++17)

函数对象否定适配器，把符合某种特殊条件的『函数对象』转换为反义「函数对象」的函数。

+ 否定一元谓词`返回bool类型,形参只有一个的叫做一元谓词`

```cpp
bool isBlock()
{
	return true;
}
int main()
{
	std::println("{}", isBlock());					//3>2  ?
	std::println("{}",std::not_fn(isBlock)());		//3<=2 ? 
	return 0;
}
```

+ 否定二元谓词`返回bool类型,形参有两个的叫做二元谓词`

```cpp
bool _greater(int a, int b)
{
	return a > b;
}

int main()
{
	auto _less_equal = std::not_fn(_greater);
	std::println("{}",_greater(3, 2));			//3>2  ?
	std::println("{}",_less_equal(3, 2));		//3<=2 ? 
	return 0;
}
```



## function类

该函数包装器模板能包装任何类型的可调用实体，如普通函数、函数对象(仿函数)、lambda表达式以及bind创建的对象。

std::function对象是对C++中现有的可调用实体的一种类型安全的包裹（我们知道像函数指针这类可调用实体，是类型不安全的）。

通过function类型可以将多个不同类型的可调用对象，整合到一个类型中。

### 包装普通函数

```cpp
 int add(int a, int b)
 {
     return a + b;
 }
 
 {
     std::function<int(int, int)> fun_add(add);
     cout<<fun_add(2, 3);
 }
```

### 包装成员函数(通过bind绑定)

```cpp
 class Maye
 {
 public:
     int add(int a, int b)
     {
         return a + b;
     }
 };
 
 {
     Maye maye;
     std::function<int(int, int)> fun_maye_add(std::bind(&Maye::add, &maye,placeholders::_1,placeholders::_2));
     cout << fun_maye_add(3, 5);
 }
```

### 包装lambda表达式

```cpp
 {
     std::function<int(int, int)> fun_lambda_add([](int a, int b)->int 
                                                     {
                                                         return a + b; 
                                                     });
     cout << fun_lambda_add(7, 8) << endl;
 }
```

### 包装函数对象

```cpp
 class Maye
 {
 public:
     int operator()(int a, int b)
     {
         return a * b;
     }
 };
 
 {       
     Maye obj;
     std::function<int(int, int)> fun_functor(obj);
     cout << fun_functor(2,4);
 }
```

## std::invoke

std::invoke 能以给定参数调用任何可调用 *(Callable)* 对象。

### 调用全局函数

```cpp
 std::string myName(){return std::string("顽石老师");}
 std::cout<< std::invoke(myName);
```

### 调用成员函数

```cpp
 class Foo
 {
 public:
     void show(){std::cout << __FUNCTION__ << std::endl;}
 };
 
 Foo foo;
 std::invoke(&Foo::show,&foo);
```

### 调用函数并传递参数

```cpp
 void show(int number, const std::string& str)
 {
     cout << number << " " << str << endl;
 }
 
 std::invoke(show,123,"world");
```

### 调用lambda

```cpp
std::invoke([]()
 {
	 std::cout << "hello wrold" << std::endl;
 });
```

甚至可以使用它来访问成员数据。

```cpp
struct Foo
{
	int a = 666;
};

Foo f;
check(&Foo::a, f);
std::cout << std::invoke(&Foo::a, f) << std::endl;
```



