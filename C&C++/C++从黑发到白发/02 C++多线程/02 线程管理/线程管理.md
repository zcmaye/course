# 线程管理

## 线程管理的基础

每个程序至少有一个线程：执行main()函数的线程，其余线程有其各自的入口函数。线程与原始线程(以main()为入口函数的线程)同时运行。如同main()函数执行完会退出一样，当线程执行完入口函数后，线程也会退出。在为一个线程创建了一个`std::thread`对象后，需要等待这个线程结束；不过，线程需要先进行启动。下面就来启动线程。

### 启动线程

第1章中，线程在`std::thread`对象创建(为线程指定任务)时启动。最简单的情况下，任务也会很简单，通常是无参数无返回(*void-returning*)的函数。这种函数在其所属线程上运行，直到函数执行完毕，线程也就结束了。在一些极端情况下，线程运行时，任务中的函数对象需要通过某种通讯机制进行参数的传递，或者执行一系列独立操作;可以通过通讯机制传递信号，让线程停止。线程要做什么，以及什么时候启动，其实都无关紧要。总之，使用C++线程库启动线程，可以归结为构造`std::thread`对象：

```cpp
void do_some_work();
std::thread my_thread(do_some_work);
```

为了让编译器识别`std::thread`类，这个简单的例子也要包含`<thread>`头文件。如同大多数C++标准库一样，`std::thread`可以用可调用（*callable*）类型构造，将带有函数调用符类型的实例传入`std::thread`类中。

#### 使用全局函数

使用全局函数作为线程入口函数，是最简单的一种：

```cpp
void do_something()
{
	std::println("hello concurrent world");
}

int main()
{
	std::thread my_thread(do_something);

	return 0;
}
```

运行之后会打印`hello concurrent world`，然后程序中断，无需理会，稍后我们会处理。

#### 使用lambda表达式

```cpp
	std::thread my_thread([]()
		{
			do_something();
		});
```

#### 使用成员函数

将类的成员函数作为线程入口函数时，必须要绑定一个对象实例：

```cpp
class Bar {
public:
	void do_something() const {
		std::println("Bar::hello concurrent world");
	}
};

int main()
{
	Bar bar;
	//std::thread my_thread(std::bind(&Bar::do_something, &bar));	//①
	std::thread my_thread(&Bar::do_something, &bar);				//②
	return 0;
}
```

代码中，使用了两种方式绑定对象实例，方法①使用了std::bind函数进行绑定，方法②直接使用了std::thread的构造函数实现绑定。

大家注意到，在绑定对象时，都使用了对象的地址，因为如果不使用地址而是使用值传递，则绑定时会拷贝bar对象，如果想要按引用传递，可以使用`std::ref`函数进行包装，如果要传递常引用则需要使用`std::cref`。

```cpp
	std::thread my_thread(&Bar::do_something, std::ref(bar));
```

当然，也可以直接使用labmda表达式：

```cpp
	std::thread my_thread([&bar]() {
		bar.do_something();
		});
```

这样会更加简单直观一点。

#### 使用仿函数

仿函数就是重载了函数调用运算符`()`的类。

```cpp
class Bar {
public:
	void do_something() const {
		std::println("Bar::hello concurrent world");
	}

	void operator()() {
		std::println("Bar::operator()() hello concurrent world");
	}
};

int main()
{
    Bar bar;
	std::thread my_thread(bar);

	return 0;
}
```

代码中，提供的函数对象会复制到新线程的存储空间当中，函数对象的执行和调用都在线程的内存空间中进行。

有件事需要注意，当把函数对象传入到线程构造函数中时，需要避免“最令人头痛的语法解析”(*C++’s most vexing parse*)。如果你传递了一个匿名对象，而不是一个命名的对象；C++编译器会将其解析为函数声明，而不是类型对象的定义。

```cpp
	std::thread my_thread(Bar());
```

编译器会给出一个警告：`warning C4930: “std::thread my_thread(Bar (__cdecl *)(void))”: 未调用原型函数(是否是有意用变量定义的?)`

这里相当与声明了一个名为my_thread的函数，这个函数带有一个参数，返回一个`std::thread`对象的函数，而非启动了一个线程。

使用在前面命名函数对象的方式，或使用多组括号①，或使用新统一的初始化语法②，可以避免这个问题。如下所示：

```cpp
	std::thread my_thread((Bar()));
	std::thread my_thread1{Bar()};
```

使用lambda表达式也能避免这个问题：

```cpp
	std::thread my_thread2([]() {
			Bar()();
		});
```

[第2章 线程管理 · C++并发编程实战](https://nj.gitbooks.io/c/content/content/chapter2/chapter2-chinese.html)