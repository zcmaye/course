# 特殊成员

## this指针

**this指针**是一个指向当前对象实例的特殊指针。它是每个**非静态成员函数**的隐含参数，允许成员函数访问调用它的对象的成员变量和成员函数。this指针对于理解对象如何访问其自身的数据和成员函数至关重要。

### this指针基本使用

测试this指针代码如下：

```cpp
class Number {
public:
	Number() = default;
	Number(double v)
		: m_value(v)
	{ }

	double value() {
		return this->m_value;
	}

	void setValue(double v) {
		this->m_value = v;
	}
		
	double m_value{};
};
```

`this->m_value`使用this指针访问成员变量，this实际上指向的是调用对应函数的对象。

在构造函数中加入打印this指针的语句：

```cpp
	Number(double v)
		: m_value(v)
	{
		std::println("this address is {}", (void*)this);
	}
```

然后，写上测试案例打印对象的地址：

```cpp
int main()
{
	{
		Number num(10);
		std::println("num is {}", num.value());
		std::println("num address is {}", (void*)&num);
	}
	std::println();
	{
		Number num(20);
		std::println("num is {}", num.value());
		std::println("num address is {}", (void*)&num);
	}
	return 0;
}
```

输出结果如下所示：

```css
this address is 0xdf8b2ff5f8
num is 10
num address is 0xdf8b2ff5f8

this address is 0xdf8b2ff618
num is 20
num address is 0xdf8b2ff618
```

可以发现`this`指针的值，和当前对象的地址是一样的，也就说明了this指针确实是指向当前对象的！！！

### this指针作用

`this` 指针在编程实践中有着广泛的应用，它可以帮助我们解决变量命名冲突，实现链式调用，并在拷贝构造函数和赋值操作符中起到关键的作用。

#### 解决变量命名冲突

在类的成员函数中，如果**形参名称**与**类的成员变量名称相同**，可以使用 `this` 指针消除歧义。

```cpp
class Rect{
public:
	Rect() = default;
	Rect(int width)
		: width(width)
	{ 
	}

	void setWidth(int width) {
		this->width = width;
	}
private:
	int width;
};
```

在这个示例中，`this` 指针用于解决 `width` 形参与 `width` 成员变量之间的命名冲突。

#### 链式调用

链式调用是一种编程技巧，可以使代码更加紧凑和易读。它通过在每个成员函数中返回 `*this`，使得多个成员函数调用可以在同一行内连续进行。

我们给Rect增加一个height成员，以便测试：

```cpp
class Rect{
public:
	Rect() = default;
	Rect(int width,int height)
		: width(width)
		, height(height)
	{ 
	}

	void setWidth(int width) {
		this->width = width;
	}

	void setHeight(int height) {
		this->height = height;
	}
private:
	int width;
	int height;
};
```

如果要给对象设置宽度和高度，则需要通过对象调用`setWidth`和`setHeight`函数，对象需要写两次！

```cpp
Rect rect;
rect.setWidth(10);
rect.setHeight(20);
```

比较麻烦，尤其是对象名比较长的时候！我们把两个设置函数的返回值修改为返回本对象，即可进行链式调用！

```cpp
	Rect& setWidth(int width) {
		this->width = width;
        return *this;			//返回本对象
	}

	Rect& setHeight(int height) {
		this->height = height;
        return *this;			//返回本对象
	}
```

这样就可以使用如下的链式调用了：

```cpp
Rect rect;
rect.setWidth(10)
    .setHeight(20);
```

### this指针探究

this指针从哪里来的？其实是C++编译器，帮你传递的，而且this指针是作为成员函数的第一个参数传递的！如何理解呢？

#### 类封装

```cpp
class Circle {
public:
	Circle () 
		:m_radius(0)
	{ }

	Circle(float radius)
		:m_radius(radius)
	{ }

	float radius() {
		return m_radius;
	}
	void setRadius(float radius) {
		m_radius = radius;
	}

	double area() {
		return m_radius * m_radius * 3.14;
	}
private:
	float m_radius;
};
```

进行测试：

```cpp
int main()
{
	Circle c(10.0f);
	std::println("r is {},area is {}", c.radius(), c.area());
	c.setRadius(20);
	std::println("r is {},area is {}", c.radius(), c.area());
	return 0;
}
```

#### 结构体封装

如果我们用结构体进行封装，也就是结构体内部不允许写函数，看如何实现相同的功能：

```cpp
struct ZcCircle {
	float m_radius;
};

void c_init(ZcCircle* pthis, float radius) {
	pthis->m_radius = radius;
}

float c_radius(ZcCircle* pthis) {
	return pthis->m_radius;
}
void c_setRadius(ZcCircle* pthis,float radius) {
	pthis->m_radius = radius;
}

double c_area(ZcCircle*pthis) {
	return pthis->m_radius * pthis->m_radius * 3.14;
}
```

测试一下调用，并和对象使用进行对比：

```cpp
{
	ZcCircle c;
	c_init(&c, 10.0f);
	std::println("r is {},area is {}", c_radius(&c), c_area(&c));
	c_setRadius(&c,20);
	std::println("r is {},area is {}", c_radius(&c), c_area(&c));
}
```

#### 总结

通过上面的测试可以知道，其实C++类中的成员函数，其实也是通过传递一个对象指针，从而能直接访问成员变量的，只不过这个`this`对象指针，是编译器帮你传递的！

### 推导this

推导this（[Deducing this](https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r7.html)）是 C++23 的新特性，给了指定非静态成员函数的新方法。通常情况下，在调用对象的成员函数的时候，对象会被**隐式**传入成员函数，虽然参数列表里没有。P0847 让这个参数可以被 **显式** 指定，可以给它名字和 `const` /引用限定符。比如：

```cpp
struct implicit_style {
    void do_something(); 				// 对象隐式传入
};

struct explicit_style {
    void do_something(this auto& self); // 对象显式传入
};
```

在类型说明符前面有 `this` 关键字的是显式的对象参数，它必须是函数的第一个参数。

定义一个类型进行测试：

```cpp
class Number {
public:
	Number() = default;
	Number(double v)
		: m_value(v)
	{
	}

	double value() {
		return m_value;
	}
	//推导this
	Number& setValue(this auto& self, double v) {
        //m_value = v;		//错误，必须使用self
        //this->m_value = v;//错误，不能使用this
		self.m_value = v;	//对咯
        return self;
	}
private:
	double m_value{};
};
```

成员函数使用了推导this，那么此函数里面就不能使用`this`指针了，必须使用参数名，比如这里的`self`。你不必用名字 `self`， 但我觉得它们是最清晰的名字，并且也和别的编程语言一样。

调用带推导this的函数：

```cpp
void t() {
	Number num(10);
	num.setValue(20);
}
```

虽然带了推导this，但是调用时不需要自己传递参数，C++编译器也会自动帮你传递的。

## 静态(static)成员

静态成员是**属于类**本身而**不是类的实例**的成员。使用*static*关键字可以将类成员定义为静态的。静态成员在类的所有对象中共享，无论创建多少个对象，静态成员都只有一个副本。静态成员包括**静态数据成员**和**静态成员函数**。

### 静态成员变量

静态数据成员不能在类定义中初始化，因为它们不属于任何单个对象。它们必须在类外部使用范围解析运算符*::*进行初始化。静态数据成员通常用于存储类级别的信息，例如，跟踪创建的对象数量。

> static 成员变量和普通 static 变量一样，都在内存分区中的全局数据区分配内存，到程序结束时才释放。这就意味着，static 成员变量不随对象的创建而分配内存，也不随对象的销毁而释放内存。而普通成员变量在对象创建时分配内存，在对象销毁时释放内存。

如下代码展示了如何定义静态成员变量：

```cpp
class ZcEntity{
public:
    static const char* ClassName;
};
```

如何访问静态成员变量呢？

```cpp
//1,通过对象访问
ZcEntity entity;
entity.ClassName = "ZcEntity1";
std::println("ClassName: {}", entity.ClassName);

//2,直接通过类名访问
ZcEntity::ClassName = "ZcEntity2";
std::println("ClassName: {}", ZcEntity::ClassName);
```

但是当编译的时候，就直接报错了：

```css
error LNK2001: 无法解析的外部符号 "public: static char const * const ZcEntity::ClassName" (?ClassName@ZcEntity@@2PEBDEB)
```

这个错误很熟悉了对吧，原因就是找不到`ZcEntity::ClassName`变了的定义，咦，不是定了吗？其实在类里面那个叫做声明，并不是定义！！！

必须要在类外进行定义，定义方式如下：

```cpp
class ZcEntity{
public:
    static const char* ClassName;
};
const char* ZcEntity::ClassName = "zcEntity";
```

定义之后，再运行，即可得到如下结果：

```cpp
ClassName: ZcEntity1
ClassName: ZcEntity2
```

**注意：**在C++17及之后的版本中，还有一种简单的定义静态变量的写法：

```cpp
class ZcEntity{
public:
    inline static const char* ClassName  = "zcEntity";
};
```

就是直接把静态变量的申明和定义放在一起，只需要在static关键字之前加上inline关键字即可！

### 静态成员函数

static 除了可以声明静态成员变量，还可以声明静态成员函数。静态成员函数可以在没有类实例的情况下调用。它们只能访问静态数据成员和其他静态成员函数。静态成员函数没有`this`指针，因此不能访问非静态成员。

封装函数返回`ClassName`静态变量的值，我们可以先用非静态成员函数来返回：

```cpp
const char* GetClassName() {
	return ClassName;
}
```

但是这个函数就必须通过对象来调用了：

```css
ZcEntity e;
e.GetClassName();
```

因为这个函数里面没有访问任何非静态成员，所以可以让这个函数也变成静态成员函数，通过类名就可以访问：

```cpp
static const char* GetClassName() {
	return ClassName;
}
```

这样就可以直接通过类名访问了，当然通过对象也还是可以访问的：

```cpp
ZcEntity::GetClassName();
```

所以说静态成员函数调用方式，有两种：

+ 和普通成员函数一样，通过对象去调用        e->ClassName();
+ 不定义对象，直接通过`类名::函数名`去调用  ZcEntity::ClassName();

**思考：为什么静态成员函数不能调用类的非静态成员？**

## 常(const)成员

在类中，如果你不希望某些数据被修改，可以使用`const`关键字加以限定。const 可以用来修饰成员变量和成员函数。

### const成员变量

const 成员变量的用法和普通 const 变量的用法相似，只需要在声明时加上 const 关键字。初始化 const 成员变量只有一种方法，就是通过构造函数的初始化列表。

如下，定义一个`Shape`形状类，然后定义一个形状类型的常量，一旦初始化就不能进行修改了！

```cpp
class Shape {
public:
	enum Type {
		None,
		Rect,
		Circle,
		Triangle
	};
public:
	Shape() {};
private:
	const Type m_type;
};
```

此时运行，会报错`error C2789: “Shape::m_type”: 必须初始化常量限定类型的对象`，也就是说你定义了常量成员变量，那么这个常量必须初始化！怎么初始化呢？使用初始化列表即可！

```cpp
	Shape()
		: m_type(None)
	{}
	
	Shape(Type type)
		: m_type(type)
	{ }
```

然后还可以提供两个函数，用来获取type和type的名称：

```cpp
	int type() {
		return m_type;
	}

	const char* typeName() {
#define XXX(type) case type: return #type
		switch (m_type) {
			XXX(None);
			XXX(Rect);
			XXX(Circle);
			XXX(Triangle);
		}
#undef XXX
		return "None";
	}
```

调用测试：

```cpp
int main()
{
	Shape rect(Shape::Rect);
	std::println("type is {},name is {}", rect.type(), rect.typeName());
	return 0;
}
```

### const成员函数

const 成员函数可以使用类中的所有成员变量，但是不能在函数里面修改它们的值，这种措施主要还是为了保护数据而设置的。const 成员函数也称为常成员函数。

定义常成员函数其实很简单，只需要在成员函数声明和实现的函数头结尾都加上`const`关键字即可，请看下面的例子：

```cpp
	int type()const {
		return m_type;
	}
```

这里，直接给上面`Shape`类的`type`函数加上了const，此时这个成员函数就变成了常成员函数。其实常成员函数就是用在那些获取值，而不需要修改值的成员函数上的。

因为在常成员函数内部是不能修改成员变量的值的。

```cpp
public:
	float x()const {
		return m_x;
	}
	float y()const {
		return m_y;
	}

	void setX(float x)const {
		m_x = x;		// error C3490: 由于正在通过常量对象访问“m_x”，因此无法对其进行修改
	}
	void setY(float y) {
		m_y = y;
	}
private:
	const Type m_type;
	float m_x;
	float m_y;
};
```

在上面代码中，我们将`setX`函数设置为常成员函数，那么在其内部，就不能修改成员变量了！其实函数后面加const是给this指针加的。

```cpp
	void setX(/*const Shape* this,*/float x)const {
		this->m_x = x;
	}
```

如果你查看this指针的类型，将会发现此时`this`的类型是`const Shape* this`，而非常成员函数的this指针类型是`Shape*this`，这就是在常成员函数内部不能修改成员变量的原因！

### 在常成员函数中修改成员变量

我们知道了常成员函数不能修改成员变量的原因，我们就有方法可以解决不能修改的问题。

#### 强转this指针

可以通过将this指针从`const Shape*`强转为`Shape*`类型，然后在通过转换后的指针修改成员变量。

```cpp
	void setX(/*const Shape* this,*/float x)const {
		//this->m_x = x;
		((Shape*)this)->m_x = x;		//强转之后再修改
	}
```

当然这种方法比较别扭，其实C++考虑到了这种情况！

#### mutable

**mutable** 是 C++ 中的一个关键字，用于修饰类的非静态成员变量。它的主要作用是允许这些变量在 *const* 成员函数中被修改，从而突破 *const* 的限制。其中文含义为“可变的”，与 *const*（不可变的）形成对比。

在 C++ 中，*const* 成员函数通常用于保证不会修改类的状态。然而，有时需要在 *const* 函数中修改一些与类状态无关的成员变量，例如缓存、计数器等。此时，可以通过 *mutable* 关键字来实现。

```cpp
	...
	void setY(float y)const {
		m_y = y;			//可以直接在常成员函数中修改使用mutable修饰的变量
	}
private:
	const Type m_type;
	float m_x;
	mutable float m_y;		//使用mutable申明变量
};
```

### 常量对象

**常量对象**（const object）是指在定义对象时使用*const*关键字修饰的对象。这种对象的成员变量值不可修改，因此在定义对象时必须初始化。常量对象只能调用**常量成员函数**（const member function），而非常量对象可以调用常量成员函数和非常量成员函数。

比如，Shape中有如下两个成员函数，一个是`常成员函数`，另一个是`非常成员函数`。

```cpp
	void setY(float y)const {
		m_y = y;
	}

	void move(float x, float y) {
		m_x = x;
		m_y = y;
	}
```

非常量对象，可以调用任意函数：

```cpp
Shape rect(Shape::Rect);
rect.move(1,2);		//调用非常量成员函数
rect.x();			//调用常成员函数
```

常量对象，只能调用常成员函数：

```cpp
const Shape crect(Shape::Rect);
crect.move(1,2);	//调用非常量成员函数,error C2662: “void Shape::move(float,float)”: 不能将“this”指针从“const Shape”转换为“Shape &”
crect.x();			//调用常成员函数
```

常对象，在调用非常成员函数时报错了！

## 友元(friend)

友元（Friend）的概念允许某些特定的非成员函数或其他类的成员函数访问当前类的私有（private）和保护（protected）成员。友元可以是单个函数，也可以是整个类，当一个类被声明为另一个类的友元时，它的所有成员函数都可以访问另一个类的非公开成员。

### 友元函数(Friend Function)

友元函数**不是类的成员函数**，但它可以**访问类的所有私有和保护成员**。这些函数在类外部定义，但需要在类内部声明，并在声明前加上`friend`关键字。友元函数的声明不受类的访问修饰符`public`或`private`的限制。例如，重载输出运算符*<<*时，由于需要访问类的私有数据，可以将其声明为友元函数：

友元函数是指某些虽然不是类成员函数却能够访问类的所有成员的函数。就像好朋友一样，有钱一起花~

#### 全局函数作为友元函数

```cpp
class Vector2 {
public:
	Vector2()
		: m_x(), m_y() 
	{ }

	Vector2(float x, float y)
		: m_x(x),m_y(y)
	{ }

	float x()const { return m_x; }
	float y()const { return m_y; }

	void setX(float x) { m_x = x; }
	void setY(float y) { m_y = y; }
private:
	float m_x;
	float m_y;
private:
    //将全局函数声明为类的友元函数
	friend void log(const Vector2& vec);
};

void hlog(const Vector2& vec) {
	std::println("Vector2({},{})", vec.x(), vec.y());	//-- 常规访问
	std::println("Vector2({},{})", vec.m_x, vec.m_y);	//-- 友元函数直接访问私有成员
}

int main()
{
	Vector2 vec(1, 2);
	log(vec);
	return 0;
}
```

我们在`Vector2`类中把`hlog`函数声明为了友元函数，这样子就可以在`hlog`函数中访问`Vector2`类的私有成员了~

#### 成员函数作为友元函数

我们再定义一个`HLog`类，提供`log`函数，实现`Vector2`的打印。

```cpp
class HLog{
public:
	void log(const Vector2& vec){
        std::println("Vector2({},{})", vec.x(), vec.y());
    }
};
```

大家注意到，我们在实现`log`函数时，必须先通过函数访问坐标，然后再打印，比较麻烦，要是能直接访问私有成员就方便很多了！如下所示：

当然，现在是不可以访问的，必须把`log`函数声明为`Vector2`类的友元函数才行！声明方式如下：

```cpp
	...
private:
	friend void log(const Vector2& vec);
	friend void HLog::log(const Vector2& vec);
};
```

但是运行的时候，在声明友元函数的地方报错了` error C2653: “HLog”: 不是类或命名空间名称`。因为在`Vector2`类中申明的时候，`HLog`类还没有定义，所以编译器不认识`HLog`。

但是如果把`HLog`放到`Vector2`之前定义，那么`log`函数的参数中的`Vector2`又找不到了！！也就是说，这两个类相互依赖了，怎么办呢？

很简单，先把`HLog`类放到`Vector2`类之前定义，接着在`HLog`类之前申明一下`Vector2`类，然后将`HLog`类中的`log`函数定义在`Vector2`类之后即可！

```cpp
//声明Vector2类，为了在HLog类中使用引用不报错
class Vector2;

//定义HLog类
class HLog{
public:
	void log(const Vector2& vec);
};

//定义Vector2类
class Vector2 {
public:
	Vector2()
		: m_x(), m_y() 
	{ }

	Vector2(float x, float y)
		: m_x(x),m_y(y)
	{ }

	float x()const { return m_x; }
	float y()const { return m_y; }

	void setX(float x) { m_x = x; }
	void setY(float y) { m_y = y; }
private:
	float m_x;
	float m_y;
private:
	friend void log(const Vector2& vec);
	friend void HLog::log(const Vector2& vec);
};

//在Vector2类定义之后实现log函数
void HLog::log(const Vector2& vec) {
	std::println("Vector2({},{})", vec.x(), vec.y());	//-- 常规访问
	std::println("Vector2({},{})", vec.m_x, vec.m_y);	//-- 友元函数直接访问私有成员
}
```

一个类的成员函数作为另一个类的友元函数的时候，这个成员函数必须在类外实现，而且是必须在作为友元的类之后实现。

### 友元类(Friend class)

当一个类被声明为另一个类的友元类时，前者的所有成员函数都成为后者的友元函数，从而可以访问后者的非公开成员。友元类的声明只需要在类中使用`friend class 类名;`的形式。友元关系是单向的，不具有交换性，也不可传递。

```cpp
class Vector2;

class HLog{
public:
	void log(const Vector2& vec);

	void test_vector2();
};

class Vector2{
    ...
private:
	friend void log(const Vector2& vec);
	//friend void HLog::log(const Vector2& vec);
	friend class HLog; 
};

void HLog::log(const Vector2& vec) {
	std::println("Vector2({},{})", vec.x(), vec.y());	//-- 常规访问
	std::println("Vector2({},{})", vec.m_x, vec.m_y);	//-- 友元函数直接访问私有成员
}

void HLog::test_vector2()
{
	Vector2 vec(100, 20);
	std::println("Vector2({},{})", vec.m_x, vec.m_y);	
}
```

在`Vector2`类中，把`HLog`类声明为了友元类，此时在`HLog`类中，就可以随心所欲的访问`Vector2`类的私有成员了！

### 友元的优缺点

友元的主要优点在于提高程序的运行效率，因为它减少了函数调用时的参数传递、类型检查和安全性检查的开销。此外，它避免了将所有成员声明为*public*，从而在一定程度上保护了数据成员的安全。

然而，友元也有其缺点，它破坏了类的封装性和隐藏性，使得类的私有数据对外暴露，这可能导致程序的可维护性变差。因此，在使用友元时需要谨慎，只有在确实需要时才使用，以保持类的封装性和数据的安全性。

在实际应用中，友元函数通常用于操作符重载和类之间的密切协作场景。例如，当两个类需要共享数据或一个类需要访问另一个类的内部实现时，可以使用友元来实现这种访问。但是，**应尽量避免过度使用友元，以免破坏类的封装性和降低代码的可读性和可维护性**。

## 成员指针

**成员函数指针**是一种特殊的指针类型，用于存储类中某个特定成员函数的访问信息。它与普通函数指针不同，因为它必须绑定到某个对象实例才能调用。

### 成员变量指针

#### 非静态成员变量指针

非静态成员变量，使用如下语法来定义：

```cpp
变量类型 (类名::*指针名) = &类名::成员变量;
```

使用则需要使用如下语法：

```cpp
实例对象.*指针名
```

定义成员变量指针：

```cpp
 int A::*p = &A::num;
```

通过成员变量指针访问成员变量：

```cpp
A a(22);
cout<<" "<<a.*p;
```

#### 静态成员变量指针

静态成员方法属于类而非对象，在程序运行前分配地址，因此可以像C语言函数一样使用。通过`&类::成员方法`可以获取到函数指针。

定义静态成员变量指针：

```cpp
int *p = &A::static_number;
```

直接访问

```cpp
cout<<" "<<*p;
```



### 成员函数指针

#### 非静态成员函数指针

非静态成员函数，使用如下语法来定义：

```cpp
返回类型 (类名::*指针名)(参数列表) = &类名::成员函数;
```

使用则需要使用如下语法：

```cpp
(实例对象.*指针名)();		//非指针对象
(实例对象->*指针名)();		//指针对象
```

定义成员函数指针:

```cpp
void (A:: * pshow)() = &A::show;
```

通过成员函数指针调用成员函数

```cpp
//在类外调用
(a.*pshow)();
//在类内调用
(this->*pshow)();
```

#### 静态成员函数指针

定义静态成员变量指针：

```cpp
void (A:: * pstatic_show)() = &A::static_show;
```

可以通过对象访问

```cpp
A a(22);
cout<<" "<<(a.*pstatic_show);
```

也可以直接访问

```cpp
cout<<" "<<pstatic_show();
```



