# 可变参数模板

## 可变参数模板的概念和语法

如果一个函数需要的参数个数以及参数类型不确定时，我们急需一种能够让参数可变的方法！

+ 在参数类型一致，参数个数不同时可以使用`initializer_list`
+ 在参数类型不一致时，需要使用C++提供的可变参数模板

来个代码：

```cpp
template<typename ...Args>
void foo(Args ...args)
{
	cout << __FUNCSIG__ <<" args count：" << sizeof...(args);
}
```

在上面的代码中`class ...Args`是类型模板形参包，他可以接受零个或者多个类型的模板实参。`Args ...args`叫做函数形参包，它出现在函数的形参列表中，可以接受零个或者多个函数实参。`sizeof...(args)` 其中`sizeof...`是C++的运算符，专门用来获取形参包的参数个数。

以上这些语法概念看起来可能会有点复杂。不过没关系，结合下面的例子会发现这个语法实际上非常明了：

```cpp
int main()
{
	foo();					//foo<>;
	foo(1);					//foo<int>;
	foo(1, 'A');			//foo<int,char>;
	foo(1, 2,"hello");		//foo<int,int,const char*>;
	return 0;
}
```

以上是一个变参函数模板，它可以接受任意多个实参，编译器会根据实参的类型和个数推导出形参包的内容，然后生成对应的**实例化函数**。

需要注意的是，函数形参包可以与普通形参结合，但是对于结合的顺序有一些特殊要求。

对于函数模板而言，模板形参包不必出现在最后，只要保证后续的形参类型能够通过实参推导或者具有默认参数即可，例如：

```cpp
template<typename ...Args,typename T,typename U = double>
void foo(T t,U u,Args ...args)	//Args ...args这里必须放到最后
{}
```

虽然以上介绍的都是类型模板形参，但是实际上非类型模板形参也可以作为形参包，而且相对于类型形参包，非类型形参包则更加直观：

```cpp
template<int ...Args>
void bar(){}

int main()
{	
	bar<1, 2, 3, 4, 5>();
}
```

## 形参包展开

虽然上一节已经简单介绍了可变参数模板的基本语法，但是大家应该已经注意到，节中的例子并没有实际用途，函数体都是空的。实际上，它们都缺少了一个最关键的环节，那就是形参包展开，简称包展开。只有结合了包展开，才能发挥变参模板的能力。需要注意的是，包展开并不是在所有情况下都能够进行的，允许包展开的场景包括以下几种。

1. 表达式列表。

2. 初始化列表。

3. 基类描述。
4. 成员初始化列表。

5. 函数参数列表。

6. 模板参数列表。

7. 动态异常列表（C++17已经不再使用）。

8. lambda表达式捕获列表。

9. Sizeof…运算符。

10. 对其运算符。

11. 属性列表。

虽然这里列出的场景比较多，但是因为大多数是比较常见的场景，所以理解起来应该不会有什么难度。让我们通过几个例子来说明包展开的具体用法：

```cpp
template<typename T>
T print(T t)
{
	cout << t << endl;
	return t;
}

template<class ...Args>
void unpack(Args ...args) {}

template<typename ...Args>
void foo(Args ...args)
{
	unpack(print(args)...);
}

int main()
{
	foo(1, 5.0, 8);
}
```

在上面的代码中，print是一个普通的函数模板，它将实参通过std::cout输出到控制台上。unpack是一个可变参数的函数模板，不过这个函数什么也不做。在main函数中调用了foo函数模板，并传递了参数，在它的函数体里面对形参包进行了展开，其中`print(args)...`是包展开，而`print(args)`就是模式，也可以理解为包展开的方法。所以这段代码相当于：

```cpp
void foo(int a1, double a2, int a3)
{
	unpack(print(a1), print(a2), print(a3));
}
```

对于这个代码来说，就非常清晰了，其实unpack这个空函数，就是用来容纳包展开的内容的，那么是不是也可以通过一个数组做到这个事情呢？

```cpp
template<typename ...Args>
void foo(Args ...args)
{
	//unpack(print(args)...);
	auto arr = {(print(args),0)...};
}
```

这样的话，我们就不需要再写一个unpack的函数了，更为简洁！！！

## 可变参数模板的递归

### 递归输出所有参数

在上面的形参包展开中也能输出所有参数，但是比较麻烦，接下来看一下递归方式输出，比如下面的案例：

```cpp
template<typename T,typename ...Args>
void foo(T t,Args ...args)
{
	cout << t << endl;
}
```

在这里只能获取到第一个参数，至于args需要展开才能得到，我们可以用递归的方法实现。

```cpp
template<typename T,typename ...Args>
void foo(T t,Args ...args)
{
	cout << t << endl;
    foo(args...,0);
}
```

这样就可以打印出所有的实参了，但是会发现递归没有停止，最终会爆栈，所以必须像一个办法终止递归！

**方法一：传入一个结束数据**

```cpp
template<typename T,typename ...Args>
void foo(T t,Args ...args)
{
    if(t == 0)
        return;
	cout << t << endl;
    foo(args...,0);
}
```

在这里仅仅是加了一个判断，当t == 0，也是就是`  foo(args...,0);`这个调用的最后一个参数时，退出递归！当然这个有个坏处，就是当调用者的参数中出现了0时，递归会提前结束。

**方法二：使用函数重载**

```cpp
template<typename T>
void foo(T t)
{
	cout << t << endl;
}

template<typename T, typename ...Args>
void foo(T t, Args ...args)
{
	cout << t << endl;
	foo(args...);
}
foo(1, 2, 3);
```

在这里首先调用有参数包的foo函数，先把t输出，然后递归，此时会把2,3传给自己，然后t就为2，继续调用foo，此时会发现参数只有一个，值为3,他就会去调用`void foo(T t)`这个版本的函数，然后退出！

### 递归计算

在C++11标准中，要对可变参数模板形参包的包展开进行逐个计算需要用到递归的方法。

```cpp
template<class T>
T sum(T arg)
{
	return arg;
}

template<typename T,typename ...Args>
auto sum(T arg, Args ...args)
{
	return arg + sum(args...);
}
int main()
{
	cout << sum(1, 2, 3, 4) << endl;	//10
}
```

在上面的代码中，当传入函数模板sum的实参数等于1是，编译器会选择调用`T sum(T arg)`,该函什么也没做，直接把传入的参数返回。当传入的实参数量大于1是，编译器会选择调用`auto sum(T arg, Args ...args)`，注意，这里使用C++14的特性将auto作为返回类型的占位符，吧返回类型的推导交给编译器。这个函数除了第一个形参之外，其他形参作为递归调用了sum函数，然后将其结果与第一个形参求和。最终编译器生成的结果应该和下面的伪代码类似:

```cpp
sum(double arg)
{
 return arg;
}
sum(double arg0, double args1)
{
 return arg0 + sum(args1);
}
sum(int arg1, double args1, double args2)
{
 return arg1 + sum(args1, args2);
}
int main()
{
 std::cout << sum(1, 5.0, 11.7) << std::endl;
}
```

## 折叠表达式

在前面的例子中，我们提到了利用数组和递归的方式对形参包进行计算的方法。这些都是非常实用的技巧，解决了C++11标准中包展开方法并不丰富的问题。不过实话实说，递归计算的方式过于烦琐，数组和括号表达式的方法技巧性太强也不是很容易想到。为了用更加正规的方法完成包展开，C++委员会在**C++17**标准中引入了折叠表达式的新特性。让我们使用折叠表达式的特性改写递归的例子：

```cpp
template<typename ...Args>
auto sum(Args ...args)
{
	return (args + ...);
}

int main()
{
 	std::cout << sum(1, 5.0, 11.7) << std::endl;
}
```

如果你是第一次接触折叠表达式，一定会为以上代码的简洁感到惊叹。在这份代码中，我们不再需要编写多个sum函数，然后通过递归的方式求和。需要做的只是按照折叠表达式的规则折叠形参包(args + ...)。根据折叠表达式的规则，(args + ...)会被折叠为arg0 + (arg1 + arg2)，即1 + (5.0 + 11.7)。

到此为止，大家应该已经迫不及待地想了解折叠表达式的折叠规则了吧。那么接下来我们就来详细地讨论折叠表达式的折叠规则。

在C++17的标准中有4种折叠规则，分别是一元向左折叠、一元向右折叠、二元向左折叠和二元向右折叠。上面的例子就是一个典型的一元向右折叠：

```cpp
(args op ...)折叠为(arg0 op (arg1 op ... (argN-1 op argN)))
```

对于一元向左折叠而言，折叠方向正好相反：

```cpp
(... op args )折叠为((((arg0 op arg1) op arg2) op ...) op argN)
```

二元折叠总体上和一元相同，唯一的区别是多了一个初始值，比如二元向右折叠：

```cpp
(args op ... op init )折叠为(arg0 op (arg1 op ...(argN-1 op (argN op
init)))
```

二元向左折叠也是只有方向上正好相反：

```cpp
(init op ... op args )折叠为(((((init op arg0) op arg1) op arg2) op
...) op argN)
```

虽然没有提前声明以上各部分元素的含义，但是大家也能大概看明白其中的意思。这其中，args表示的是形参包的名称，init表示的是初始化值，而op则代表任意一个二元运算符。值得注意的是，在二元折叠中，两个运算符必须相同。

在折叠规则中最重要的一点就是操作数之间的结合顺序。如果在使用折叠表达式的时候不能清楚地区分它们，可能会造成编译失败，例如：

```cpp
template<typename ...Args>
auto sum(Args ...args)
{
	return (args + ...);
}

int main()
{
	cout << sum(std::string("hello "), "C++", "Maye") << endl;
}
```

上面的代码会编译失败，理由很简单，因为折叠表达式(args +…)向右折叠，所以翻译出来的实际代码是`(std::string("hello ") + ("c++ " + "Maye"))`。但是两个原生的字符串类型是无法

相加的，所以编译一定会报错。要使这段代码通过编译，只需要修改一下折叠表达式即可：

```cpp
template<typename ...Args>
auto sum(Args ...args)
{
	return (... + args);
}
```

这样翻译出来的代码将是`((std::string("hello ") +"c++ ") + "world")`。而std::string类型的字符串可以使用+将两个字符串连接起来，于是可以顺利地通过编译。

最后让我们来看一个有初始化值的例子：

```cpp
template<typename ...Args>
void print(Args ...args)
{
	(std::cout << ... << args) << std::endl;
}
```

在上面的代码中，print是一个输出函数，它会将传入的实参输出到控制台上。该函数运用了二元向左折叠(std::cout <<…<<args)，其中std::cout是初始化值，编译器会将代码翻译为`(((std::cout << std::string("hello ")) << "c++ ")<< "world") << std::endl;`。

## 一元折叠表达式中空参数包的特殊处理

一元折叠表达式对空参数包展开有一些特殊规则，这是因为编译器很难确定折叠表达式最终的求值类型，比如：

```cpp
template<typename ...Args>
auto sum(Args ...args)
{
	return (args + ...);
}
```

在上面的代码中，如果函数模板sum的实参为空，那么表达式args +…是无法确定求值类型的。当然，二元折叠表达式不会有这种情况，因为它可以指定一个初始化值：

```cpp
template<typename ...Args>
auto sum(Args ...args)
{
	return (args + ... + 0);
}
```

这样即使参数包为空，表达式的求值结果类型依然可以确定，编译器可以顺利地执行编译。为了解决一元折叠表达式中参数包为空的问题，下面的规则是必须遵守的。

1. 只有&&、||和,运算符能够在空参数包的一元折叠表达式中使用。

2. &&的求值结果一定为true。

3. ||的求值结果一定为false。

4. ,的求值结果为void()。

5. 其他运算符都是非法的。

```cpp
template<typename ...Args>
auto andop(Args ...args)
{
	return (args && ...);
}
int main()
{
	std::cout<< std::boolalpha << andop()<<std::endl;
}
```

在上面的代码中，虽然函数模板andop的参数包为空，但是依然能成功地编译运行并且输出计算结果true。

## 可变参类模板

我们已经见识了很多函数模板中包展开的例子，但是这些并不是包展开的全部，接下来让我们了解一下在类的继承中形参包以及包展开是怎么使用的：

```cpp
template<typename ...Args>
class Derived : public Args...
{
public:
	Derived(const Args& ...args)
		:Args(args)...
	{}
};

class Base1
{
public:
	Base1() {}
	Base1(const Base1&)
	{
		std::cout << "copy ctor base1" << std::endl;
	}
};

class Base2
{
public:
	Base2() {}
	Base2(const Base2&)
	{
		std::cout << "copy ctor Base2" << std::endl;
	}
	void base2_show()
	{

	}
};

int main()
{
	Base1 b1;
	Base2 b2;
	Derived<Base1, Base2> d(b1, b2);
}
```

在上面的代码中，derived是可变参数的类模板，有趣的地方是它将形参包作为自己的基类并且在其构造函数的初始化列表中对函数形参包进行了解包，其中Args(args)…是包展开，Args(args)是

模式。到此为止读者应该对形参包和包展开有了一定的理解，现在是时候介绍另一种可变参数模板了，这种可变参数模板拥有一个模板形参包，请注意这里并没有输入或者打印错误，确实是模板形参包。之所以在前面没有提到这类可变参数模板，主要是因为它看起来过于复杂。

```cpp
template<template<typename ...> typename ...Args>
class Bar : public Args<int, double>...
{
public:
	Bar(const Args<int, double>&...args)
		:Args<int, double>(args)...
	{}
};

template<typename ...Args>
class Baz1 {};

template<typename ...Args>
class Baz2 {};

int main()
{
	Baz1<int, double> a1;
	Baz2<int, double> a2;
	Bar<Baz1, Baz2>(a1, a2);
}
```

可以看到类模板bar的模板形参是一个模板形参包，也就是说其形参包是可以接受零个或者多个模板的模板形参。在这个例子中，bar<baz1, baz2>接受了两个类模板baz1和baz2。不过模板缺少

模板实参是无法实例化的，所以bar实际上继承的不是baz1和baz2两个模板，而是它们的实例baz1<int, double>和baz2<int,double>。还有一个有趣的地方，template<template<class…> class…Args>似乎存在两个形参包，但事实并非如此。因为最里面的template<class…>只说明模板形参是一个变参模板，它不能在bar中被展开。

## std::tuple

## std::pair