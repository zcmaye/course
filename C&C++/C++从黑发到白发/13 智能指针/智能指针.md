# 智能指针

## 什么是智能指针

智能指针是一个模板类，封装了裸指针，可以对指针进行安全的操作。

+ 使用RAII特点，将对象生命周期使用栈来管理
+ 智能指针区分了所有权，因此使用责任更为清晰
+ 智能指针大量使用操作符重载和函数内联特点，调用成本和裸指针无差别

## 为什么要使用智能指针

一句话：智能指针就是帮我们C++程序员管理动态分配的内存的，它会帮助我们自动释放new出来的内存，从而避免内存泄漏！

内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况，这是C和C++程序员的噩梦之一。

## Vs中内存泄漏检测方法

首先来看一下内存泄漏的案例，以及如何检测内存泄漏。

[CSDN参考](https://www.cnblogs.com/bugfly/p/3917767.html)

**1）实质：**
内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费；

**2）原理：**
内存泄露的关键就是记录分配的内存和释放内存的操作，看看能不能匹配。跟踪每一块内存的生命周期；

**3）方法：**不同开发环境有不同的检测方法，在VS中使用时，需加上

```cpp
#define _CRTDBG_MAP_ALLOC
#include<crtdbg.h>
```

crtdbg.h的作用是将malloc和free函数映射到它们的调试版本_malloc_dbg和_free_dbg，这两个函数将跟踪内存分配和释放（在Debug版本中有效）

```cpp
_CrtDumpMemoryLeaks();
```

函数将显示当前内存泄露，也就是说程序运行到此行代码时的内存泄露，所有未销毁的对象都会报出内存泄露，因此要让这个函数尽量放到最后(放在主函数return 0；前面即可)。

```cpp
//Vs中检测内存泄漏代码，C/C++通用
#ifdef _DEBUG

#ifdef  __cplusplus
#include<iostream>
#define new   new( _CLIENT_BLOCK, __FILE__, __LINE__)
#else
#define _CRTDBG_MAP_ALLOC
#include<malloc.h>
#include<crtdbg.h>
#include<stdlib.h>
#endif //  __cplusplus

#else
#include<malloc.h>
#endif
//用于atexit注册，会在程序退出时自动调用
void Exit()
{
	_CrtDumpMemoryLeaks();
}
```

测试代码

```cpp
int main()
{
	atexit(Exit);
	int* p = new int[5];
	//delete[] p;
	return 0;
}
/* 输出窗口中显示：
Detected memory leaks!
Dumping objects ->
{157} normal block at 0x00C5E690, 20 bytes long.
 Data: <                > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 
Object dump complete.
*/
```

## unique_ptr

unique_ptr是一种定义在<memory>中的智能指针(smart pointer)。它持有对对象的独有权——两个unique_ptr不能指向一个对象，不能进行复制操作只能进行移动操作。

unique_ptr对象是管理的对象的唯一拥有者：因为当unique_ptr对象释放时会删除它们的托管对象，而不考虑其他指针是否仍然指向相同的对象，从而使指向那里的其他指针指向无效的位置。

unique_ptr对象复制了有限的指针功能，通过操作符*和->(用于单个对象)或操作符\[](用于数组对象)提供对其托管对象的访问。出于安全考虑，它们不支持指针算术运算，只支持移动赋值(禁用复制赋值)。

+ 构造：禁止隐式构造，必须显示构造

  ```cpp
  //管理指针
  unique_ptr<int> up(new int(666));
  std::cout << "up " << *up << endl;
  
  //管理数组指针
  unique_ptr<int[]> up_arr(new int[10] {0});
  for(int i =0;i<10;i++)
  {
  	std::cout << up_arr[i] << " ";
  }
  
  //只能移动
  unique_ptr<int> up1 = up;				//尝试引用已删除的函数
  unique_ptr<int> up1 = std::move(up);	//可以移动
  ```

+ 析构：会自动释放管理的指针，对于普通指针与数组指针有不同的释放方式，可以自己指定删除器

  ```cpp
  void deleter(int* p)
  {
  	delete p;
  }
  
  struct Deleter
  {
  	void operator()(char* c)
  	{
  		delete[] c;
  	}
  };
  
  void test()
  {
  	//指定全局函数为删除器
  	unique_ptr<int, void(*)(int*)> ptri(new int(50), deleter);
  	//指定仿函数为删除器
  	unique_ptr<char, Deleter> ptrc(new char[10], Deleter());
  	//指定lambda表达式为删除器
  	auto deleter = [](double* p) {delete[] p; };
  	unique_ptr<double, decltype(deleter)> ptrd(new double[5], deleter);
  }
  ```

+ **获取管理的指针**，如果unique_ptr为空则返回nullptr。

  注意，对这个函数的调用不会使unique_ptr释放指针的所有权(即，它仍然负责在某个时刻删除托管数据)。因此，该函数返回的值不能用于构造新的托管指针。

  ```cpp
  unique_ptr<int> up(new int(666));
  int* p = up.get();
  cout <<"*p " << *p << endl;
  *p = 20;
  cout << "*p " << *p << endl;
  ```

+ 返回并释放所有权(智能指针管理的指针会变为nullptr)

  这个调用不会销毁管理对象，但是unique_ptr对象从删除对象的责任中解脱出来。其他实体必须在某个时刻负责删除对象。

  ```cpp
  void test()
  {
  	unique_ptr<int> up(new int(666));
  	
  	//返回管理的指针，并释放所有权，必须手动释放ptr
  	int* ptr = up.release();
  
  	cout << "ptr " << *ptr << endl;
  
  	delete ptr;
  }
  ```

+ **reset**

  销毁unique_ptr当前管理的对象(如果有的话)，并获得p的所有权。

  如果p是空指针，unique_ptr将变为空，在调用后不管理任何对象。

  ```cpp
  void test()
  {
  	unique_ptr<int> up;
  				
  	up.reset(new int(-22));		//获取指针的所有权
  	cout << *up << endl;
  
  	up.reset(new int(666));		//释放管理的内存，获取新的指针
  	cout << *up << endl;
  
  	up.reset();						//释放管理的内存
  }
  ```

  

## shared_ptr

unique_ptr是一个独享指针，同一时刻只能有一个unique_ptr指向一个对象，而shared_ptr是一个共享指针，同一时刻可以有多个shared_ptr指向同一对象，但会记录有多少个shared_ptrs共同指向一个对象。这便是所谓的引用计数（reference counting）。

一旦最后一个这样的指针被销毁，也就是一旦某个对象的引用计数变为0，这个对象会被自动删除。这在**非环形数据结构**中防止资源泄露很有帮助。

```cpp

```



+ 构造

  ```cpp
  shared_ptr<int> p1;
  shared_ptr<int> p2(new int(1));
  shared_ptr<int> p3(new int[10]);
  shared_ptr<int> p4(new int(1), [](int* p) {delete p; });
  shared_ptr<int> p5(p4);
  ```

+ use_count

  返回与此对象(包括它)共享同一指针所有权的shared_ptr对象的数量。

  如果这是一个空的shared_ptr，函数返回零。

  库实现不需要保留任何特定所有者集的计数，因此调用此函数可能效率不高。要具体检查use_count是否为1，可以使用member unique代替，这样可能更快。

+ reset

## week_ptr

为了解决循环引用问题，C++11中出现了shared_ptr的辅助类：week_ptr

week_ptr是对对象的一种弱引用，它不会增加对象的引用计数。week_ptr和shared_ptr之间可以相互转换， shared_ptr可以直接赋值给week_ptr，week_ptr可通过调用lock函数来获得shared_ptr(如果对象已经被释放，则返回一个空的shared_ptr)。



