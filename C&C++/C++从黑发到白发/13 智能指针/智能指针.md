# 智能指针

## 什么是智能指针

智能指针是一个模板类，封装了裸指针，可以对指针进行安全的操作。

+ 使用RAII特点，将对象生命周期使用栈来管理
+ 智能指针区分了所有权，因此使用责任更为清晰
+ 智能指针大量使用操作符重载和函数内联特点，调用成本和裸指针无差别

## 为什么要使用智能指针

一句话：智能指针就是帮我们C++程序员管理动态分配的内存的，它会帮助我们自动释放new出来的内存，从而避免内存泄漏！

内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存的情况，这是C和C++程序员的噩梦之一。

## Vs中内存泄漏检测方法

首先来看一下内存泄漏的案例，以及如何检测内存泄漏。

[CSDN参考](https://www.cnblogs.com/bugfly/p/3917767.html)

**1）实质：**
内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该段内存之前就失去了对该段内存的控制，从而造成了内存的浪费；

**2）原理：**
内存泄露的关键就是记录分配的内存和释放内存的操作，看看能不能匹配。跟踪每一块内存的生命周期；

**3）方法：**不同开发环境有不同的检测方法，在VS中使用时，需加上

```cpp
#define _CRTDBG_MAP_ALLOC
#include<crtdbg.h>
```

crtdbg.h的作用是将malloc和free函数映射到它们的调试版本_malloc_dbg和_free_dbg，这两个函数将跟踪内存分配和释放（在Debug版本中有效）

```cpp
_CrtDumpMemoryLeaks();
```

函数将显示当前内存泄露，也就是说程序运行到此行代码时的内存泄露，所有未销毁的对象都会报出内存泄露，因此要让这个函数尽量放到最后(放在主函数return 0；前面即可)。

```cpp
//Vs中检测内存泄漏代码，C/C++通用
#ifdef _DEBUG

#ifdef  __cplusplus
#include<iostream>
#define new   new( _CLIENT_BLOCK, __FILE__, __LINE__)
#else
#define _CRTDBG_MAP_ALLOC
#include<malloc.h>
#include<crtdbg.h>
#include<stdlib.h>
#endif //  __cplusplus

#else
#include<malloc.h>
#endif
//用于atexit注册，会在程序退出时自动调用
void Exit()
{
	_CrtDumpMemoryLeaks();
}
```

测试代码

```cpp
int main()
{
	atexit(Exit);
	int* p = new int[5];
	//delete[] p;
	return 0;
}
/* 输出窗口中显示：
Detected memory leaks!
Dumping objects ->
{157} normal block at 0x00C5E690, 20 bytes long.
 Data: <                > CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD CD 
Object dump complete.
*/
```

## unique_ptr

unique_ptr是一个模板类，用来管理裸指针，提供有限的垃圾回收机制，与内置指针相比几乎没有开销（取决于使用的删除器）。

这些对象具有获得指针*所有权*的能力：一旦获得所有权，它们就会通过在某个时刻负责删除指向的对象来管理指向的对象。

unique_ptr对象是裸指针的唯一拥有者：不能有其他的对象指向该裸指针， 没有其他工具可以删除裸指针对象，因为只要它们必须这样做，unique_ptr对象就会删除它们的托管对象，而不考虑其他指针是否仍然指向相同的对象，从而使指向那里的其他指针指向无效的位置。



## shared_ptr

## week_ptr