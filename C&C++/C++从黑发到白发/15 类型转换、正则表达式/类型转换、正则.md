# 类型转换

在 C++ 中，类型转换分为**隐式类型转换**和**显式（强制）类型转换**。隐式转换由编译器自动完成，而显式转换需要程序员手动指定。相比 C 风格的 `(type)expr`，C++ 提供了更安全、语义更清晰的四种强制转换运算符：`static_cast`、`dynamic_cast`、`const_cast`、`reinterpret_cast`。

## static_cast

`static_cast`用于**基本数据类型转换**和**类层次结构中安全的上行/下行转换**（无运行时检查）。

+ 基本类型转换

  ```cpp
  double score = 59.5;
  int nScore = static_cast<int>(score);
  ```

+ void指针和其他类型指针之间的转换(其他类型指针之间不能转换)

  ```cpp
  void* p = new int(20);
  int* pi = static_cast<int*>(p);
  void* pc = static_cast<void*>(pi);		//这里可以隐式转换，可以省略static_cast
  delete p;
  ```

+ 用于基类派生类之间指针、引用的转换

  ```cpp
  class Base
  {
  public:
  	virtual void show()
  	{
  		std::cout << "Base " << std::endl;
  	}
  };
  
  class Derive :public Base
  {
  	char* name = nullptr;
  public:
  	Derive()
  	{
  		name = new char[5]{ "玩蛇" };
  	}
  	~Derive()
  	{
  		delete name;
  	}
  	void print()
  	{
  		std::cout << "Derive " << name << std::endl;
  	}
  };
  ```

  + **上行转换：**把派生类指针、引用转为基类的指针、引用（可以自动隐式转换）

  ```cpp
  //指针
  Derive* derive = new Derive;
  Base* base = static_cast<Derive*>(derive);
  //引用
  Derive& refDerive = *derive;
  Base& refBase = static_cast<Base&>(refDerive);
  
  delete derive;
  ```

  + **下行转换：**把基类指针、引用转为派生类的指针、引用（必须强制静态转换）

  ```cpp
  Base* base = new Base;
  Derive* derive = static_cast<Derive*>(base);
  derive->print();
  
  delete base;
  ```

  **注意：**下行转换使用`static_cast`不安全，请使用`dynamic_cast`（不安全：因为不知道基类的指针，到底是不是指向的要转换的派生类对象，如果不是，访问数据成员会有错误）

## reinterpret_cast

**reinterpret_cast** 进行**底层位模式的重新解释**，无类型检查，风险高。

**主要用于以下六种情况：**

+ 任意类型指针之间的转换

  ```cpp
  int* p = nullptr;
  char* pc = reinterpret_cast<char*>(p);
  ```

+ 指针转整型，整型转指针

  ```cpp
  int* p = nullptr;
  uint64_t a = reinterpret_cast<uint64_t>(p);	//x64 指针是8个字节，所以要用uint64_t保存，否则可能会丢失数据
  double* pd = reinterpret_cast<double*>(a);
  ```

+ 函数指针也可以转换哦~

  ```cpp
  uint64_t funMax = reinterpret_cast<uint64_t>(_max);
  cout<<reinterpret_cast<int(*)(int, int)>(funMax)(2, 3);
  
  int _max(int a, int b)
  {
  	return a > b ? a : b;
  }
  ```

+ 一个官方案例

  ```cpp
  int arr[10];
  for (int i = 0; i < 10; i++)
  {
  	cout << arr+i <<"  " <<hex<< ::hash(arr+i) << endl;;
  }
  
  uint32_t _hash(void* p)
  {
  	uint64_t val = reinterpret_cast<uint64_t>(p);
  	return val ^ (val >> 32);
  }
  ```

## const_cast

**const_cast** **移除或添加 const/volatile 限定符**，不能改变对象的实际常量性。

+ const指针、引用不能直接赋值给非const的对象，需要去掉const之后再赋值

  ```cpp
  const char* name = "hello";
  char* pname = const_cast<char*>(name);
  
  const int& refA = 8;
  int& refB = const_cast<int&>(refA);
  ```

+ 可以在类的const函数里面修改成员变量

  ```cpp
  class Integer
  {
  private:
  	int number;
  public:
  	Integer(int number = 0)
  		:number(number)
  	{
  	}
  	operator int()const
  	{
  		const_cast<int&>(number)++;		//必须去掉const才能修改
          const_cast<Integer*>(this)->number++;
  		return number;
  	}
  };
  
  Integer num = 10;
  int n = num;		//11
  ```

  

## dynamic_cast

 **dynamic_cast** 用于**多态类型**的安全下行转换，运行时检查类型有效性，失败返回 `nullptr`（指针）或抛异常（引用）。

+ 通过`dynamic_cast`，将派生类指针转换为基类指针（上行转换），这个操作与static_cast的效果是一样的。

+ 通过`dynamic_cast`，将基类指针转换为派生类指针（下行转换），dynamic_cast具有类型检查的功能，比static_cast更安全（如果转换的是指针，失败时会返回空指针；如果转换的是引用，会抛出std::bad_cast异常）



+ 指针转换，转换失败返回nullptr

  ```cpp
  	Animal* dog = new Dog;
  	dog->cry();
  	//转成实际的类型
  	Dog* d = dynamic_cast<Dog*>(dog);
  	if (!d)
  		std::cout << "dog is not Dog" << std::endl;
  	d->cry();
  	//尝试转成其他子类,失败返回nullptr
  	Cat* cat = dynamic_cast<Cat*>(dog);
  	if (!cat)
  		std::cout << "dog is not Cat";
  	else
  		cat->cry();	
  ```

+ 转换引用，转换失败抛异常std::bad_cast

  ```cpp
  Animal& refA = *dog;
  //转成实际的类型
  Dog& refD = dynamic_cast<Dog&>(refA);
  refD.cry();
  //尝试转成其他子类,失败抛异常
  Cat& refC = dynamic_cast<Cat&>(refA);
  refC.cry();
  ```

  

# 正则表达式

正则表达式是一种强大的工具，用于执行**字符串匹配和搜索**。C++11标准引入了正则表达式库，提供了一系列用于处理复杂**字符串模式**的功能。

## 正则基础

### 概念

正则表达式（Regular Expression）是用于描述一组字符串特征的模式，用来匹配特定的字符串。通过特殊字符+普通字符来进行模式描述，从而达到文本匹配目的工具。

正则表达式目前被集成到了各种文本编辑器/文本处理工具当中。

### 应用场景

（1）验证：表单提交时，进行用户名密码的验证。

（2）查找：从大量信息中快速提取指定内容，在一批url中，查找指定url。

（3）替换：将指定格式的文本进行正则匹配查找，找到之后进行特定替换。

### 基本要素

（1）字符类

（2）数量限定符

（3）位置限定符

（4）特殊符号

注意：正则表达式基本是与语言无关的，我们可以结合语言/工具与正则表达式进行文本处理

#### 1，字符类

| 字符 |                        含义                        |                             举例                             |
| :--: | :------------------------------------------------: | :----------------------------------------------------------: |
|  .   |                  匹配任意一个字符                  |                   adc.可以匹配abcd或abc6等                   |
|  []  |              匹配括号中的任意一个字符              |                    [abc]d可以匹配ad,bd,cd                    |
|  -   |                 在[]内表示字符范围                 |         [0-9a-zA-Z]可以匹配任意大写、小写和数字字符          |
|  ^   | 位于括号内的开头，匹配除括号内的字符之外的任意字符 | [^xy]z匹配xy之外的任意字符，可以匹配az、bz,但是不可以匹配xz、yz |

#### 2，数量限定符

| 字符  |                   含义                   |                          举例                          |
| :---: | :--------------------------------------: | :----------------------------------------------------: |
|  ？   |    紧跟在它前面的单元应匹配零次或一次    |    [0-9]?.[0-9]匹配0.0、5.2、.3,匹配.需要使用\转义     |
|   +   |    紧跟在它前面的单元应匹配一次或多次    | [a-zA-Z0-9*]+@[a-zA-Z0-9]+.[a-zA-Z0-9*]+ 匹配email地址 |
|   *   |  紧跟在它前面的单元应匹配匹配零次或多次  |               [0-9] [0-9]*至少匹配一位数               |
|  {N}  |     紧跟在它前面的单元应精准匹配N次      |           [1-9] [0-9]{2}匹配从100到999的整数           |
| {N,}  |    紧跟在它前面的单元应匹配至少一N次     |        [1-9] [0-9]{2,}匹配大于等于三位数的整数         |
| {0,M} |     紧跟在它前面的单元应匹配最多M次      |          [0-9]{,2}匹配空或者匹配小于99的整数           |
| {N,M} | 紧跟在它前面的单元应匹配至少N次，最多M次 |       [0-9]{1,3}. [0-9]. [0-9]. [0-9]匹配IP地址        |

#### 3，位置限定符

| 字符 | 含义                       | 举例                                   |
| ---- | -------------------------- | -------------------------------------- |
| ^    | 匹配行首的位置             | ^maye匹配一行开头的maye                |
| $    | 匹配行末的位置             | ;$匹配位于一行结尾的;号<br>^\$匹配空行 |
| \b   | 匹配单词开头或结尾的位置   | at\b 匹配at不能匹配att                 |
| \B   | 匹配非单词开头或结尾的位置 |                                        |

#### 4，特殊符号

| 字符 | 含义                                                         | 举例                |
| ---- | ------------------------------------------------------------ | ------------------- |
| \    | 转义字符                                                     |                     |
| ()   | 将正则表达式的一部分括起来组成一个单元，可以对整个单元使用数量限定符 |                     |
| \|   | 连接两个子表达式，表示或的关系                               | n(o\|ot)匹配no或not |

#### 5，其他普通字符及其替换

| 符号 | 替换正则    | 匹配                 |
| ---- | ----------- | -------------------- |
| \d   | [0-9]       | 数字字符             |
| \D   | [^0-9]      | 非数字字符           |
| \w   | [a-zA-Z0-9] | 数字、字母、下划线   |
| \W   | [^\w]       | 非数字、字母、下划线 |
| \s   | [\r\t\n\f]  | 表格、换行等空白区域 |
| \S   | [^\s]       | 非空白区域           |

### 简单练习

[Regex正则表达式在线测试、生成、解析工具 - GoRegex.cn](https://goregex.cn/)

[正则表达式在线测试 | 菜鸟工具 (runoob.com)](https://c.runoob.com/front-end/854/)

[正则表达式的语法汇总](https://blog.csdn.net/qq28129019/article/details/115913596)

## C++正则

### regex算法

#### 匹配(regex_match)

判断**整个字符串**是否完全符合正则表达式的规则，返回`bool`值（`true`= 完全匹配，`false`= 不完全匹配）。

##### 1，是否匹配

###### 匹配测试

regex_match有几种传递字符串的方式：

```cpp
void match()
{
    std::regex pattern(R"(\d{11})");  //-- "\\d{11}"
    std::string str("13123415661");

    bool is_valid1 = std::regex_match(str.data(), pattern);                //const char*
    bool is_valid2 = std::regex_match(str, pattern);                       //string
    bool is_valid3 = std::regex_match(str.begin(),str.end(), pattern);     //[first last]

    std::println("is_valid1: {}", is_valid1);
    std::println("is_valid2: {}", is_valid2);
    std::println("is_valid3: {}", is_valid3);
}
```

###### 匹配手机号

```cpp
{
	//1，匹配手机号码
	std::vector<std::string> phone = {
		"13187050605","15675879209","18570365828","19198143084","11363691460"
	};
	for (auto& p : phone) {
		CHECK(std::regex_match(p, std::regex(R"(\d{11})")));		//只能限制数字
		CHECK(std::regex_match(p, std::regex(R"(^1[3-9]\d{9}$)")));	//必须以1开头，第二位必须在3-9之间
		CHECK(std::regex_match(p, std::regex(R"(^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d{8}$)")));	//指定运营商号段
	}
}    
```



##### 2，匹配结果

更多的时候我们希望能够获得匹配结果（字符串），对结果进行操作。这时就需要对匹配结果进行存储

```cpp
	{
		//完全匹配
		CHECK(std::regex_match("我的电话号码是13187050605，你记住了吗?", std::regex(R"(^\d{11}$)")));		//Not Match
		//部分匹配
		//CHECK(std::regex_match("我的电话号码是13187050605，你记住了吗?", std::regex(R"(^.*\d{11}.*$)")));	//Match
		//1,使用要匹配的字符串类型为const char*，对应的匹配结果类型为cmatch
		{
			std::cmatch match_result;
			CHECK(std::regex_match("我的电话号码是13187050605，你记住了吗?", match_result, std::regex(R"(^.*(\d{11}).*$)")));	//Match
			if (match_result.ready()) {
				for (auto& ret : match_result) {
					std::println("-> {}", ret.str());
				}
				//-> 我的电话号码是13187050605，你记住了吗?
				//-> 13187050605
			}
		}
		//2,使用要匹配的字符串类型为string，对应的匹配结果类型为smatch
		{
			std::smatch match_result;
			std::string str("我的电话号码是13187050605，你记住了吗?");
			CHECK(std::regex_match(str, match_result, std::regex(R"(^.*(\d{11}).*$)")));	//Match
			if (match_result.ready()) {
				for (auto& ret : match_result) {
					std::println("-> {}", ret.str());
				}
				//-> 我的电话号码是13187050605，你记住了吗?
				//-> 13187050605
			}
		}
	}
```

#### 搜索(regex_search)

在字符串中**查找符合正则的子串**（无需整个字符串匹配），返回`bool`值，同时可通过`std::smatch`获取匹配到的子串内容。

##### 是否查找到

```cpp
void test_search_1()
{
	std::regex pattern(R"((\w+)@(\w+)\.(\w+))");
	std::string str("我的邮箱是zhangsan@163.com，同事的邮箱是lisi@gmail.com，还有wangwu@qq.com");

	if (std::regex_search(str, pattern)) {
		std::println("查找到了 ");
	}
	else {
		std::println("没有找到哟~");
	}
}
```

##### 查找所有(循环查找)

```cpp
void loopSearch()
{
	std::regex pattern(R"(\w+@\w+\.\w+)");
	std::string str("我的邮箱是zhangsan@163.com，同事的邮箱是lisi@gmail.com，还有wangwu@qq.com");

    std::smatch result;

	auto it = str.cbegin();
	while (regex_search(it, str.cend(), result, pattern)) {
		for (auto& r : result) {
			std::println("{}", r.str());
			it = r.second;
		}
	}
}
```

#### 替换(regex_replace)

替换匹配，即可以将符合匹配规则的子字符串替换为其他字符串。要求输入一个正则表达式，以及一个用于替换匹配子字符串的格式化字符串。

##### 1,替换

```cpp
void replace()
{
    regex pattern("(hi|u|c)");
    string str = "oh!shit!fuck you!";
    cout<< regex_replace(str, pattern,"*");
}
```

以上代码会把str中所有的hi|u|uc替换成*，并返回一个新的string对象(str没有改变)，如果只想替换第一个匹配的，可以给`regex_replace`加上标志。

```
regex_replace(str, pattern,"*",regex_constants::format_first_only);
```

这样的话就只会把shit变为s*t,其他的不会改变。关于标志请参考[微软文档](https://learn.microsoft.com/zh-cn/cpp/standard-library/regex-constants-class?view=msvc-170)。

**除了以上方法之外还有一种方法操作。**

```cpp
    //1，复制 [first,last) 中的字符到 out ，以 re 所格式化的字符替换任何匹配 fmt 的序列
    //string output;
    //output.resize(str.size());    //注意访问越界问题
    //regex_replace(output.begin(), str.cbegin(), str.cend(), pattern, "*");
    //cout << "output:" << output << endl;
    //1.1同上，只不过传入的是char*数组
    char buf[1024] = {0};
    regex_replace(buf, str.cbegin(), str.cend(), pattern, "*");
    cout << "buf:" << buf << endl;

    //1.2 写结果到输出迭代器
    regex_replace(std::ostreambuf_iterator<char>(std::cout), str.begin(), str.end(), pattern, "*");
```

#### 捕获组(captrue group)

在正则表达式中，**分组**是用小括号 `()` 将子表达式括起来，将多个字符视为一个整体进行匹配。**捕获**则是在匹配后将该分组的内容保存下来，以便后续引用或提取。

**常见分组类型**

- **捕获分组** `(exp)`：匹配并保存内容，自动编号从1开始，组0代表整个匹配结果。
- **非捕获分组** `(?:exp)`：仅分组但不保存内容，不占用编号。

有如下字符串，现在需要提取所有邮箱以及邮箱每部分内容(名称，主机名以及后缀)：

```cpp
std::string str("我的邮箱是zhangsan@163.com，同事的邮箱是lisi@gmail.com，还有wangwu@qq.com");
```

正则模式如下，将需要捕获的内容用`()`括起来，搜索后会自动保存起来：

```cpp
std::regex pattern(R"((\w+)@(\w+)\.(\w+))");
```

开始搜索：

```cpp
std::smatch result;
bool is_searched = std::regex_search(str, result, pattern);
```

如果有搜索结果返回true，没有返回false：

```cpp
    //找到一个匹配的之后，立马返回
    if (is_searched) {
        //1，通过下标访问捕获内容
		std::println("email:{}", result[0].str());
		std::println("name:{}", result[1].str());
		std::println("domain:{}", result[2].str());
		std::println("suffix:{}", result[3].str());

        //2，通过循环遍历捕获内容
        for (auto& r : result) {
            std::println("-> {}", r.str());
        }
    }
    else {
        std::println("没有找到哟~");;
    }
```

结果如下：

```css
email:zhangsan@163.com
name:zhangsan
domain:163
suffix:com
-> zhangsan@163.com
-> zhangsan
-> 163
-> com
```

#### 贪婪(greedy)与非贪婪(lazy )

正则中的**贪婪模式与非贪婪模式**（也叫懒惰模式），这是正则匹配中的核心规则，决定了量词（`*`、`+`、`?`、`{n,}`等）的匹配行为。

##### 核心概念

首先明确两个模式的核心区别，关键在于「是否尽可能多的匹配内容」：

1. **贪婪模式（默认模式）**

   正则中的量词默认是贪婪的，即**在满足整体正则规则的前提下，尽可能多地匹配字符**（吃的越多越好）。

   常用贪婪量词：`*`（0 次或多次）、`+`（1 次或多次）、`?`（0 次或 1 次）、`{n,}`（至少 n 次）、`{n,m}`（n 到 m 次）。

   

2. **非贪婪模式（懒惰模式）**

   在贪婪量词后**添加一个`?`**，即可切换为非贪婪模式，即**在满足整体正则规则的前提下，尽可能少地匹配字符**（点到为止即可）。

   常用非贪婪量词：`*?`（0 次或多次，尽可能少）、`+?`（1 次或多次，尽可能少）、`??`（0 次或 1 次，尽可能少）、`{n,}?`（至少 n 次，尽可能少）、`{n,m}?`（n 到 m 次，尽可能少）。

##### 语法对应表

| 贪婪量词 | 非贪婪量词 |         量词含义         |
| :------: | :--------: | :----------------------: |
|   `*`    |    `*?`    | 匹配前面字符 0 次或多次  |
|   `+`    |    `+?`    | 匹配前面字符 1 次或多次  |
|   `?`    |    `??`    | 匹配前面字符 0 次或 1 次 |
|  `{n,}`  |  `{n,}?`   |  匹配前面字符至少 n 次   |
| `{n,m}`  |  `{n,m}?`  |  匹配前面字符 n 到 m 次  |

##### 实战

下面通过两个经典场景，对比贪婪模式与非贪婪模式的差异。

###### 提取成对标签内容

这是最能体现两者差异的场景，非贪婪模式可避免「过度匹配」。

```cpp
int main() {
    // 待匹配的字符串：两个<a>标签
    std::string text = "<a>这是第一个标签</a><a>这是第二个标签</a>";
    
    // 1. 贪婪模式（默认，量词*为贪婪）
    std::regex greedy_regex(R"(<a>.*</a>)"); // .* 贪婪匹配任意字符（除换行）0次或多次
    std::smatch match_result;
    
    std::println("=== 贪婪模式匹配结果 ===");
    std::string::const_iterator it = text.cbegin();
    while (regex_search(it, text.cend(), match_result, greedy_regex)) {
		std::println("匹配到：{}", match_result[0].str());
        it = match_result.suffix().first; // 更新迭代器，继续查找
    }
    
    // 2. 非贪婪模式（量词*后加?，变为*?）
    std::regex non_greedy_regex(R"(<a>.*?</a>)"); // .*? 非贪婪匹配任意字符0次或多次
    it = text.cbegin(); // 重置迭代器
    
    std::println("\n=== 非贪婪模式匹配结果 ===");
    while (regex_search(it, text.cend(), match_result, non_greedy_regex)) {
		std::println("匹配到：{}", match_result[0].str());
        it = match_result.suffix().first; // 更新迭代器，继续查找
    }
    
    return 0;
}
```

**运行结果**

```css
=== 贪婪模式匹配结果 ===
匹配到：<a>这是第一个标签</a><a>这是第二个标签</a>

=== 非贪婪模式匹配结果 ===
匹配到：<a>这是第一个标签</a>
匹配到：<a>这是第二个标签</a>
```

**结果分析**

- 贪婪模式（`.*`）：从第一个`<a>`开始，会一直匹配到**最后一个**`</a>`（尽可能多吃），把两个标签当成一个整体匹配，这不是我们想要的结果。
- 非贪婪模式（`.*?`）：从第一个`<a>`开始，匹配到**第一个**`</a>`就停止（点到为止），正确提取每个独立的标签，这是处理成对结构的常用方案。

###### 提取字符串中的数字（对比`+`与`+?`）

```cpp
int main() {
    std::string text = "num123 num4567 num89";
    
    // 1. 贪婪模式（+ 贪婪匹配1次或多次数字）
    std::regex greedy_regex(R"(\d+)"); // \d+ 贪婪匹配连续数字
    std::smatch match_result;
    
    std::println("=== 贪婪模式提取数字 ===");
    std::string::const_iterator it = text.cbegin();
    while (regex_search(it, text.cend(), match_result, greedy_regex)) {
		std::println("提取到数字：{}", match_result[0].str());
        it = match_result.suffix().first; // 更新迭代器，继续查找
    }
    
    // 2. 非贪婪模式（+? 非贪婪匹配1次或多次数字）
    std::regex non_greedy_regex(R"(\d+?)"); //// \d+? 非贪婪匹配连续数字
    it = text.cbegin(); // 重置迭代器
    
    std::println("\n=== 非贪婪模式提取数字 ===");
    while (regex_search(it, text.cend(), match_result, non_greedy_regex)) {
		std::println("提取到数字：{}", match_result[0].str());
        it = match_result.suffix().first; // 更新迭代器，继续查找
    }
    
    return 0;
}
```

**运行结果**

```css
=== 贪婪模式提取数字 ===
提取到数字：123
提取到数字：4567
提取到数字：89

=== 非贪婪模式提取数字 ===
提取到数字：1
提取到数字：2
提取到数字：3
提取到数字：4
提取到数字：5
提取到数字：6
提取到数字：7
提取到数字：8
提取到数字：9
```

**结果分析**

- 贪婪模式（`\d+`）：匹配连续的数字，尽可能多的提取完整数字（123、4567），符合提取完整数字的需求。
- 非贪婪模式（`\d+?`）：匹配到 1 个数字就停止（满足「1 次或多次」的最低要求），因此会逐个提取单个数字，这在需要拆分数字时有用。

### regex迭代

C++ 正则中的 `std::regex_iterator`（正则迭代器）和 `std::regex_token_iterator`（正则令牌迭代器），这两个迭代器是 `<regex>` 头文件中用于**批量遍历 / 提取匹配结果**的高级工具，相比手动循环调用 `std::regex_search` 更简洁、更符合 C++ 迭代器编程风格。

两者都用于批量处理字符串中的正则匹配结果，**`regex_iterator` 用于遍历所有完整匹配结果，`regex_token_iterator` 用于灵活提取匹配结果 / 捕获组 / 非匹配部分**（功能更强）。

#### 正则迭代([regex_iterator](https://en.cppreference.com/w/cpp/regex/regex_iterator))

`std::regex_iterator` 会**自动遍历字符串中所有符合正则的完整匹配结果**，每一次迭代都返回一个 `std::smatch`（存储当前完整匹配结果），本质是对 `std::regex_search` 循环的封装，用法更简洁。

##### 语法格式

```cpp
// 针对 std::string 的迭代器（常用）
std::regex_iterator<std::string::const_iterator> it(
    str.cbegin(),  // 字符串起始迭代器
    str.cend(),    // 字符串结束迭代器
    regex_obj      // 正则表达式对象
);

// 结束迭代器（默认构造，作为遍历终止条件）
std::regex_iterator<std::string::const_iterator> end_it;
```

##### 实战

需求：从文本中提取所有邮箱地址，使用 `regex_iterator` 遍历结果。

```cpp
int main() {
    // 待处理文本
    std::string text = "我的邮箱：zhangsan@163.com，同事：lisi@gmail.com，朋友：wangwu@qq.com";

    // 正则表达式（匹配简单邮箱）
    std::regex email_regex(R"(\w+@\w+\.\w+)");

    // 定义 regex_iterator 迭代器（开始迭代器 + 结束迭代器）
    std::sregex_iterator it(text.cbegin(), text.cend(), email_regex);
    std::sregex_iterator end_it;    // 结束迭代器（默认构造，标志遍历结束）

    // 遍历所有匹配结果
    std::println("提取到的所有邮箱：");
    std::vector<std::string> emails; // 存储提取结果
    for (; it != end_it; ++it) {
        // *it 等价于当前的 smatch 对象，(*it)[0] 是完整匹配结果
        std::smatch current_match = *it;
        std::string email = current_match.str(); // 等价于 current_match[0].str()
        emails.push_back(email);
        std::println("{} ", email);
    }

    return 0;
}
```

**运行结果**

```css
提取到的所有邮箱：
zhangsan@163.com
lisi@gmail.com
wangwu@qq.com
```

#### 正则令牌迭代([regex_token_iterator](https://en.cppreference.com/w/cpp/regex/regex_token_iterator))

`td::regex_token_iterator` 是 `std::regex_iterator` 的**增强版**，功能更灵活，核心支持 3 种场景：

1. 提取所有完整匹配结果（和 `regex_iterator` 功能一致）。
2. 提取所有指定捕获组的结果（批量提取捕获组，无需手动遍历 `smatch`）。
3. 提取「非匹配部分」（即正则未匹配到的字符串片段，实现字符串分割）。

##### 语法格式

```cpp
// 针对 std::string 的迭代器（常用）
std::regex_token_iterator<std::string::const_iterator> it(
    str.cbegin(),  // 字符串起始迭代器
    str.cend(),    // 字符串结束迭代器
    regex_obj,     // 正则表达式对象
    submatch_idx   // 关键参数：指定提取的内容（整数/整数数组）
);

// 结束迭代器（默认构造）
std::regex_token_iterator<std::string::const_iterator> end_it;
```

**关键参数：`submatch_idx`（核心区别于 `regex_iterator`）**

该参数决定了迭代器提取的内容，支持以下取值：

1. `0`：提取**完整匹配结果**（和 `regex_iterator` 功能一致）。
2. 正整数 `n`（n≥1）：提取**第 n 个编号捕获组**的结果（批量提取，无需手动处理 `smatch`）。
3. 负整数 `-1`：提取**非匹配部分**（即正则匹配结果之间的字符串，用于分割字符串）。
4. 整数数组 / 初始列表：提取**多个指定内容**（如 `{0, 1}` 表示同时提取完整匹配和第 1 个捕获组）。

##### 实战

###### 提取完整匹配结果（等价于 `regex_iterator`）

```cpp
int main() {
    std::string text = "num123 num4567 num89";
    std::regex num_regex(R"(\d+)");

    // 定义 regex_token_iterator，submatch_idx=0（提取完整匹配）
    std::sregex_token_iterator it(text.cbegin(), text.cend(), num_regex, 0);
    std::sregex_token_iterator end_it;

    std::println("提取完整数字（等价于 regex_iterator）：");
    for (; it != end_it; ++it) {
        std::println("{} ", it->str());
    }

    return 0;
}
```

**运行结果**

```css
提取完整数字（等价于 regex_iterator）：
123
4567
89
```

###### 提取指定捕获组结果（批量提取手机号的前缀和后缀）

```cpp
int main() {
    std::string text = "手机号1：13812345678，手机号2：13987654321，手机号3：15012348765";
    // 正则：两个捕获组（前缀3位，后缀4位）
    std::regex phone_regex(R"(1(\d{2})\d{4}(\d{4}))");

    // 场景2.1：提取第1个捕获组（前缀3位，submatch_idx=1）
    std::sregex_token_iterator it1(text.cbegin(), text.cend(), phone_regex, 1);
    std::sregex_token_iterator end_it;

    std::println("批量提取手机号前缀（第1个捕获组）：");
    for (; it1 != end_it; ++it1) {
        std::println("{} ", it1->str());
    }

    // 场景2.2：提取第2个捕获组（后缀4位，submatch_idx=2）
    std::sregex_token_iterator it2(text.cbegin(), text.cend(), phone_regex, 2);
    std::println("\n批量提取手机号后缀（第2个捕获组）：");
    for (; it2 != end_it; ++it2) {
        std::println("{} ", it2->str());
    }

    return 0;
}
```

**运行结果**

```css
批量提取手机号前缀（第1个捕获组）：
38
39
50

批量提取手机号后缀（第2个捕获组）：
5678
4321
8765
```

###### 提取非匹配部分（实现字符串分割）

需求：以逗号、空格为分隔符，分割字符串（类似 `split` 函数）。

```cpp
int main() {
    const char* text = "苹果,香蕉 橙子,葡萄 西瓜";
    // 正则：匹配分隔符（逗号或空格）
    std::regex sep_regex(R"([, ]+)");

    // 定义 regex_token_iterator，submatch_idx=-1（提取非匹配部分，即分割后的内容）
	std::cregex_token_iterator it(text, text + std::strlen(text), sep_regex, -1);
	std::cregex_token_iterator end_it;

    std::println("字符串分割结果：");
    for (; it != end_it; ++it) {
        std::println("{} ", it->str());
    }

    return 0;
}
```

**运行结果**

```css
字符串分割结果：
苹果
香蕉
橙子
葡萄
西瓜
```

###### 提取特定捕获组

```cpp
int main() {

    const char* text = "https://example.com http://google.com";
    std::regex re(R"((https?)://(\w+)\.(\w+))"); // 捕获协议和域名

    // 提取第1个捕获组（协议）和第3个捕获组（后缀）
    std::cregex_token_iterator iter(text, text + std::strlen(text), re, { 1, 3 });
    std::cregex_token_iterator end;

    while (iter != end) {
        std::println("Protocol:{}", (iter++)->str());
        std::println("Suffix:{}", (iter++)->str());
    }

    return 0;
}
```

**运行结果**

```css
Protocol:https
Suffix:com
Protocol:http
Suffix:com
```
