# 内存泄漏检测

## 内存泄漏是什么?

在 C/C++ 中，**内存泄漏（Memory Leak）** 是指程序在运行过程中，动态分配的堆内存（通过`malloc`/`calloc`/`realloc`（C 语言）或`new`（C++）分配）在不再需要使用时，没有通过对应的`free`（C）或`delete`/`delete[]`（C++）释放，且后续再也无法通过程序中的指针访问到这块内存，导致这块内存永远被占用，直到程序退出才会被操作系统回收。

### 内存泄漏的核心特点

+ 仅针对**堆内存**（栈内存由编译器自动分配和释放，局部变量、函数参数等存放在栈上，不会产生内存泄漏）；

+ 两个必要条件：
  + ① 未释放动态分配的内存；
  + ② 丢失了指向该内存的所有指针（无法再访问，也就无法后续释放）；

+ 短期运行的小程序可能影响不大（程序退出后内存被系统回收），但长期运行的后台服务、守护进程等，内存泄漏会持续累积，最终导致程序内存耗尽（OOM），崩溃退出。

> **OOM**（Out Of Memory）是指“内存用完了”，通常发生在程序无法分配对象时，因为没有足够的内存可用。

### 简单案例

如下代码，展示了一个典型的内存泄漏案例：

```cpp
#include <iostream>
#include <cstdlib>
using namespace std;

void testMemoryLeak() {
    // 1. 动态分配堆内存（C++方式）
    int* p1 = new int(10);
    // 2. 动态分配堆内存（C方式）
    char* p2 = (char*)malloc(100);
    
    // 错误：没有执行 delete p1; 和 free(p2);
    // 且函数执行完毕后，p1、p2（栈上的指针变量）被销毁，再也无法访问分配的堆内存，造成内存泄漏
}

int main() {
    testMemoryLeak();
    // 程序运行结束，操作系统才会回收未释放的堆内存
    return 0;
}
```

补充：C++ 中还有一种 “隐性内存泄漏”—— 比如容器`vector`、`string`虽然自动管理内存，但如果容器作为类成员，类的析构函数未正确清理容器中的动态资源（或容器存放的是指针类型，未先释放指针指向的内存再清空容器），也可能导致内存泄漏

## 如何检测内存泄漏

检测内存泄漏的方法分为**手动排查**和**工具辅助**两大类，其中工具辅助是实际开发中的主流方式（效率更高、更准确）。

### 方法一：手动排查

手动排查适合简单小程序，核心思路是 **“配对管理”**，确保每一次动态分配都有对应的释放操作，重点关注以下几点：

1. 检查`malloc`/`calloc`/`realloc`是否与`free`一一对应；
2. 检查`new`是否与`delete`对应、`new[]`是否与`delete[]`对应（**不可混用**，比如`new`分配的内存用`free`释放，不仅可能导致内存泄漏，还可能引发程序崩溃）；
3. 关注分支逻辑（`if/else`、`switch`）、循环、异常场景，避免某些分支中分配了内存但未释放（比如异常抛出后，跳过了释放内存的代码）；
4. 推荐实践：C++ 中优先使用**智能指针（`std::shared_ptr`、`std::unique_ptr`）**，它能自动管理堆内存，超出作用域时自动释放，从根源上减少手动管理导致的内存泄漏。

### 方法二：工具辅助排查

适合复杂项目，推荐优先使用！手动排查在复杂项目中容易遗漏，主流的 C/C++ 开发环境都有对应的内存泄漏检测工具，以下是最常用的几款：

#### 1. Visual Studio 内置内存检测工具（Windows 平台，便捷、集成度高）

Windows 下使用 Visual Studio 开发时，可以直接使用其内置的**CRT（C Runtime Library）内存检测机制**，无需额外安装第三方工具。

##### 核心步骤：

1. 包含必要头文件和定义宏（在代码开头添加）：

   ```cpp
   // 启用内存泄漏检测（仅在 Debug 模式下生效）
   #define _CRTDBG_MAP_ALLOC
   #include <crtdbg.h>
   ```

2. 在程序入口（`main`函数）末尾添加检测代码：

   ```cpp
   // 转储内存泄漏报告到输出窗口
   _CrtDumpMemoryLeaks();
   ```

3. 以**Debug 模式**编译并运行程序，运行结束后，Visual Studio 的 “输出” 窗口会显示详细的内存泄漏报告（包含泄漏的内存大小、分配时的代码行号等）。

示例（完整配置）：

```cpp
#define _CRTDBG_MAP_ALLOC
#include <crtdbg.h>

#ifdef __cplusplus
    #define new   new( _CLIENT_BLOCK, __FILE__, __LINE__)
    #include <iostream>
#endif

void testMemoryLeak() {
    int* p = new int(10);
    int* p1 = (int*)malloc(sizeof(int));
    // 未释放 p p1
}

int main() {
    testMemoryLeak();
    // 输出内存泄漏报告
    _CrtDumpMemoryLeaks();
    return 0;
}
```

#### 2. Valgrind（Linux/macOS 平台，免费、开源，最常用）

Valgrind 是一套强大的程序调试和分析工具集，其中**Memcheck**工具专门用于检测内存泄漏和内存错误（比如越界访问、使用已释放的内存等）。

##### 使用步骤：

1. 安装 Valgrind（Ubuntu/Debian 示例）：

   ```bash
   sudo apt update
   sudo apt install valgrind
   ```

2. 编译代码时，添加`-g`参数（保留调试信息，让 Valgrind 能显示具体的泄漏代码行号）：

   ```bash
   g++ -g test_leak.cpp -o test_leak
   ```

3. 用 Valgrind 运行编译后的程序：

   ```bash
   valgrind --leak-check=full ./test_leak
   ```

   其中`--leak-check=full`表示全面检测内存泄漏，会输出详细的泄漏报告。

   输出如下：

   ```bash
   root@maye-vm-pc:~# valgrind --leak-check=full ./main 
   ==6139== Memcheck, a memory error detector
   ==6139== Copyright (C) 2002-2022, and GNU GPL'd, by Julian Seward et al.
   ==6139== Using Valgrind-3.22.0 and LibVEX; rerun with -h for copyright info
   ==6139== Command: ./main
   ==6139== 
   ==6139== 
   ==6139== HEAP SUMMARY:
   ==6139==     in use at exit: 8 bytes in 2 blocks
   ==6139==   total heap usage: 3 allocs, 1 frees, 73,736 bytes allocated
   ==6139== 
   ==6139== 4 bytes in 1 blocks are definitely lost in loss record 1 of 2
   ==6139==    at 0x4846FA3: operator new(unsigned long) (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
   ==6139==    by 0x10917E: testMemoryLeak() (main.cpp:4)
   ==6139==    by 0x1091A6: main (main.cpp:10)
   ==6139== 
   ==6139== 4 bytes in 1 blocks are definitely lost in loss record 2 of 2
   ==6139==    at 0x4846828: malloc (in /usr/libexec/valgrind/vgpreload_memcheck-amd64-linux.so)
   ==6139==    by 0x109192: testMemoryLeak() (main.cpp:5)
   ==6139==    by 0x1091A6: main (main.cpp:10)
   ==6139== 
   ==6139== LEAK SUMMARY:
   ==6139==    definitely lost: 8 bytes in 2 blocks
   ==6139==    indirectly lost: 0 bytes in 0 blocks
   ==6139==      possibly lost: 0 bytes in 0 blocks
   ==6139==    still reachable: 0 bytes in 0 blocks
   ==6139==         suppressed: 0 bytes in 0 blocks
   ==6139== 
   ==6139== For lists of detected and suppressed errors, rerun with: -s
   ==6139== ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)
   ```

##### 报告解读核心要点：

- `definitely lost`：**明确的内存泄漏**（必须修复，就是我们前面说的 “丢失了所有指针，无法访问的未释放内存”）；
- `indirectly lost`：间接泄漏（通常由明确泄漏导致，修复了`definitely lost`后，这类泄漏也会消失）；
- `possibly lost`：可能的泄漏（内存指针还存在，但无法确定是否能访问，建议排查）；
- `still reachable`：内存未释放，但程序退出前仍能访问（比如全局指针指向的内存，程序结束后会被系统回收，一般可忽略，若追求严谨也可释放）。

#### 3. 其他常用工具（补充）

- **AddressSanitizer（ASAN）**：Google 开发的内存错误检测工具，支持 Linux/macOS/Windows，集成在 GCC、Clang 编译器中，检测速度比 Valgrind 快，使用时编译代码添加`-fsanitize=address`参数即可；
- **Purify**：商业级工具，功能强大，支持多平台，但需要付费；
- **Clang Static Analyzer**：静态代码分析工具，可在编译前排查潜在的内存泄漏风险，无需运行程序。

# 智能指针

## 为什么需要智能指针？

在 C++ 中，手动使用`new`/`delete`管理堆内存存在诸多问题：

1. 容易忘记释放内存，导致**内存泄漏**；
2. 异常场景下，释放内存的代码可能被跳过（比如`new`后抛出异常，`delete`未执行）；
3. 容易出现**双重释放**（多次`delete`同一个指针）、**野指针**（使用已释放的内存）。

而**智能指针（Smart Pointer）** 是 C++ 标准库（`<memory>`头文件）提供的模板类，它的核心思想是 **「RAII（资源获取即初始化）」**—— 将堆内存的生命周期与智能指针对象的生命周期绑定，智能指针对象在**超出作用域（或不再被引用）时，自动调用析构函数释放绑定的堆内存 **，无需手动调用`delete`，从根源上解决上述问题。

**核心前提**

1. 智能指针是**栈上的对象**（不是堆对象），管理的是**堆上的资源**（`new`/`malloc`分配的内存）；
2. C++11 及以上版本提供了成熟的智能指针体系（`unique_ptr`、`shared_ptr`、`weak_ptr`），C++98 中的`auto_ptr`已被废弃（存在缺陷，不推荐使用）；
3. 使用前必须包含头文件：`#include <memory>`。

## 三种智能指针

C++ 标准库提供的智能指针中，最常用的是`std::unique_ptr`、`std::shared_ptr`，`std::weak_ptr`是配合`shared_ptr`使用的辅助工具，所以重点掌握前两种。

下面逐一讲解，因为大多时候都是用的自定义类型，所以我们先定义一个Test类：

```cpp
// 定义一个简单类，用于演示
class Test {
public:
	Test(int num) 
		: m_num(num) {
		std::println("Test 构造：{}", m_num);
	}
	~Test() {
		std::println("Test 析构：{}", m_num);
	}
	void show() {
		std::println("当前数值：{}", m_num);
	}
private:
	int m_num;
};
```

### unique_ptr

#### 核心特性

- 「独占所有权」：一个`unique_ptr`对象独占它所管理的堆内存，**不允许拷贝和赋值**（避免多个指针管理同一块内存，导致双重释放）；
- 生命周期结束时（超出作用域、被重置），自动释放管理的内存；
- 轻量高效（几乎没有额外性能开销，和裸指针效率接近）；
- 支持转移所有权（通过`std::move()`）。

#### 常用用法

##### 构造指针对象

最熟悉的莫过于直接构造对象了，但是这种方法还是需要手动调用new，不太雅观QAQ！！！

```cpp
std::unique_ptr<Test> uptr1(new Test(1));
//std::unique_ptr<Test> uptr1 = new Test(1);	//error:禁止隐式构造
```

还有一种是C++14提供的方法，即通过`make_unique`函数来创建独享指针：

```cpp
auto uptr1 = std::make_unique<Test>(1);
```

##### 访问管理的对象

和裸指针用法一致，使用 -> 或 * :

```cpp
uptr1->show();
(*uptr1).show();
```

还可以通过`get`方法获取裸指针：

```cpp
Test* pt = uptr1.get();
```

> 注意，获取到的裸指针不要自己释放！！！否则会导致双重释放问题。

##### 重置智能指针

重置智能指针，即释放当前管理的内存：

```cpp
uptr1.reset();
std::println("uptr1 : {}", uptr1 == nullptr);	//true
```

reset方法还支持传递一个参数，如果原来有管理的内存则释放掉，然后管理新的内存。

```cpp
uptr1.reset(new Test(2));
std::println("uptr1 : {}", uptr1 == nullptr);	//false
```

##### 转移所有权

通过 `std::move()`将uptr1的所有权转移给uptr2，uptr1的所有权变为空，uptr2 获得所有权

```cpp
	std::unique_ptr<Test> uptr2 = std::move(uptr1);
	if (uptr1 == nullptr) {
		std::println("uptr1 已经失去了所有权");
	}
	uptr2->show();
```

##### 释放所有权

释放所有权的意思是：智能指针对象不再管理内存，而是将管理内存的权限转交给调用者，调用者需要负责释放内存！

```cpp
	//返回裸指针，并释放所有权，uptr2为空了
	auto ptest = uptr2.release();
	delete ptest;	//需要手动释放
```

#### 管理数组

##### 构造指针对象

首先，也是可以通过构造函数直接去构造的：

```cpp
std::unique_ptr<Test[]> uptr1(new Test[3]{ 1, 2, 3 });
```

然后，也可以通过`std::make_unique`函数创建，但是不支持初始化列表，而且类型必须支持默认初始化：

```cpp
auto uptr1 = std::make_unique<Test[]>(3);
```

##### 遍历数组

unique_ptr重载了`[]`运算符，所以可以直接使用：

```cpp
	for (int i = 0; i < 3; i++) {
		uptr1[i].show();
	}
```

#### 删除器

在某些时候，默认的释放操作不能满足咱们的需要，这个时候就需要自定义删除器。

```cpp
void del_global(Test* ptr){delete ptr;}					//全局函数
auto del_lambda = [](Test* ptr) {delete ptr; };			//lambda
std::function<void(Test*)> del_function = del_lambda;	//函数包装器
struct Del_Object										//仿函数
{
	void operator()(Test* ptr)
	{
		delete ptr;
	}
};

int main()
{
   	std::unique_ptr<Test, decltype(del_global)*>	p2(new Test, del_global);
	std::unique_ptr<Test, decltype(del_lambda)>		p3(new Test, del_lambda);
	std::unique_ptr<Test, decltype(del_function)>	p4(new Test, del_function);
	std::unique_ptr<Test, decltype(Del_Object())>	p5(new Test, Del_Object());
    
    return 0;
}
```

> 注意:自定义删除器无法通过std::make_unique来指定。可以通过`get_deleter`获取删除器。

### shared_ptr

#### 核心特性

- 「共享所有权」：多个`shared_ptr`对象可以共享同一块堆内存，通过**引用计数（Reference Count）** 实现；
- 引用计数：每一个`shared_ptr`指向该内存时，引用计数 + 1；`shared_ptr`销毁（超出作用域、重置）时，引用计数 - 1；
- 当引用计数**减至 0**时，自动释放管理的堆内存（无任何对象引用该内存时，才释放）；
- 支持拷贝和赋值（拷贝 / 赋值时，引用计数自动 + 1）；
- 有轻微性能开销（需要维护引用计数，线程安全的引用计数更新会有额外开销）。

#### 构造对象

可以使用shared_ptr提供的构造函数构造对象，可以构造对象，也可以构造数组！

```cpp
std::shared_ptr<Test> sp(new Test);
std::shared_ptr<Test[]> sp1(new Test[5]);
```

大家会发现，上面的代码写起来有点麻烦，Test类型在同一个语句中需要写两个，有点冗余，而且构造数组时也容易忘记写数组大小。有没有更轻松的方法呢？必须有！

```cpp
auto sp2 = std::make_shared<Test>();
//值得会注意的是，使用make_shared不支持创建数组
//auto sp3 = std::make_shared<Test>(5);
```

使用`make_shared`构造，然后使用auto自动类型推导，就很方便了。

#### 删除器

在某些时候，默认的释放操作不能满足咱们的需要，这个时候就需要自定义删除器。

```cpp
std::shared_ptr<Test> sp(new Test, [](auto* ptr) {delete ptr; });
```

#### 指针使用

和unique_ptr一样

#### 获取/释放

##### use_count

使用use_count获取所指对象的引用计数。如果这是一个空的shared_ptr，函数返回零。

库实现不需要保留任何特定所有者集的计数，因此调用此函数可能效率不高。要具体检查use_count是否为1，可以使用member unique代替，这样可能更快。

##### unique

检查所管理对象是否仅由当前shared_ptr管理。

##### get

同unique_ptr;

##### reset

```cpp
void reset();					//仅释放
void reset(_Ux* _Px);			//释放，并接管_Px
void reset(_Ux* _Px, _Dx _Dt)	//释放，并接管_Px,并给_Px指定_Dt删除器
```

#### 循环引用（shared_ptr 的致命缺陷）

`shared_ptr`的共享所有权可能导致**循环引用**—— 两个（或多个）`shared_ptr`互相引用，导致引用计数永远无法减至 0，最终造成内存泄漏。

```cpp
// 前向声明
class B;

class A {
public:
	shared_ptr<B> b_ptr; // A 引用 B
	A() { std::println("A 构造"); }
	~A() { std::println("A 析构"); }
};

class B {
public:
	std::shared_ptr<A> a_ptr; // B 引用 A（形成循环）
	B() { std::println("B 构造"); }
	~B() { std::println("B 析构"); }
};

int main() {
	auto a = std::make_shared<A>();
	auto b = std::make_shared<B>();
	a->b_ptr = b; // A 引用 B
	b->a_ptr = a; // B 引用 A，形成循环引用

	std::println("a 引用计数：{}", a.use_count()); // 输出 2
	std::println("b 引用计数：{}", b.use_count()); // 输出 2

	// 程序结束时，a 和 b 超出作用域，引用计数各减 1，变为 1（互相引用）
	// 引用计数未减至 0，析构函数不会调用，内存泄漏
	return 0;
}
```

运行结果（无析构输出，内存泄漏）：

```cpp
A 构造
B 构造
a 引用计数：2
b 引用计数：2
```

### week_ptr

#### 核心特性

- 「弱引用」：不拥有堆内存的所有权，仅作为`shared_ptr`的 “观察者”；
- 不会增加`shared_ptr`的引用计数（解决循环引用问题的核心）；
- 无法直接访问管理的对象（需要先通过`lock()`方法转换为`shared_ptr`，转换成功后才能访问）；
- 生命周期结束时，不会对堆内存做任何操作（因为不拥有所有权）。

#### 解决循环引用

```cpp
// 前向声明
class B;

class A {
public:
	weak_ptr<B> b_ptr; // 改为 weak_ptr（不增加引用计数）
	A() { std::println("A 构造"); }
	~A() { std::println("A 析构"); }
};

class B {
public:
	weak_ptr<A> a_ptr; // 改为 weak_ptr（不增加引用计数）
	B() { std::println("B 构造"); }
	~B() { std::println("B 析构"); }
};

int main() {
	auto a = make_shared<A>();
	auto b = make_shared<B>();
	a->b_ptr = b; // weak_ptr 可以接收 shared_ptr（隐式转换）
	b->a_ptr = a;

	std::println("a 引用计数：{}", a.use_count()); // 输出 1（weak_ptr 不增加计数）
	std::println("b 引用计数：{}", b.use_count()); // 输出 1

	// 尝试通过 weak_ptr 访问对象（需要 lock() 转换为 shared_ptr）
	if (shared_ptr<B> temp_b = a->b_ptr.lock()) { // lock() 成功：返回有效的 shared_ptr
		std::println("成功访问 B 对象");
	}
	else {
		std::println("B 对象已被释放");
	}

	return 0;
}
```

运行结果（析构函数正常调用，无内存泄漏）：

```cpp
A 构造
B 构造
a 引用计数：1
b 引用计数：1
成功访问 B 对象
B 析构
A 析构
```

#### 关键方法：lock ()

`weak_ptr`无法直接访问对象，必须通过`lock()`方法转换为`shared_ptr`：

1. 若被观察的`shared_ptr`还存在（内存未释放），`lock()`返回一个有效的`shared_ptr`，引用计数 + 1；
2. 若被观察的`shared_ptr`已释放（内存已释放），`lock()`返回一个空的`shared_ptr`；
3. 通常配合`if`判断使用，避免访问已释放的内存。

#### 适用场景

- 解决`shared_ptr`的**循环引用**问题（这是核心用途）；
- 作为观察者，需要访问`shared_ptr`管理的对象，但不需要拥有所有权（比如缓存、观察者模式）。

## 共享自己(enable_shared_from_this)

`std::enable_shared_from_this`是 C++ 标准库的**模板基类**，核心作用是**让类的对象能安全获取指向自身的`std::shared_ptr`**，解决直接用`this`指针构造`shared_ptr`导致的**双重释放、引用计数混乱**问题，它必须和`shared_ptr`配合使用，是`shared_ptr`的重要配套工具。

### 为什么需要？

直接用类的`this`指针构造`shared_ptr`会触发**严重的未定义行为**，核心原因是：**同一个裸指针（this）被多个独立的 shared_ptr 管理，导致引用计数不共享，最终双重释放内存**。

#### 错误示例：直接用 this 构造 shared_ptr

```cpp
class Test {
public:
	Test() { std::println("Test 构造"); }
	~Test() { std::println("Test 析构"); }

	// 成员函数：尝试返回指向自身的 shared_ptr
	std::shared_ptr<Test> getSelf() {
		// 错误：用 this 裸指针直接构造 shared_ptr
		return std::shared_ptr<Test>(this);
	}
};

int main() {
	// 第一个 shared_ptr 管理 this 指针，引用计数 = 1
	std::shared_ptr<Test> sptr1(new Test());
	// 调用成员函数，用 this 构造第二个 shared_ptr，引用计数独立 = 1
	std::shared_ptr<Test> sptr2 = sptr1->getSelf();

	// 查看引用计数：两个 shared_ptr 计数都是 1（未共享）
	std::println("sptr1 引用计数：{}", sptr1.use_count()); // 1
	std::println("sptr2 引用计数：{}", sptr2.use_count()); // 1

	return 0;
}
```

运行结果（未定义行为：双重析构 / 程序崩溃）：

```css
Test 构造
sptr1 引用计数：1
sptr2 引用计数：1
Test 析构
Test 析构 // 同一个对象被析构两次，直接触发程序崩溃/内存损坏
```

#### 问题核心

`shared_ptr`的引用计数是**和自身管理的堆内存绑定**，而非和裸指针绑定。上面的代码中，`sptr1`和`sptr2`是**两个独立的 shared_ptr**，都管理`this`这个裸指针，但各自的引用计数都是 1；程序结束时，两个`shared_ptr`都会析构，各自调用`delete this`，导致**双重释放**。

我们需要的是：**从对象内部获取一个和外部 shared_ptr 共享引用计数的智能指针**，这就是`enable_shared_from_this`的核心价值。

### 核心原理

`enable_shared_from_this`是`<memory>`头文件中的**模板基类**，使用方式是**让目标类公有继承该基类**（模板参数为目标类自身）。

**其底层原理很简单**：

1. 基类`enable_shared_from_this`中包含一个**私有 / 受保护的 weak_ptr 成员**；
2. 当第一个`shared_ptr`构造并管理该类对象时，会自动将这个`weak_ptr`绑定到自身（**弱引用**，不增加引用计数）；
3. 类的成员函数通过调用基类提供的`shared_from_this()`方法，让该`weak_ptr`调用`lock()`转换为`shared_ptr`；
4. 转换后的`shared_ptr`和外部管理该对象的`shared_ptr`**共享引用计数**，从根本上避免了独立计数的问题。

简单说：`enable_shared_from_this`通过一个**内部弱引用**，让对象能 “感知” 到外部的`shared_ptr`，从而生成共享计数的智能指针。

### 正确使用

#### 核心步骤

1. 类**公有继承**`std::enable_shared_from_this<类名>`（模板参数是类自身，C++11 及以上支持）；
2. 成员函数中通过 **`shared_from_this()`** 替代`this`构造`shared_ptr`，获取指向自身的智能指针；
3. 必须保证**对象已被至少一个 shared_ptr 管理**时，才能调用`shared_from_this()`（否则会抛异常 / 未定义行为）；
4. 优先使用`std::make_shared`创建对象（和`shared_ptr`更适配）。

#### 正确示例（修复上面的错误）

```cpp
// 步骤1：公有继承 enable_shared_from_this，模板参数为自身 Test
class Test : public std::enable_shared_from_this<Test> {
public:
	Test() { std::println("Test 构造"); }
	~Test() { std::println("Test 析构"); }

	// 步骤2：用 shared_from_this() 替代 this 构造 std::shared_ptr
	std::shared_ptr<Test> getSelf() {
		return shared_from_this(); // 核心：返回共享计数的 std::shared_ptr
	}

	// 进阶：const 成员函数需调用 const 版本：shared_from_this() const
	std::shared_ptr<const Test> getSelfConst() const {
		return shared_from_this();
	}
};

int main() {
	// 推荐：用 make_shared 创建，自动绑定内部 weak_ptr
	std::shared_ptr<Test> sptr1 = std::make_shared<Test>();
	// 调用成员函数，获取共享计数的 std::shared_ptr
	std::shared_ptr<Test> sptr2 = sptr1->getSelf();

	// 查看引用计数：两个 std::shared_ptr 共享计数，变为 2
	std::println("sptr1 引用计数：{}", sptr1.use_count()); // 2
	std::println("sptr2 引用计数：{}", sptr2.use_count()); // 2

	// 重置 sptr1，引用计数减 1 变为 1（sptr2 仍在管理）
	sptr1.reset();
	std::println("sptr2 引用计数（sptr1 重置后）：{}", sptr2.use_count()); // 1

	return 0;
}
```

运行结果（行为正常，仅析构一次）：

```cpp
Test 构造
sptr1 引用计数：2
sptr2 引用计数：2
sptr2 引用计数（sptr1 重置后）：1
Test 析构
```

### 典型适用场景

`enable_shared_from_this`在实际开发中主要用于**需要在类内部获取自身智能指针**的场景，常见的有：

#### 1. 回调函数 / 异步操作

将类的成员函数作为回调函数时，需要传递指向自身的`shared_ptr`，保证回调执行时对象仍存活（避免野指针）。

```cpp
// 异步任务中传递自身 shared_ptr，确保对象不被提前释放
void Test::asyncTask() {
    auto self = shared_from_this();
    // 异步回调：捕获 self，延长对象生命周期
    std::async(std::launch::async, [self]() {
        self->doSomething();
    });
}
```

#### 2. 观察者模式

被观察对象需要向观察者注册自身，通过`shared_from_this()`传递智能指针，让观察者共享所有权，保证观察期间对象存活。

#### 3. 链式调用

类的成员函数需要返回自身的`shared_ptr`，实现链式调用（如`obj->func1()->func2()->func3()`）。

#### 4. 多线程编程

多线程中，需要将对象的智能指针传递给其他线程，保证线程执行时对象未被释放，从内部获取`shared_ptr`是最安全的方式。
