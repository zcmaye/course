# 迭代器

## 简介

迭代器(iterator)是一种抽象的设计概念，在容器中指出一个位置、或成对使用以划定一个区域，用来限定操作所涉及到的数据范围。

迭代器提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。(实际上是封装了指针的类)

迭代器是STL的关键所在，STL的中心思想在于将容器(container)和算法(algorithms)分开，彼此独立设计，最后再一贴胶着剂将他们撮合在一起。从技术角度来看，容器和算法的泛型化并不困难，C++的class template和function template可分别达到目标，如果设计出两这个之间的良好的胶着剂，才是大难题。

迭代器的种类:

|      种类      |                             功能                             |                  操作                   |
| :------------: | :----------------------------------------------------------: | :-------------------------------------: |
|   输入迭代器   |                     提供对数据的只读访问                     |          只读，支持++、==、!=           |
|   输出迭代器   |                     提供对数据的读写访问                     |              读写，支持++               |
|   前向迭代器   |               提供读写操作，并能向前推进迭代器               |          读写，支持++、==、!=           |
|   双向迭代器   |               提供读写操作，并能向前和向后操作               |           读写，支持++、--，            |
| 随机访问迭代器 | 提供读写操作，并能以跳跃的方式访问容器的任意数据，是功能最强的迭代器 | 读写，支持++、--、[n]、-n、<、<=、>、>= |

## 迭代器概念引入

### 数组遍历

以往我们遍历数组，都是使用下标法，简单，清晰！有如下数组:

```cpp
//容器
int arr[5] = { 1,2,3,4,5 };
```

+ 下标法遍历

```cpp
for (int i = 0; i < 5; i++)
{
	cout << arr[i] << " ";
}
```

+ 基于范围的for循环

```cpp
for(auto& v : arr)
{
    cout << v << " ";
}
```

为啥能使用基于范围的for循环遍历数组呢？因为只要知道了数组的开始和结束就能去遍历了，看看如下遍历方法，你就明白了！

+ 指针法遍历

```cpp
int* iter = arr;
for (iter = arr; iter != arr + 5; iter++)
{
	cout << *iter << " ";
}
```

+ 迭代器方式

```cpp
using  iterator = int*;
iterator begin = arr;
iterator end = arr + 5;
for (iterator it = begin; it != end; it++)
{
	cout << *it << " ";
}
```

## 自定义迭代器

接下来，把上面的迭代器(using  iterator = int*)改成类。

### 前向迭代器

```cpp
template<typename T>
class Iterator
{
public:
	Iterator() = default;
	Iterator(T ptr) :_ptr(ptr) {}
	bool operator!=(const Iterator& right)
	{
		return _ptr != right._ptr;
	}
	Iterator operator++(int)
	{
		auto tmp = *this;
		++_ptr;
		return tmp;
	}
	Iterator& operator++()
	{
		++_ptr;
		return *this;
	}
	auto& operator*()
	{
		return *_ptr;
	}

	T operator->()
	{
		reutrn _ptr;
	}
private:
	T _ptr{ nullptr };
};
```

定义名为Iterator的迭代器模板类，并重载了!=、++、*、->运算符。如果需要支持更多操作(比如--、>、<等)可自行添加。

**测试基本类型**

```cpp
int test_baseType()
{
	int nums[5] = { 1,2,3,4,5 };

	Iterator begin(nums);
	Iterator end(nums + 5);
	for (auto it = begin ;it != end;++it)
	{
		std::cout << *it << " ";
	}

	return 0;
}
```

**测试类**

因为重载了->运算符，所以可以通过->访问迭代器所表示的对象的成员。

```cpp
struct Intger
{
	Intger(int number) :value(number) {}
	int value;
};

int test_classType()
{
	Intger nums[5] = { 1,2,3,4,5 };

	Iterator begin(nums);
	Iterator end(nums + 5);
	for (auto it = begin; it != end; ++it)
	{
		std::cout << it->value << " ";
	}

	return 0;
}
```

### 反向迭代器

同理，可以实现反向迭代器。

```CPP
template<typename T>
class Reverse_Iterator
{
public:
	Reverse_Iterator() = default;
	Reverse_Iterator(T ptr) :_ptr(ptr) {}
	bool operator!=(const Reverse_Iterator& right)
	{
		return _ptr != right._ptr;
	}
	Reverse_Iterator operator++(int)
	{
		auto tmp = *this;
		--_ptr;
		return tmp;
	}
	Reverse_Iterator& operator++()
	{
		--_ptr;
		return *this;
	}
	auto& operator*()
	{
		auto tmp = _ptr;
		return *--tmp;
	}

	T operator->()
	{
		auto tmp = _ptr;
		return --tmp;
	}
private:
	T _ptr{ nullptr };
};
```

**测试**

```cpp
int test_baseType()
{
	int nums[5] = { 1,2,3,4,5 };

	Reverse_Iterator begin(nums+5);
	Reverse_Iterator end(nums);
	for (auto it = begin ;it != end;++it)
	{
		std::cout << *it <<" ";
	}

	return 0;
}
```

### 链表迭代器

迭代器最重要的一点就是统一了容器的访问方式，对于顺序容器来说迭代器的实现很简单，定义一个迭代器类，然后包装++，--等操作即可。那么对于链表来说，想要实现功能类似的迭代器怎么办呢？

> 链表和顺序表的遍历方式完全不同，如果都提供了迭代器遍历，那么他们的访问方式将会一致，对于我们来说会非常方便！

#### 写一个链表

首先，写出节点类型：

```cpp
template<typename T>
struct Node
{
	Node(const T& v) :data(v), next{ nullptr } {}
	T data;
	Node* next;
};
```

然后，写出链表：

```cpp
template<typename T>
class SForwardList
{
public:
	SForwardList(){}
	SForwardList(const std::initializer_list<T>& list) 
	{
		for (auto& v : list)
		{
			push_back(v);
		}
	}
	~SForwardList() 
	{
		Node<T>* curNode = _head;
		Node<T>* delNode = nullptr;
		while (curNode)
		{
			delNode = curNode;
			curNode = curNode->next;
			delete[] delNode;
		}
	}
	void push_back(const T& value)
	{
		Node<T>* node = new Node<T>(value);
		if (!_head)
		{
			_head = node;
			_tail = node;
		}
		else
		{
			_tail->next = node;
			_tail = node;
		}
	}
	friend std::ostream& operator<<(std::ostream& out, const SForwardList& list)
	{
		Node<T>* curNode = list._head;
		out << "SForwardList(";
		while (curNode)
		{
			out << curNode->data;
			if (curNode->next)
				out<< ",";
			curNode = curNode->next;
		}
		out << ")";
		return out;
	}
private:
	Node<T>* _head{ nullptr };
	Node<T>* _tail{ nullptr };
};
```

测试：

```cpp
const SForwardList<int> list = {1,2,3,4,5,6,7,8};
cout << list << endl;
```

Ok! 没问题了。

#### 实现迭代器

接下来实现迭代器来遍历链表。

> 针对特定容器的迭代器可以写在类外，也可以写在类中！！

```cpp
template<typename T>
class _SForwardList_iterator
{
public:
	_SForwardList_iterator() {};
	_SForwardList_iterator(T* ptr) :_ptr(ptr) {};
	bool operator!=(const _SForwardList_iterator& it)
	{
		return _ptr != it._ptr;
	}
	_SForwardList_iterator operator++()
	{
		_ptr = _ptr->next;
		return _ptr;
	}
	typename  T::value_type & operator*()
	{
		return _ptr->data;
	}
private:
	T* _ptr{ nullptr };
};
```

`SForwardList`类中添加如下代码：

```cpp
public:
using iterator = _SForwardList_iterator<Node<T>>;
public:
iterator begin() { return iterator(_head); }
iterator end() { return iterator(nullptr); }
```

测试一下:

```cpp
for (auto& v : list)
{
	//v = 5;
	cout << v << " ";
}
for( SForwardList<int>::iterator it = list.begin();it!=list.en();it++)
{
    std::cout<<*it<<" ";
}
```

好了，能运行起来了！

注意：因为单链表只支持从前往后依次访问元素，所以只支持前向迭代。

## 迭代器适配器

### 迭代器辅助函数

#### 获取迭代器

我们已经对 C++ STL标准库提供的std::vector、std::list已经有了基本了解。其实无论什么容器，内部提供有 begin() 和 end() 成员方法，C++ STL 标准库中还提供有同名且具有相同功能的 begin() 和 end() 全局函数。

在实际的使用场景中，begin() 和 end() 函数往往会一起使用的。根据作用对象的不同，begin() 和 end() 函数可细分为以下 2 个功能。

##### 数组作为参数

将指定数组传给 begin() 函数，其会返回一个指向该数组首个元素的指针；将指定数组传给 end() 函数，其会返回一个指向数组中最后一个元素之后位置的指针。

数组作为参数时，end() 函数的语法格式和 begin() 函数也完全一样，这里仅给出了 begin() 函数的语法格式：

```cpp
template <class _Ty, size_t _Size>
constexpr _Ty* begin(_Ty (&_Array)[_Size]);
```

其中 T 为数组中存储元素的类型，N 为数组的长度；(&arr)[N] 表示以引用的方式传递数组作为参数。也就是说begin、end函数必须传递一个数组，而不能是一个指针。

**举个栗子：**

```cpp
int main()
{
	int nums[] = { 1,2,3,4,5 };
	for (int* it = std::begin(nums); it != std::end(nums); it++)
	{
		std::cout << *it << " ";
	}

	//以下写法错误，不能讲指针作为begin和end的参数
	/*
	int* pnums = nums;
	for (int* it = std::begin(pnums); it != std::end(pnums); it++)
	{
		std::cout << *it << " ";
	}
	*/

	return 0;
}
```

除此之外还有rbegin、rend支持数组作为参数。

**举个栗子：**

```cpp
int main()
{
	int nums[] = { 1,2,3,4,5 };
	for (std::reverse_iterator<int*> it = std::rbegin(nums); 
         it != std::rend(nums); it++)
	{
		std::cout << *it << " ";
	}

	return 0;
}
```



##### 容器作为参数

当将某个具体容器（比如 cont）作为参数分别传给 begin() 和 end() 函数时，其中 begin() 底层会执行 cont.begin() 语句，而 end() 底层会执行 cont.end() 语句，它们最终会将得到的迭代器作为函数的返回值反馈回来。

容器作为参数除了上面数组支持的begin/end、rbegin/rend函数之外还支持cbegin/cend、crbegin/crend函数。

当作用对象为容器时，end() 和 begin() 函数的语法格式是完全一样的，这里以 begin() 函数为例，有以下 2 种格式：

```cpp
//① 非 const 修改的容器作为参数，begin() 函数返回的为非 const 类型的迭代器
template <class _Container>
auto begin(const _Container& _Cont);
//② 传入 const 修饰的容器，begin() 函数返回的为 const 类型的迭代器
template <class _Container>
auto begin(_Container& _Cont)
```

其中，cont 表示指定的容器；同时，函数会返回一个有特定指向的迭代器，且此迭代器的类型也取决于 cont 容器。

举个例子：

```cpp
int main() 
{
    //创建并初始化 vector 容器
    std::vector<int> vec{ 1,2,3,4,5 };
    //调用 begin() 和 end() 函数遍历 myvector 容器
    for (auto it = begin(vec); it != end(vec); ++it)
        cout << *it << ' ';
    return 0;
}
```

#### std::size

std::size用于获取容器/数组大小

```cpp
template <class _Container>
constexpr auto size(const _Container& _Cont)
     
template <class _Ty, size_t _Size>
constexpr size_t size(const _Ty (&)[_Size])
```

#### std::empty

std::size用于判断容器/数组是否为空

```cpp
template <class _Container>
constexpr auto empty(const _Container& _Cont)
    
template <class _Ty, size_t _Size>
constexpr bool empty(const _Ty (&)[_Size])    

template <class _Elem>
constexpr bool empty(initializer_list<_Elem> _Ilist)    
```

#### std::distance

```cpp
template <class _InIt>
_Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last)
```

first 和 last 都是迭代器，该函数的功能是计算 first 和 last 之间的距离。注意：对随机访问迭代器才有意义(数组、顺序表)

#### std::advance

```cpp
template <class _InIt, class _Diff>
void advance(_InIt& _Where, _Diff _Off)
```

\_Where表示某个迭代器，\_Off为整数。该函数的功能是将\_Where迭代器前进或后退 \_Off 个位置。

#### std::next

std::next用于获取指定迭代器的写一个迭代器，指定的迭代器至少为前向迭代器

```cpp
template <class _InIt>
next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1)
```

#### std::prev

std::prev用于获取指定迭代器的上一个迭代器，指定的迭代器至少为双向迭代器

```cpp
template <class _BidIt>
_BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1)
```

#### std::data

std::data用于获取容器/数组的data(即底层指针)

```cpp
template <class _Container>
constexpr auto data(_Container& _Cont); 

template <class _Container>
constexpr auto data(const _Container& _Cont);

template <class _Ty, size_t _Size>
constexpr _Ty* data(_Ty (&_Array)[_Size]);

template <class _Elem>
constexpr const _Elem* data(initializer_list<_Elem> _Ilist);
```

### std::reverse_iterator

### std::insert_iterator

### istream_iterator/ostream_iterator

### streambuf_iterator

### move_iterator

[](http://c.biancheng.net/view/vip_7732.html)

[](https://blog.csdn.net/qq_37529913/article/details/119859888)