# 错误处理

错误处理在所有编程语言中，都是一件棘手的问题，也是一个备受争议的话题。这个问题在 C++ 这里尤其严重：因为历史的原因，C++ 并没有统一的错误处理方式。

目前，**关于错误处理的方式，C++ 社区基本分裂为异常和非异常（返回值）两个阵营**。

## 异常

### 简介

异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。

异常处理提供了一种可以使程序从执行的某点将控制流和信息转移到与执行先前经过的某点相关联的处理代码的方法（换言之，异常处理将控制权沿调用栈向上转移）。

C++ 异常处理涉及到三个关键字：**try、catch、throw、noexcept **。

- **throw:** 当问题出现时，程序会抛出一个异常。这是通过使用 **throw** 关键字来完成的。
- **catch:** 在您想要处理问题的地方，通过异常处理程序捕获异常。**catch** 关键字用于捕获异常。
- **try:** try 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。
- **noexcept ：**用于描述函数不会抛出异常，一旦有异常抛出，会立刻终止程序，它可以阻止异常的传播与扩散。noexcept可以带一个“常量表达式作为参数，常量表达式为true，表示不会抛出异常，否则代表可以抛出异常

如果有一个块抛出一个异常，捕获异常的方法会使用 **try** 和 **catch** 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try/catch 语句的语法如下所示：

```cpp
try
{
   // 保护代码
}catch( ExceptionName e1 )
{
   // catch 块
}catch( ExceptionName e2 )
{
   // catch 块
}catch( ExceptionName eN )
{
   // catch 块
}
```

如果 **try** 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 **catch** 语句，用于捕获不同类型的异常。

### 抛出异常

可以使用 **throw** 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。

以下是尝试除以零时抛出异常的实例:

```cpp
double division(int a, int b)
{
   if( b == 0 )
   {
      throw "Division by zero condition!";
   }
   return (a/b);
}
```

### 捕获异常

**catch** 块跟在 **try** 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。

```cpp
try
{
   // 保护代码
}catch( ExceptionName e )
{
  // 处理 ExceptionName 异常的代码
}
```

上面的代码会捕获一个类型为 **ExceptionName** 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 ...，如下所示：

```cpp
try
{
   // 保护代码
}catch(...)
{
  // 能处理任何异常的代码
}
```

下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。

```cpp
#include <iostream>
using namespace std;
 
double division(int a, int b)
{
   if( b == 0 )
   {
      throw "Division by zero condition!";
   }
   return (a/b);
}
 
int main ()
{
   int x = 50;
   int y = 0;
   double z = 0;
 
   try {
     z = division(x, y);
     cout << z << endl;
   }catch (const char* msg) {
     cerr << msg << endl;
   }
 
   return 0;
}
```

由于我们抛出了一个类型为 **const char\*** 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果：

```text
Division by zero condition!
```

### C++ 标准的异常

C++ 提供了一系列标准的异常，定义在 **<exception>** 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：

![C++ 异常的层次结构](assets/exceptions_in_cpp.png)

下表是对上面层次结构中出现的每个异常的说明：

| 异常                   | 描述                                                         |
| :--------------------- | :----------------------------------------------------------- |
| **std::exception**     | 该异常是所有标准 C++ 异常的父类。                            |
| std::bad_alloc         | 该异常可以通过 **new** 抛出。                                |
| std::bad_cast          | 该异常可以通过 **dynamic_cast** 抛出。                       |
| std::bad_exception     | 这在处理 C++ 程序中无法预期的异常时非常有用。                |
| std::bad_typeid        | 该异常可以通过 **typeid** 抛出。                             |
| **std::logic_error**   | 理论上可以通过读取代码来检测到的异常。                       |
| std::domain_error      | 当使用了一个无效的数学域时，会抛出该异常。                   |
| std::invalid_argument  | 当使用了无效的参数时，会抛出该异常。                         |
| std::length_error      | 当创建了太长的 std::string 时，会抛出该异常。                |
| std::out_of_range      | 该异常可以通过方法抛出，例如 std::vector 和 std::bitset<>::operator[]()。 |
| **std::runtime_error** | 理论上不可以通过读取代码来检测到的异常。                     |
| std::overflow_error    | 当发生数学上溢时，会抛出该异常。                             |
| std::range_error       | 当尝试存储超出范围的值时，会抛出该异常。                     |
| std::underflow_error   | 当发生数学下溢时，会抛出该异常。                             |

### 定义新的异常

您可以通过继承和重载 **exception** 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：

```cpp
#include <iostream>
#include <exception>
using namespace std;
 
struct MyException : public exception
{
  const char * what () const
  {
    return "C++ Exception";
  }
};
 
int main()
{
  try
  {
    throw MyException();
  }
  catch(MyException& e)
  {
    std::cout << "MyException caught" << std::endl;
    std::cout << e.what() << std::endl;
  }
  catch(std::exception& e)
  {
    //其他的错误
  }
}
```

这将产生以下结果：

```cpp
MyException caught
C++ Exception
```

### 抑制new抛异常

当使用new申请内存时，如果内存申请失败，会抛出std::bad_alloc异常，需要如下处理：

```cpp
try
{
	while (true)
	{
		new char[1024];
	}
}
catch (const std::bad_alloc& e)
{
	cout << "has exception "<<e.what() << endl;
}
```

如果想根据返回的指针来判断，就需要抑制new抛出异常。

```cpp
double* p = nullptr;
do
{
	 p = new(std::nothrow) double[1024];
} while (p);
```

### 异常安全

构造函数完成对象的构造和初始化，最好不要在构造函数中抛出异常，否则可能导致对象不完整或没有完全初始化析构函数主要完成资源的清理，最好不要在析构函数内抛出异常，否则可能导致资源泄漏(内存泄漏、句柄未关闭等)

C++中异常经常会导致资源泄漏的问题，比如在 new 和 delete 中抛出了异常，导致内存泄漏，在lock 和 unlock 之间抛出了异常导致死锁，C++经常使用RAII来解决以上问题。

一下是一个可能导致异常安全的代码！

```cpp
void dance()
{
	auto p = new int(666);

	*p = std::stoi("xx123");

	delete p;
}
```

当std::stoi函数中传入的不是一个整数字符串时，则会抛出`std::bad_cast`异常，导致p指向的内存没有释放！



### 异常规范

- 异常规格说明的目的是为了让函数使用者知道该函数可能抛出的异常有哪些。 可以在函数的后面接throw(类型)，列出这个函数可能抛掷的所有异常类型。
-  函数的后面接 noexcept，表示函数不抛异常。
- 若无异常接口声明，则此函数可以抛掷任何类型的异常



## 非异常

为了保证与 C 语言的兼容性，C++ 从 C 语言那里继承了各种基于错误返回码的机制，常见的有两种：

1. 返回各种特殊值用于表示各种不同的错误原因（通常返回 0 表示成功）。
2. 返回 0 值表示成功；返回非 0 表示错误（大部分情况返回 -1），并通过设置全局状态（errno）来表示具体错误原因。

```cpp
int getchar(); // 遇到文件结尾返回 -1
char* malloc(int); // 如果分配出错，返回 0
```

基于错误返回码的错误处理机制，存在一些天然的缺陷：

1. 繁琐且重复的错误检查使代码变得混乱。
2. 构造函数没有返回值，错误返回码无法处理构造函数出错的情形。类似的，重载的运算符执行出错也没法返回错误码。
3. 还有，最令人头疼的是，开发者可能会忘记检查错误或者没有正确处理返回码。

关于基于返回值的错误处理方式，C++ 也进行了一些增强：

### std::error_code

- C++11 引入了 `std::error_code` 增强了错误码的概念。

  ```cpp
  class maye_category : public std::error_category
  {
  	const char* error_msg[100] = {"one","two","three","four"};
  	const char* mapStr(int errval) const
  	{ 
  		if (errval == 0)
  		{
  			return "No Error";
  		}
  		if (errval < 255 || errval > 255 + 100)
  		{
  			return "unknown Error";
  		}
  		return error_msg[errval - 255]; 
  	}
  public:
  	virtual const char* name() const noexcept override
  	{
  		return "maye_category";
  	}
  	virtual std::string message(int _Errval) const override
  	{
  		return std::string(mapStr(_Errval));
  	}
  };
  
  void sendMsg(const std::string& msg, std::error_code& code)
  {
  	//code =  std::make_error_code(std::errc::invalid_argument);
  
  	static maye_category cate;
  	code.assign(257, cate);
  
  	//code.assign(255,)
  }
  
  int main()
  {
  	std::error_code error;
  	sendMsg("hello", error);
  	if (error)
  	{
  		std::cout << "has erro " << error.value() << " " << error.message() << " " << error.category().name() << std::endl;
  	}
  
  	std::cout << sqrt(-1) << std::endl;
  	struct ss
  	{
  		ss(int a, int b) {}
  		int a; 
  		int b;
  	};
  	std::optional<ss> v({ 2,3 });
  	//std::cout << v.has_value() <<"  "<<v.value() << std::endl;
  
  	return 0;
  }
  ```

### std::optional(C++17)

#### 一、前言

  有时我们会用一个值来表示一种“没有什么意义”的状态，这就是C++17的std::optional的用处，允许函数返回“空值（nothing）“，增强了函数接口的表达能力。

  在编写程序时，我们常常遇到一种情况，那就是我们不总是有一个固定值来表示一个事物。例如，找出文本中的第一个偶数（如果存在的话）。在以前的代码中，这些情况一般使用魔术值（magic value）或者空指针（null pointers）来表示。一个魔术值可以是一个空的字符串、0、-1或者一个最大的非负值（例如std::string::npos）。

  这两个方法都有他们的缺点。魔术值人为地限制了可获得的值得范围，它也仅仅按照惯例与那些合法、正常的值分开来。对于一些类型，没有明显的魔术值，或者无法用常规手段创建魔术值。用空指针表示没有意义的值意味着其他合法的值必须被分配一个地址空间，这是一个代价高昂的操作并且难以实现。

  另一种方法是提供两次查询：首先询问是否有一个有意义的值，如果答案是真的，就查找这个值。实现这个会导致查找代码的不必要的重复，并且他的使用也不够安全。如果要查找的值不存在，第二次查询的实现就必须要做点什么，例如返回一个容易被误解的值，这个值会引起未定义的行为，或者直接抛出一个异常，后者通常是唯一明智的行为。

#### 二、介绍

C++17引入了std::optional，类似于std::variant，std:optional是一个和类型（译者注：和类型即sum type，如果你熟悉C++中的union，那么就不难理解这里的sum。如果一个union包含两个类型，一个bool类型和一个uint8_t类型，那么这个union一共会有2+2^8 = 258种值，所以我们称之为和类型，因为它们的类型数量是用各个类型的类型数量累加求得的。如果换成struct，那么这里的类型数量就是2*2^8=512种），它是类型T 的所有值和一个单独的“什么都没有”的状态的和。
	后者有专门的名字：它的类型是std::nullopt_t，并且它有一个值std::nullopt。那听上去很熟悉，它和nullptr 的概念相同，不同的是后者是C++内置的关键词。

#### 三、使用

std::optional具有我们所期望的所有特性：我们可以用任何可以被转化为T的类型来构造和赋值，我们也可用std::nullopt和默认构造函数来构造和赋值。我们还能从其他类型的std::optional初始化一个另外类型的std::optional，只要这两个类型可以相互转化。结果会包含被转换的值或者会为空，跟我们的预期相符。

我们可以像上面描述的那样查询std::optional，has_value()告诉我们是否有一个值，value()则返回这个值。如果没有值并且我们还调用了value()，会抛出一个类型为std::bad_optional_access的异常。或者我们可以使用value_or(U&& default)来得到值，如果std::optional为空，则得到default。

```cpp
#include<iostream>
#include<optional>
//从字符串中找到第一个能被n整除的数
std::optional<int> firstNumberDivisible(const std::string& str, int n)
{
	//0不能做除数
	if (n == 0)
	{
		return std::optional<int>();
	}
	for (size_t i = 0; i < str.size(); i++)
	{
		if (std::isdigit(str[i]))
		{
			if ((str[i] - '0') % n == 0)
			{
				return std::make_optional<int>(str[i] - '0');
			}
			//std::cout << str[i] - '0' << " ";
		}
	}

	return std::optional<int>();
}

int main()
{
	std::string text = "876543210";
	std::optional<int> opt = firstNumberDivisible(text, 10);
    //如果找到返回找到的值，没有找到返回999
	int v = opt.value_or(999);
   	std::cout << "first number is " << v << std::endl;
    
	if (opt.has_value())
	{
		std::cout << "first number is " << opt.value() << std::endl;
	}
	else
	{
		std::cout << "not found" << std::endl;
	}

	return 0;
}
```

除了这些显式的方法，std::optional还重载了bool类型转换，它可以显式转化为bool来表示std::optional是否有一个值。指针的解引用操作符*和->都实现了，但是没有std::bad_optional_access异常，用这种方式访问一个空的std::optional是一个未定义的行为。最后，reset()清除std::optional包含的对象，让它为空。
  上面的代码因此可以写成这样：

```cpp
if (opt)
{
	std::cout << "first number is " << *opt << std::endl;
}
```

为了方便构造std::optional，提供了std::make_optional函数模板；emplace(Args..)可以对std::optional对象重新构造值。

```cpp
auto optNums = std::make_optional<std::vector<int>>({ 1,3,5,7,9,3,4,56 });
```

### std::expected(C++23)

`std::expected` 是 C++23 引入的一个新特性，旨在提供一种类型安全的方式来表示可能成功或失败的计算结果。它是 `std::optional` 的一个补充，专门用于处理那些可能失败的操作，例如文件读取、网络请求等。`std::expected` 可以携带一个值（表示成功）或一个异常（表示失败），从而避免了使用异常处理机制的开销，并提供了更清晰的错误处理路径。

#### 主要特点

1. **类型安全**：`std::expected` 明确区分成功和失败的情况，避免了使用裸露的错误码或异常。
2. **性能**：相比于异常处理，`std::expected` 在失败时不会抛出异常，从而减少了运行时开销。
3. **灵活性**：可以自定义失败时的处理逻辑，例如记录日志、重试操作等。

#### 期望值与意外值

```cpp
//构造意外值，并构造给期望
std::expected<double,int> ex = std::unexpected(3);
//std::expected<double, int> ex = 99.9;
//没有期望值，有意外值
if (!ex) {
	std::println("ex contains an error value {}", ex.error());
	//有意外值，判断意外值是什么
	if (ex == std::unexpected(3)) {
		std::println("the error value is 3");
	}
	else if (ex == std::unexpected(4)) {
		std::println("the error value is 4");
	}
}
//有期望值
else {
	std::println("value is {}", ex.value());
}
```

#### 用法

##### 常规实现

对于一个函数调用，如果结果不正确，需要返回错误值，常规写法如下：

```cpp
int getItemType(int itemId) {
    if (itemId < 0) {
         return INT_MAX;
    }
	return itemId + 1;
}

int main(){

	int type = getItemType(2);
	if (type == INT_MAX) {
		std::println("item id too big!");
	}
    else{
        std::println("item type is {}",type);
    }
	return 0;
}
```

功能是能实现，但是正常值和错误值混合在一起，这样让我们的判断变的比较麻烦！

##### std::expected实现

使用std::expected能先判断有没有错误，然后在判断错误类型，这样就比较方便和直观了！

```cpp
std::expected<int,int> getItemType(int itemId) {
    if (itemId < 0) {
		return std::unexpected(INT_MAX);
    }
	return itemId + 1;
}

int main(){

	auto type = getItemType(2);
	if (!type) {
		std::println("item id too big!");
	}
	else {
		std::println("item type is {}", type.value());
	}
	return 0;
}
```

当可能得错误类型比较多时，意外值的类型可以使用枚举！

```cpp
enum IdError {
	IdTooSmall,
	IdTooBig,
};

std::expected<int,IdError> getItemType(int itemId) {
    if (itemId < 0) {
		return std::unexpected(IdTooSmall);
    }
	else if (itemId > 63) {
		return std::unexpected(IdTooBig);
	}
	return itemId + 1;
}

int main(){

	auto type = getItemType(-1);
	//没有期望值
	if (!type) {
		if (type.error() == IdTooSmall)
			std::println("item id too smaill!");
		else if (type.error() == IdTooBig)
			std::println("item id too big!");
	}
	//有期望值
	else {
		std::println("item type is {} {}", type.value(), *type);
	}
	return 0;
}
```

#### 高级用法

##### 转换

###### transform_error

transform_error函数用于对错误进行转换。

+ 如果`expected`是成功值：则不做任何操作直接返回原expected。
+ 如果 `expected` 是错误值：它会调用你提供的函数，将错误值转换成另一种错误类型，并返回新的 `std::expected`。

```cpp
int main() {
	auto type = getItemType(-1)
		.transform_error([](const IdError& idErr) ->const char*
			{
				switch (idErr)
				{
				case IdError::IdTooBig: return "Id 太大";
				case IdError::IdTooSmall: return "Id 太小";
				default:return "未知错误";
				}
			});
	if (!type) {
		std::println("错误:{}", type.error());
	}
}
```

###### transfrom

transfrom函数用于对成功值进行转换。

+ 如果`expected`是成功值：它会调用你提供的函数，将成功值转换成另一种成功值，并返回新的 `std::expected`。
+ 如果 `expected` 是错误值：则不做任何操作直接返回原expected。

```cpp
int main() {
	auto type = getItemType(2)
		.transform_error([](const IdError& idErr) ->const char*
			{
				switch (idErr)
				{
				case IdError::IdTooBig: return "Id 太大";
				case IdError::IdTooSmall: return "Id 太小";
				default:return "未知错误";
				}
			})
		.transform([](int v)->std::string
			{
				return "type_" + std::to_string(v);
			});

		if (!type) {
			std::println("错误:{}", type.error());
		}
		else {
			std::println("成功:{}", *type);
		}
}
```

##### 组合

`std::expected` 支持多种转换和组合操作，例如：

- `std::expected<T, E>::and_then`：在成功时执行另一个 `std::expected` 操作。
- `std::expected<T, E>::or_else`：在失败时执行另一个 `std::expected` 操作。

##### 示例

```cpp
int main(){

	auto type = getItemType(2);
	//没有期望值
	if (!type) {
		if (type.error() == IdTooSmall)
			std::println("item id too smaill!");
		else if (type.error() == IdTooBig)
			std::println("item id too big!");
	}
	//有期望值
	else {
		std::println("item type is {} {}", type.value(), *type);

		auto v = type
			//把type运用and_then对值进行转换
			. and_then([](int e)->std::expected<std::string, IdError>
				{
					std::println("and_then is {}", e);
					//把值转成字符串并返回
					return /*"h"  +*/ std::to_string(100 + e);
				})
			//把上一步and_then返回的结果，转成字符串
			.and_then([](const std::string& str)->std::expected<int, IdError>
				{
					try {
						return std::stoi(str);
					}
					catch (const std::exception& e) {
						return std::unexpected(IdError::IdTooSmall);
					}
				})
			//上面任何一步and_then失败执行
			.or_else([](int v)->std::expected<int, IdError> {
					return -1;
				});

		if (v) {
			std::println("value is {}", *v);
		}
	}
	return 0;
}
```

#### 总结

`std::expected` 是一个强大的工具，用于处理可能失败的函数调用。它提供了类型安全的方式来表示成功和失败，并且支持多种转换和组合操作。通过使用 `std::expected`，可以编写更清晰、更健壮的代码，避免使用裸露的错误码或异常处理机制。

## 辅助类

### source_location(C++20)

std::source_location用于在代码中捕获源代码的位置信息（文件名、行号、函数名等），非常适合用于日志记录、调试和错误报告。

#### 日志记录

```cpp
#define Log(fmt,...) log(std::source_location::current(),fmt,__VA_ARGS__)

template<typename ...Args>
void hdy_log(const std::source_location& location,const std::string& fmt, Args&&...args)
{
	std::string buf;
	std::format_to(std::back_inserter(buf), "{}:{}:({}) -> ", location.file_name(), location.function_name(), location.line());
	std::vformat_to(std::back_inserter(buf), fmt, std::make_format_args(args)...);
	std::print("{}", buf);
}
```

#### 断言宏增强

```cpp
#define HDY_ASSERT(condition, message) \
    if (!(condition)) { \
        throw std::runtime_error( \
            std::string("Assertion failed: ") + (message) + \
            "\nAt: " + std::source_location::current().file_name() + \
            ":" + std::to_string(std::source_location::current().line())); \
    }
```

#### 给异常增加位置信息

```cpp
class HdyError : public std::runtime_error{
public:
	HdyError(const std::string& str, const std::source_location& location = std::source_location::current())
		:location(location)
		,std::runtime_error(str)
	{ 
	}

	std::source_location location;
};

void process() {
    throw HdyError("Something went wrong");
}

int main() {
    try {
        process();
    } catch (const Error& e) {
        std::cerr << "Error at " << e.location().file_name() 
                  << ":" << e.location.line() << " - " 
                  << e.message() << '\n';
    }
    return 0;
}
```



### stacktrace(C++23)

> 头文件\<stacktrace>

`std::basic_stacktrace` 是 C++23 引入的新特性，用于在运行时捕获和操作调用栈信息（stack trace）。它比 `std::source_location` 提供更全面的调用上下文信息，非常适合调试和错误诊断。

#### 基本用法

```cpp
void hdy() {
    auto trace = std::stacktrace::current();	//获取当前调用栈
    std::cout << "Current stack trace:\n" << trace << '\n';
    //std::println("Current stack trace:\n{}", std::to_string(trace));
}

void bar() {
    hdy();
}

int main()
{
	bar();
	return 0;
}
```

能输出所有调用栈信息：

```css
0> F:\MyCode\test_code\test_cpp_any\formatter.cpp(72): test_cpp_any!hdy+0x45
1> F:\MyCode\test_code\test_cpp_any\formatter.cpp(77): test_cpp_any!bar+0x21
2> F:\MyCode\test_code\test_cpp_any\formatter.cpp(82): test_cpp_any!main+0x21
...
```

#### 异常增强

```cpp
class traced_exception : public std::runtime_error {
    std::stacktrace stack_;
public:
    traced_exception(const std::string& what_arg)
        : std::runtime_error(what_arg)
        , stack_(std::stacktrace::current()) 
    {}
    
    const std::stacktrace& stack() const noexcept { return stack_; }
};
```

