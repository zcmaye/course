# 类型转换

C++为了规范C中的类型转换，加强类型转换的可视性，引入了四种强制类型转换操作符：

+ **static_cast：**
+ **reinterpret_cast：**
+ **const_cast：**
+ **dynamic_cast：** 

## static_cast

> static_cast<type-id>(expression)

该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性。 编译器隐式执行任何类型转换都可由static_cast显示完成

+ 基本类型转换

  ```cpp
  double score = 59.5;
  int nScore = static_cast<int>(score);
  ```

+ void指针和其他类型指针之间的转换(其他类型指针之间不能转换)

  ```cpp
  void* p = new int(20);
  int* pi = static_cast<int*>(p);
  void* pc = static_cast<void*>(pi);		//这里可以隐式转换，可以省略static_cast
  delete p;
  ```

+ 用于基类派生类之间指针、引用的转换

  ```cpp
  class Base
  {
  public:
  	virtual void show()
  	{
  		std::cout << "Base " << std::endl;
  	}
  };
  
  class Derive :public Base
  {
  	char* name = nullptr;
  public:
  	Derive()
  	{
  		name = new char[5]{ "玩蛇" };
  	}
  	~Derive()
  	{
  		delete name;
  	}
  	void print()
  	{
  		std::cout << "Derive " << name << std::endl;
  	}
  };
  ```

  + **上行转换：**把派生类指针、引用转为基类的指针、引用（可以自动隐式转换）

  ```cpp
  //指针
  Derive* derive = new Derive;
  Base* base = static_cast<Derive*>(derive);
  //引用
  Derive& refDerive = *derive;
  Base& refBase = static_cast<Base&>(refDerive);
  
  delete derive;
  ```

  + **下行转换：**把基类指针、引用转为派生类的指针、引用（必须强制静态转换）

  ```cpp
  Base* base = new Base;
  Derive* derive = static_cast<Derive*>(base);
  derive->print();
  
  delete base;
  ```

  **注意：**下行转换使用`static_cast`不安全，请使用`dynamic_cast`（不安全：因为不知道基类的指针，到底是不是指向的要转换的派生类对象，如果不是，访问数据成员会有错误）

## reinterpret_cast

为操作数的位模式提供较低层的重新解释.

**主要用于以下六种情况：**

+ 任意类型指针之间的转换

  ```cpp
  int* p = nullptr;
  char* pc = reinterpret_cast<char*>(p);
  ```

+ 指针转整型，整型转指针

  ```cpp
  int* p = nullptr;
  uint64_t a = reinterpret_cast<uint64_t>(p);	//x64 指针是8个字节，所以要用uint64_t保存，否则可能会丢失数据
  double* pd = reinterpret_cast<double*>(a);
  ```

+ 函数指针也可以转换哦~

  ```cpp
  uint64_t funMax = reinterpret_cast<uint64_t>(_max);
  cout<<reinterpret_cast<int(*)(int, int)>(funMax)(2, 3);
  
  int _max(int a, int b)
  {
  	return a > b ? a : b;
  }
  ```

+ 一个官方案例

  ```cpp
  int arr[10];
  for (int i = 0; i < 10; i++)
  {
  	cout << arr+i <<"  " <<hex<< ::hash(arr+i) << endl;;
  }
  
  uint32_t _hash(void* p)
  {
  	uint64_t val = reinterpret_cast<uint64_t>(p);
  	return val ^ (val >> 32);
  }
  ```

## const_cast

const_cast用来移除类型的const属性。const_cast 中的类型必须是指针、引用或指向对象类型成员的指针

+ const指针、引用不能直接赋值给非const的对象，需要去掉const之后再赋值

  ```cpp
  const char* name = "hello";
  char* pname = const_cast<char*>(name);
  
  const int& refA = 8;
  int& refB = const_cast<int&>(refA);
  ```

+ 可以在类的const函数里面修改成员变量

  ```cpp
  class Integer
  {
  private:
  	int number;
  public:
  	Integer(int number = 0)
  		:number(number)
  	{
  	}
  	operator int()const
  	{
  		const_cast<int&>(number)++;		//必须去掉const才能修改
          const_cast<Integer*>(this)->number++;
  		return number;
  	}
  };
  
  Integer num = 10;
  int n = num;		//11
  ```

  

## dynamic_cast

dynamic_cast用于有继承关系的多态类（基类必须有虚函数）的指针或引用之间的转换。

+ 通过dynamic_cast，将派生类指针转换为基类指针（上行转换），这个操作与static_cast的效果是一样的。

+ 通过dynamic_cast，将基类指针转换为派生类指针（下行转换），dynamic_cast具有类型检查的功能，比static_cast更安全（如果转换的是指针，失败时会返回空指针；如果转换的是引用，会抛出std::bad_cast异常）



+ 指针转换，转换失败返回nullptr

  ```cpp
  	Animal* dog = new Dog;
  	dog->cry();
  	//转成实际的类型
  	Dog* d = dynamic_cast<Dog*>(dog);
  	if (!d)
  		std::cout << "dog is not Dog" << std::endl;
  	d->cry();
  	//尝试转成其他子类,失败返回nullptr
  	Cat* cat = dynamic_cast<Cat*>(dog);
  	if (!cat)
  		std::cout << "dog is not Cat";
  	else
  		cat->cry();	
  ```

+ 转换引用，转换失败抛异常std::bad_cast

  ```cpp
  Animal& refA = *dog;
  //转成实际的类型
  Dog& refD = dynamic_cast<Dog&>(refA);
  refD.cry();
  //尝试转成其他子类,失败抛异常
  Cat& refC = dynamic_cast<Cat&>(refA);
  refC.cry();
  ```

  

# 正则表达式

在很多技术领域（如：自然语言处理，数据存储等），正则表达式可以很方便的提取我们想要的信息，所以正则表达式是一个很重要的知识点！

## 概念

正则表达式（Regular Expression）是用于描述一组字符串特征的模式，用来匹配特定的字符串。通过特殊字符+普通字符来进行模式描述，从而达到文本匹配目的工具。

正则表达式目前被集成到了各种文本编辑器/文本处理工具当中。

## 应用场景

（1）验证：表单提交时，进行用户名密码的验证。

（2）查找：从大量信息中快速提取指定内容，在一批url中，查找指定url。

（3）替换：将指定格式的文本进行正则匹配查找，找到之后进行特定替换。

## 基本要素

（1）字符类

（2）数量限定符

（3）位置限定符

（4）特殊符号

注意：正则表达式基本是与语言无关的，我们可以结合语言/工具与正则表达式进行文本处理

### 1，字符类

| 字符 |                        含义                        |                             举例                             |
| :--: | :------------------------------------------------: | :----------------------------------------------------------: |
|  .   |                  匹配任意一个字符                  |                   adc.可以匹配abcd或abc6等                   |
|  []  |              匹配括号中的任意一个字符              |                    [abc]d可以匹配ad,bd,cd                    |
|  -   |                 在[]内表示字符范围                 |         [0-9a-zA-Z]可以匹配任意大写、小写和数字字符          |
|  ^   | 位于括号内的开头，匹配除括号内的字符之外的任意字符 | [^xy]z匹配xy之外的任意字符，可以匹配az、bz,但是不可以匹配xz、yz |

### 2，数量限定符

| 字符  |                   含义                   |                          举例                          |
| :---: | :--------------------------------------: | :----------------------------------------------------: |
|  ？   |    紧跟在它前面的单元应匹配零次或一次    |    [0-9]?.[0-9]匹配0.0、5.2、.3,匹配.需要使用\转义     |
|   +   |    紧跟在它前面的单元应匹配一次或多次    | [a-zA-Z0-9*]+@[a-zA-Z0-9]+.[a-zA-Z0-9*]+ 匹配email地址 |
|   *   |  紧跟在它前面的单元应匹配匹配零次或多次  |               [0-9] [0-9]*至少匹配一位数               |
|  {N}  |     紧跟在它前面的单元应精准匹配N次      |           [1-9] [0-9]{2}匹配从100到999的整数           |
| {N,}  |    紧跟在它前面的单元应匹配至少一N次     |        [1-9] [0-9]{2,}匹配大于等于三位数的整数         |
| {0,M} |     紧跟在它前面的单元应匹配最多M次      |          [0-9]{,2}匹配空或者匹配小于99的整数           |
| {N,M} | 紧跟在它前面的单元应匹配至少N次，最多M次 |       [0-9]{1,3}. [0-9]. [0-9]. [0-9]匹配IP地址        |



### 3，位置限定符

| 字符 | 含义                       | 举例                                   |
| ---- | -------------------------- | -------------------------------------- |
| ^    | 匹配行首的位置             | ^maye匹配一行开头的maye                |
| $    | 匹配行末的位置             | ;$匹配位于一行结尾的;号<br>^\$匹配空行 |
| \b   | 匹配单词开头或结尾的位置   | at\b 匹配at不能匹配att                 |
| \B   | 匹配非单词开头或结尾的位置 |                                        |



### 4，特殊符号

| 字符 | 含义                                                         | 举例                |
| ---- | ------------------------------------------------------------ | ------------------- |
| \    | 转义字符                                                     |                     |
| ()   | 将正则表达式的一部分括起来组成一个单元，可以对整个单元使用数量限定符 |                     |
| \|   | 连接两个子表达式，表示或的关系                               | n(o\|ot)匹配no或not |

### 5，其他普通字符及其替换

| 符号 | 替换正则    | 匹配                 |
| ---- | ----------- | -------------------- |
| \d   | [0-9]       | 数字字符             |
| \D   | [^0-9]      | 非数字字符           |
| \w   | [a-zA-Z0-9] | 数字、字母、下划线   |
| \W   | [^\w]       | 非数字、字母、下划线 |
| \s   | [\r\t\n\f]  | 表格、换行等空白区域 |
| \S   | [^\s]       | 非空白区域           |

## 简单练习

[Regex正则表达式在线测试、生成、解析工具 - GoRegex.cn](https://goregex.cn/)

[正则表达式在线测试 | 菜鸟工具 (runoob.com)](https://c.runoob.com/front-end/854/)

[正则表达式的语法汇总](https://blog.csdn.net/qq28129019/article/details/115913596)

## regex算法

### regex_match

全文匹配，要求整个字符串符合正则表达式的匹配规则。用来判断一个字符串和一个正则表达式是否模式匹配，如果匹配成功则返回true，否则返回false。

#### 1，是否匹配

##### 匹配测试

```cpp
#define CHECK(exp)\
		if (exp) {\
			std::println("match");\
		}\
		else {\
			std::println("Not match");\
		}

void match()
{
    regex pattern("<.*>.*</.*>");
    string str("<title>maye25</title>");

    CHECK(regex_match(str.data(), pattern));                //const char*
    CHECK(regex_match(str, pattern));                       //string
    CHECK(regex_match(str.begin(),str.end(), pattern));     //[first last]

}
```

##### 匹配手机号

```cpp
{
	//1，匹配手机号码
	std::vector<std::string> phone = {
		"13187050605","15675879209","18570365828","19198143084","11363691460"
	};
	for (auto& p : phone) {
		CHECK(std::regex_match(p, std::regex(R"(\d{11})")));		//只能限制数字
		CHECK(std::regex_match(p, std::regex(R"(^1[3-9]\d{9}$)")));	//必须以1开头，第二位必须在3-9之间
		CHECK(std::regex_match(p, std::regex(R"(^(13[0-9]|14[01456879]|15[0-35-9]|16[2567]|17[0-8]|18[0-9]|19[0-35-9])\d{8}$)")));	//指定运营商号段
	}
}    
```



#### 2，匹配结果

更多的时候我们希望能够获得匹配结果（字符串），对结果进行操作。这时就需要对匹配结果进行存储

```cpp
	{
		//完全匹配
		CHECK(std::regex_match("我的电话号码是13187050605，你记住了吗?", std::regex(R"(^\d{11}$)")));		//Not Match
		//部分匹配
		//CHECK(std::regex_match("我的电话号码是13187050605，你记住了吗?", std::regex(R"(^.*\d{11}.*$)")));	//Match
		//1,使用要匹配的字符串类型为const char*，对应的匹配结果类型为cmatch
		{
			std::cmatch match_result;
			CHECK(std::regex_match("我的电话号码是13187050605，你记住了吗?", match_result, std::regex(R"(^.*(\d{11}).*$)")));	//Match
			if (match_result.ready()) {
				for (auto& ret : match_result) {
					std::println("-> {}", ret.str());
				}
				//-> 我的电话号码是13187050605，你记住了吗?
				//-> 13187050605
			}
		}
		//2,使用要匹配的字符串类型为string，对应的匹配结果类型为smatch
		{
			std::smatch match_result;
			std::string str("我的电话号码是13187050605，你记住了吗?");
			CHECK(std::regex_match(str, match_result, std::regex(R"(^.*(\d{11}).*$)")));	//Match
			if (match_result.ready()) {
				for (auto& ret : match_result) {
					std::println("-> {}", ret.str());
				}
				//-> 我的电话号码是13187050605，你记住了吗?
				//-> 13187050605
			}
		}
	}
```

#### 3，贪婪模式

在上面的测试中，我们是刚好写了11位手机号，如果我们在手机号后面加一些其他数字会如何呢?

```cpp
{
	std::smatch match_result;
	std::string str("我的电话号码是131870506059898，你记住了吗?");
	CHECK(std::regex_match(str, match_result, std::regex(R"(^.*(\d{11}).*$)")));	//Match
	if (match_result.ready()) {
		for (auto& ret : match_result) {
			std::println("-> {}", ret.str());
		}
	}
}
```

输出结果如下：

```sh
-> 我的电话号码是131870506059898，你记住了吗?
-> 70506059898
```

根据输出结果我们发现，手机号貌似不对！在这一串数字中`131870506059898`，前11位才是手机号，后面的`9898`是我们额外添加的字符！

为什么会产生这种情况呢?

> 正则表达式中的贪婪模式和非贪婪模式是指量词匹配时的两种不同匹配方式，它们的区别在于匹配时的优先级和匹配的范围。

正则匹配默认是贪婪匹配的，在贪婪匹配下，`.*` 会匹配尽可能多的字符。正则表达式中`.*`后面是`(\d{11})`，也就是需要11个数字，因此，`.*`就尽可能匹配多的字符，这里就把1318匹配了，给`(\d{11})`留下个11数字就够了。最后得到的内容就是`70506059898`了。

在正则表达式中，使用 `?` 后缀可以将量词从贪婪模式切换为非贪婪模式。例如，`*?` 表示非贪婪的零次或多次匹配，而 `+?` 表示非贪婪的一次或多次匹配。

对于上面的案例，我们只需要把正则`R"(^.*(\d{11}).*$)"`改为`R"(^.*(\d{11}).*$)"`即可，匹配到`13187050605`正确的手机号了！

### regex_search

搜索匹配，根据正则表达式来搜索字符串中是否存在符合规则的子字符串。

#### 1，是否查找到

```cpp
void test_search_1()
{
    std::regex pattern("<img.*/>");
    std::string str("<title>maye25</title>\n<img src='maye/haha.png'/>\n<img/>\n<img/ src=''/>");

    if(std::regex_search(str, pattern)) {
		std::println("查找到了 ");
    }
    else {
		std::println("没有找到哟~");
    }
}
```

#### 2，查找并存储结果

```cpp
void searchGetResult()
{
    std::regex pattern("<img.*/>");
    std::string str("<title>maye25</title>\n<img src='maye/haha.png'/>\n<img/>\n<img src=''/>");

    std::smatch result;
    //找到一个匹配的之后，立马返回
    if(std::regex_search(str, result,pattern)) {
		std::println("查找到了 {}个", result.size());
        for (auto& r : result) {
            std::println("-> {}", r.str());
            //r.first 为匹配到的序列的开始
            //r.second 为匹配到的序列的最后一个位置
            //注意:返回的都是str的迭代器
			std::println("{} {}", *r.first, *r.second);
			std::println("{} {}", (r.first - str.cbegin()), (r.second - str.cbegin()));
        }
    }
    else {
        std::println( "没有找到哟~" );;
    }
}
```

#### 3，查找所有(循环查找)

```cpp
void loopSearch()
{
    std::regex pattern("<img.*/>");
    std::string str("<title>maye25</title>\n<img src='maye/haha.png'/>\n<img/>\n<img src=''/>");

    std::smatch result;
	std::println("loop search 1");
    //循环查找1(不推荐)，所有满足条件的
    std::string s = str;
	while (std::regex_search(s, result, pattern)) {
		for (auto& r : result) {
			std::println("{}", r.str());
			//std::println("---" << *r.first << *(r.first + 5) << " " << *r.second << *(r.second + 5) );
			s.assign(r.second, s.cend());    //这种方式不好，每次都要拷贝
		}
	}

	std::println("loop search 2");
	//循环查找2(推荐)，所有满足条件的
	auto csit = str.cbegin();
	while (regex_search(csit, str.cend(), result, pattern)) {
		for (auto& r : result) {
			std::println("{}", r.str());
			//std::println("---" << *r.first << *(r.first + 5) << " " << *r.second << *(r.second + 5) );
			//s.assign(r.second, s.cend()); //这种方式不好，每次都要拷贝
			csit = r.second;
		}
	}
}
```



### regex_replace

替换匹配，即可以将符合匹配规则的子字符串替换为其他字符串。要求输入一个正则表达式，以及一个用于替换匹配子字符串的格式化字符串。

#### 1,替换

```cpp
void replace()
{
    regex pattern("(hi|u|c)");
    string str = "oh!shit!fuck you!";
    cout<< regex_replace(str, pattern,"*");
}
```

以上代码会把str中所有的hi|u|uc替换成*，并返回一个新的string对象(str没有改变)，如果只想替换第一个匹配的，可以给`regex_replace`加上标志。

```
regex_replace(str, pattern,"*",regex_constants::format_first_only);
```

这样的话就只会把shit变为s*t,其他的不会改变。关于标志请参考[微软文档](https://learn.microsoft.com/zh-cn/cpp/standard-library/regex-constants-class?view=msvc-170)。

**除了以上方法之外还有一种方法操作。**

```cpp
    //1，复制 [first,last) 中的字符到 out ，以 re 所格式化的字符替换任何匹配 fmt 的序列
    //string output;
    //output.resize(str.size());    //注意访问越界问题
    //regex_replace(output.begin(), str.cbegin(), str.cend(), pattern, "*");
    //cout << "output:" << output << endl;
    //1.1同上，只不过传入的是char*数组
    char buf[1024] = {0};
    regex_replace(buf, str.cbegin(), str.cend(), pattern, "*");
    cout << "buf:" << buf << endl;

    //1.2 写结果到输出迭代器
    regex_replace(std::ostreambuf_iterator<char>(std::cout), str.begin(), str.end(), pattern, "*");
```

## regex迭代

正则表达式迭代器用于遍历序列中找到的整个正则表达式匹配集。

### [regex_iterator](https://en.cppreference.com/w/cpp/regex/regex_iterator)

 循环访问字符序列中与正则表达式匹配的项。

```cpp
void test_regex()
{
    std::string s = "I am maye";
    std::regex regex("[^\\s]+");
    
    std::sregex_iterator words_begin(s.cbegin(), s.cend(), regex);
    std::sregex_iterator words_end;

	std::println("found {} words:", std::distance(words_begin, words_end));

	for (auto it = words_begin;it != words_end;it++) {
        auto match_res = *it;
		std::println("{}", match_res.str());
    }
}
```

### [regex_token_iterator](https://en.cppreference.com/w/cpp/regex/regex_token_iterator)

  循环访问给定字符串中所有正则表达式匹配项中的指定子表达式，或通过不匹配的子字符串 （类模板） 

#### 按空格分割字符串

```cpp
void t()
{
	const char* text = "Hello world! How are you?";
	std::regex re("\\s+"); // 匹配一个或多个空白字符

	// 使用 submatch = -1 获取未匹配部分（即分割的令牌）
	std::cregex_token_iterator iter(text, text + std::strlen(text), re, -1);
	std::cregex_token_iterator end;

	std::vector<std::string> tokens;
	for (; iter != end; ++iter) {
		tokens.push_back(iter->str()); // 存储每个令牌
	}

	// 输出结果
	for (const auto& token : tokens) {
		std::println("{}", token);
	}
}
```

#### 提取特定捕获组

```cpp
void t()
{
	const char* text = "https://example.com http://google.com";
	std::regex re(R"((https?)://([^/\s]+))"); // 捕获协议和域名

	// 提取第1个捕获组（协议）和第2个捕获组（域名）
	std::cregex_token_iterator iter(text, text + std::strlen(text), re, { 1, 2 });
	std::cregex_token_iterator end;

	while (iter != end) {
		std::println("Protocol:{}", (iter++)->str());
        std::println("Domain:{}",  (iter++)->str());
	}
}
```



#### 小案例

##### 拆分单词

把英文字符串中每个单词拿出来。

```cpp
{
    std::string text = "I am maye,and you ?";
    std::regex rx("[\\s.,?]+");
    
    std::sregex_token_iterator next(text.begin(), text.end(), rx, -1);
    std::sregex_token_iterator end;

    for (; next != end; next++)
        std::cout << next->str() << std::endl;
    std::cout << std::endl;
}
```

正则`[\s.,?]+`表示匹配空白字符、点、逗号、问号中的任意一个，后面有+号，表示可以出现一次或多次。简单来说就是按空白字符、点、逗号、问号对字符串进行分割。

##### 获取\<a>超链接

```cpp
{
    std::string html = "<p><a href='https://www.baidu.com'>百度一下</a></p>"
        "< a   HREF='https://www.baidu.com'>百度一下</a>";


    std::regex rx("<\\s*a\\s+href\\s*=\\s*'([^']+)'\\s*>", std::regex::icase);

    std::sregex_token_iterator next(html.begin(), html.end(), rx, 1);
    std::sregex_token_iterator end;

    for (; next != end; next++)
        std::cout << next->str() << std::endl;
    std::cout << std::endl;

}
```
