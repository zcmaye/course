# 文件系统(C++17)

C++在17标准中，引入了文件系统库，可以很方便的对文件、目录进行操作。

## path

类型 `path` 的对象表示文件系统上的路径。只有路径的语法外观得到处理：路径名可能表示不存在的路径，或甚至不允许存在于当前文件系统或操作系统的路径。

路径可隐式转换自及转换成 [std::basic_string](https://zh.cppreference.com/w/cpp/string/basic_string) ，这使得在文件 API 上使用它们可行，例如作为到 [std::ifstream::open](https://zh.cppreference.com/w/cpp/io/basic_ifstream/open) 的参数

### 创建路径

+ 使用构造函数来创建一个路径，支持相对路径和绝对路径

  ```cpp
  fs::path patha(".");
  fs::path pathb("F:/MyCode/test_code/test_cpp_any");
  ```

+ 也可以在构造之后进行设置

  ```cpp
  patha = "aa/bb/cc";			//直接赋值
  patha.assign("./x64");		//重新分配
  patha.append("hello");		//追加路径(前面不能加斜杠)
  ```

+ 使用`clear`函数能清空路径

  ```cpp
  patha.clear();
  ```

+ 使用`empty`能判断路径是否为空

### 打印路径

path底层使用的是`std::wstring`，所以并不能直接使用println打印，必须要获取到`std::string`类型的字符串。

+ 使用`generic_string()`能获取通用字符串，类型为std::string。

  ```cpp
  std::println("{}", patha.generic_string());
  ```

+ path提供了迭代器，可以遍历路径中的每个块的内容

  ```cpp
  for (auto& s : patha) {
  	std::println("{}", s.generic_string());
  }
  ```

  结果为：

  > .
  > x64
  > hello

### 路径比较

使用`compare`函数来比较路径，示例代码如下：

```cpp
int ret = patha.compare(pathb);
if (ret == 0) { std::println("相等"); }
else if (ret > 0) { std::println("patha 大于 pathb"); }
else if (ret < 0) { std::println("patha 小于 pathb"); }
```

也可以直接使用运算符进行比较。

```cpp
patha == pathb;
patha != pathb;
patha > pathb;
patha >= pathb;
patha < pathb;
patha <= pathb;
```

### 判断函数

path中提供了许多判断函数，比如判断是否是相对或绝对路径。

+ 相对绝对路径判断

  ```cpp
  std::println("{}", patha.is_absolute());	//是否是绝对路径
  std::println("{}", patha.is_relative());	//是否是相对路径
  ```

+ 判断是否有**拓展名**(如：maye.txt，这里的txt就是文件拓展名)，如果有拓展名，可以通过`extension`函数获取拓展名。

  ```cpp
  patha = "aa/bb/maye.txt";
  std::println("{} {}", patha.has_extension(), patha.extension().generic_string());	//.txt
  ```

+ 判断是否有**文件名**(如：maye.txt，这里的maye就是文件名)，如果有文件，可以通过`filename`函数获取文件名。

  ```cpp
  std::println("{} {}", patha.has_filename(), patha.filename().generic_string());		//maye.txt
  ```

+ 判断是否有**主干**，如果是文件则返回文件名，如果是目录则返回目录名

  ```cpp
  std::println("{} {}", patha.has_stem(), patha.stem().generic_string());		//true maye
  patha = "aa/bb";
  std::println("{} {}", patha.has_stem(), patha.stem().generic_string());		//true bb
  ```

+ 判断是否有**父路径**

  ```cpp
  std::println("{} {}", patha.has_parent_path(), patha.parent_path().generic_string());	//aa/bb
  ```

+ 判断是否有**相对路径**

  ```cpp
  std::println("{} {}", patha.has_relative_path(), patha.relative_path().generic_string());	//aa/bb/maye.txt
  ```

+ 判断是否有**根目录**

  ```cpp
  patha = "aa/bb/maye.txt";
  std::println("{} {}", patha.has_root_directory(), patha.root_directory().generic_string());	//false 
  patha = "C:/aa/bb/maye.txt";
  std::println("{} {}", patha.has_root_directory(), patha.root_directory().generic_string());	//true /
  ```

+ 判断是否有**根目录名**和**路径**

  ```cpp
  patha = "E:/aa/bb/maye.txt";
  std::println("{} {}", patha.has_root_name(), patha.root_name().generic_string());	//true E:
  std::println("{} {}", patha.has_root_path(), patha.root_path().generic_string());	//true E:/
  ```

### 词法转换

这些转换完全是基于词汇层面的。它们不会检查路径是否存在，不会遵循符号链接，也不会访问文件系统。对于基于词汇层面的“相对”和“接近”的对应概念，请参阅[“相对”](https://en.cppreference.com/w/cpp/filesystem/relative.html)和[“接近”](https://en.cppreference.com/w/cpp/filesystem/relative.html)。

```cpp
assert(fs::path("a/./b/..").lexically_normal() == "a/");
assert(fs::path("a/.///b/../").lexically_normal() == "a/");
assert(fs::path("/a/d").lexically_relative("/a/b/c") == "../../d");
assert(fs::path("/a/b/c").lexically_relative("/a/d") == "../b/c");
assert(fs::path("a/b/c").lexically_relative("a") == "b/c");
assert(fs::path("a/b/c").lexically_relative("a/b/c/x/y") == "../..");
assert(fs::path("a/b/c").lexically_relative("a/b/c") == ".");
assert(fs::path("a/b").lexically_relative("c/d") == "../../a/b");
assert(fs::path("a/b").lexically_relative("/a/b") == "");
assert(fs::path("a/b").lexically_proximate("/a/b") == "a/b");
```

### 路径操作

#### 文件名和拓展

+ 移除文件名

  ```cpp
  patha = "E:/aa/bb/maye.txt";
  patha.remove_filename();
  std::println("{}", patha.generic_string());		// E:/aa/bb/
  ```

+ 替换文件名

  ```cpp
  patha = "E:/aa/bb/maye.txt";
  patha.replace_filename("hello.data");
  std::println("{}", patha.generic_string());	//E:/aa/bb/hello.data
  ```

+ 替换拓展名

  ```cpp
  patha = "E:/aa/bb/maye.txt";
  patha.replace_filename("hello.data").replace_extension(".c");
  std::println("{}", patha.generic_string());	//E:/aa/bb/hello.c
  ```

#### 路径拼接

+ 使用concat函数

  ```cpp
  patha = "C:";
  patha.concat("/windows");
  std::println("{}", patha.generic_string());
  ```

+ 使用运算符重载

  ```cpp
  patha += "/fonts";		//不会自动加上斜杠
  std::println("{}", patha.generic_string());
  
  patha /= "hello";		//会自动加上斜杠
  std::println("{}", patha.generic_string());
  ```

### 非成员函数

#### path哈希值

```cpp
auto hash = fs::hash_value(patha);
std::println("{}", hash);
```

#### 文件类型判断

| File types                                                   | 秒数                                        |
| ------------------------------------------------------------ | ------------------------------------------- |
| [is_block_file](https://en.cppreference.com/w/cpp/filesystem/is_block_file) | 检查给定路径是否指向块设备(函数)            |
| [is_character_file](https://en.cppreference.com/w/cpp/filesystem/is_character_file) | 检查给定的路径是否指向字符设备(函数)        |
| [is_directory](https://en.cppreference.com/w/cpp/filesystem/is_directory) | 检查给定的路径是否指向一个目录(函数)        |
| [is_empty](https://en.cppreference.com/w/cpp/filesystem/is_empty) | 检查给定的路径是否指向空文件或目录(函数)    |
| [is_fifo](https://en.cppreference.com/w/cpp/filesystem/is_fifo) | 检查给定路径是否引用命名管道(函数)          |
| [is_other](https://en.cppreference.com/w/cpp/filesystem/is_other) | 检查参数是否引用了“其他”文件(函数)          |
| [is_regular_file](https://en.cppreference.com/w/cpp/filesystem/is_regular_file) | 检查参数是否引用常规文件(函数)              |
| [is_socket](https://en.cppreference.com/w/cpp/filesystem/is_socket) | 检查参数是否引用了一个命名的IPC套接字(函数) |
| [is_symlink](https://en.cppreference.com/w/cpp/filesystem/is_symlink) | 检查参数是否引用符号链接(函数)              |
| [status_known](https://en.cppreference.com/w/cpp/filesystem/status_known)( | 检查文件状态是否已知(函数)                  |

#### 文件信息获取

| 函数            |
| --------------- |
| exists          |
| file_size       |
| last_write_time |

#### 文件拷贝

+ 使用`copy`函数能拷贝文件或目录

  ```cpp
  fs::copy("students.txt", "ss.txt");						//拷贝文件
  fs::copy("x64", "xx64",fs::copy_options::recursive);	//拷贝目录
  ```

  如果文件已经存在，则会拷贝失败，拷贝失败会**抛出异常**！可以加上`fs::copy_options::overwrite_existing`选项，来覆盖已经存在的文件。

  拷贝目录时，如果不加选项，则只会拷贝指定的目录，不会拷贝目录下面的文件，如果想要拷贝目录中的内容，必须加上`recursive`递归选项。

+ 使用`copy_file`来专门拷贝文件

  ```cpp
  fs::copy_file("students.txt", "ss.txt");
  ```

#### 文件创建

+ 创建目录，使用`create_directory`或`create_directories`函数来创建目录。

  ```cpp
  fs::create_directory("files");
  fs::create_directory("files/bb/cc");
  ```

  可以用来创建多级目录，目录存在不会失败~

+ 创建硬链接(可以理解为就是把文件拷贝了一份)

  ```cpp
  fs::create_hard_link("students.txt", "hstu.txt");
  ```

+ 创建软连接(快捷方式)，创建快捷方式的文件必须指定绝对路径！

  ```cpp
  std::error_code errc;
  fs::create_symlink("F:/MyCode/test_code/test_cpp_any/students.txt", "files/学生.txt",errc);
  if (errc) {
  	std::println("create symlink error:{}", errc.message());
  }
  ```

+ 获取符号链接的目标

  ```cpp
  try
  {
  	std::println("target :{}", fs::read_symlink("files/学生.txt").generic_string());
  }
  catch (const std::exception& e)
  {
  	std::println("Exception:{}", e.what());
  }
  ```

#### 文件删除/重命名

+ 删除文件，文件不存在不会失败

  ```cpp
  fs::remove("x64.lnk");
  ```

+ 删除目录，只能删除空目录(也就是说目录中有文件，会删除失败)

  ```cpp
  fs::remove("xx64",errc);
  if (errc) {
  	std::println("remove error {}", errc.message());
  }
  ```

+ 递归删除目录，使用`remove_all`函数可以递归删除目录(也就是说目录中有内容也会一并删除)，返回删除的文件数量。

  ```cpp
  fs::remove_all("xx64",errc);
  if (errc) {
  	std::println("remove_all error {}", errc.message());
  }
  ```

+ 重命名，可以给目录、文件重命名

  ```cpp
  	std::error_code errc;
  	fs::rename("xx64","xx64__", errc);
  	if (errc) {
  		std::println("remove error {}", errc.message());
  	}
  ```

#### 其他

##### 系统空闲空间

```cpp
std::error_code errc;
fs::space_info info = fs::space("C:/", errc);
if (errc) {
	std::println("remove error {}", errc.message());
}
else {
	std::println("总大小:{} 已用:{} 空闲:{}",info.available,info.capacity,info.free);
}
```

##### 系统临时文件目录

```cpp
std::println("{}", fs::temp_directory_path().generic_string());	//C:/Users/<User>/AppData/Local/Temp/
```

##### 修改文件大小

```cpp
fs::resize_file("ss.txt", 1024 * 1024);
```

## file_status

用于获取和修改文件（或目录）的属性。

### 获取文件状态

+ 通过status函数来获取文件状态

  ```cpp
  auto file_satus = fs::status("students.txt");
  ```

+ 还有一个`symlink_status`函数，专门用来获取符号链接的状态。

## directory_entry

```cpp
	fs::directory_entry entry("ss.txt");

	//判断文件是否存在
	if (entry.exists()) {
		//打印文件名
		std::println("{}", entry.path().filename().generic_string());
		//获取文件状态
		auto status = entry.status();
	}
```

## directory_iterator

directory_iterator是一个LegacyInputIterator()，它遍历目录的directory_entry元素(但不访问子目录)。迭代顺序没有指定，只是每个目录项只访问一次。跳过特殊的路径名.和..。

> 遗留输入迭代器(LegacyInputIterator) 仅保证单趟算法的有效性：一旦自增**遗留输入迭代器(LegacyInputIterator)** ，则所有其先前值的副本都可能失效。

首先，使用指定的路径创建迭代器。

```cpp
std::filesystem::directory_iterator it("./");
```

然后，遍历目录。

```cpp
for (auto& entry : dir_it)
{
	std::cout << entry << std::endl;
}
```

或者通过迭代器遍历，值得注意的是，迭代器遍历之后不能再次使用，必须重新创建。

```cpp
std::filesystem::directory_iterator dir_it("./");
for (auto it = std::filesystem::begin(dir_it); 
     dir_it != std::filesystem::end(dir_it); it++)
{
	std::cout << *it << std::endl;
}
```

## recursive_directory_iterator

std::filesystem::recursive_directory_iterator是一个LegacyInputIterator，它遍历目录的directory_entry元素，并递归地遍历所有子目录的条目。迭代顺序没有指定，只是每个目录项只访问一次。

除了和**directory_iterator**一样遍历目录外，还提供了一些方法。

+ 获取当前递归深度

  ```cpp
  int depth() const;
  ```

+ 检查当前目录是否禁用递归

  ```cpp
  bool recursion_pending() const;
  ```

+ 禁用递归，直到下一个增量

  ```cpp
  void disable_recursion_pending()
  ```

+ 将迭代器在目录层次结构中向上移动一级

  ```cpp
  void pop();					//异常版本
  void pop(error_code& _Ec);	//错误码版本
  ```

