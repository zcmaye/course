# 日期时间

*std::chrono* 是 C++11 引入的一个强大的时间处理库，用于测量时间间隔、计算时间点以及处理日期和时间。它提供了高精度的计时功能，适用于性能测试和时间管理。

要使用chrono库，需要#include<chrono>，其所有实现均在std::chrono namespace下。

`std::chrono`库主要包含以下功能：

- **时间点(time_point)**：表示特定的时间点，比如当前的时间。这如同人们通过记忆可以回忆起特定的时刻。
- **时间段(duration)**：表示时间的长度，比如1秒，1分钟，1小时等。这如同人们能够感知时间的流逝，理解"早","晚"等概念。
- **时钟(clock)**：用于获取当前的时间点，有三种类型的时钟：system_clock，steady_clock和high_resolution_clock。这如同人们通过看表来知道现在的具体时间。

## duration(时长)

### 简介

std::chrono::duration 表示一段时间，比如两个小时，12.88秒，半个时辰，一炷香的时间等等，只要能换算成秒即可。

```cpp
template <class _Rep, class _Period = ratio<1>> class duration;
```

+ **_Rep：**表示一种数值类型，用来表示_Period的数量，比如int、float、double...

+ **_Period：**是ratio类型，用来表示（用秒表示的）单位，比如second、milisecond...

  + 常用的`duration<Rep,Period>`已经预定义好了，如下：

    ```cpp
    using nanoseconds  = duration<long long, nano>;
    using microseconds = duration<long long, micro>;
    using milliseconds = duration<long long, milli>;
    using seconds      = duration<long long>;
    using minutes      = duration<int, ratio<60>>;
    using hours        = duration<int, ratio<3600>>;
    //C++20
    using days   = duration<int, ratio_multiply<ratio<24>, hours::period>>;
    using weeks  = duration<int, ratio_multiply<ratio<7>, days::period>>;
    using years  = duration<int, ratio_multiply<ratio<146097, 400>, days::period>>;
    using months = duration<int, ratio_divide<years::period, ratio<12>>>;
    ```

+  这里需要说明一下ratio这个类模版的原型：[](https://www.cnblogs.com/zlshmily/p/10058427.html)

  ```cpp
  template <intmax_t _Nx, intmax_t _Dx = 1> struct ratio;
  ```
  + **intmax_t**就是long long类型
  + **Nx**代表分子(秒数)，**Dx**代表分母(秒数对应的其他单位时长)，所以ratio表示一个分数值
  + 比如`ratio<3600,1>`表示小时单位，3600秒等于一小时，`ratio<1, 1000>`表示毫秒单位，一秒等于1000毫秒。

### 使用

#### 定义时长

直接使用内置类型定义即可！

```cpp
//1,表示年月日时分秒的时长
std::chrono::years years(5);		//5年
std::chrono::months months(5);		//5个月
std::chrono::days days(5);			//5天
std::chrono::weeks weeks(5);		//5周
std::chrono::hours hours(5);		//5个小时
std::chrono::minutes minutes(5);	//5分钟
//上面的类型都能直接转成下面的类型，详见后续代码
std::chrono::seconds secs(5);		//5秒钟
std::chrono::milliseconds ms(5);	//5毫秒
std::chrono::microseconds us(5);	//5微秒
std::chrono::nanoseconds us(5);		//5纳秒
```

还可以使用字面量重载快速定义时长。

```cpp
using namespace std::chrono;
auto years(5y);			//5年
//auto months(5);		//5个月(不支持后缀)
auto days(5d);			//5天
//auto weeks(5);		//5周(不支持后缀)
auto hours(5h);			//5个小时
auto minutes(5min);		//5分钟
auto secs(5s);			//5秒钟
auto ms(5ms);			//5毫秒
auto us(5us);			//5微秒
auto ns(5ns);			//5纳秒
```

用一种时长构造另一种时长，seconds之上的所有类型，都可以转换为seconds以及seconds之下的类型。

```cpp
std::chrono::years years(5);
std::chrono::months months = years
    
//std::chrono::days days = years;			//无法转换
//std::chrono::weeks weeks = years;			//无法转换
//std::chrono::hours hours = years;		 	//无法转换
//std::chrono::minutes minutes = years;		//无法转换
    
std::chrono::seconds secs = years;		
std::chrono::milliseconds ms = years;	
std::chrono::microseconds us = years;	
std::chrono::nanoseconds ns = years;	
```

使用`count`函数可以获取底层存储的时长基本类型。

#### 时长运算

Duration 支持一些质变运算符(++，--，+=，-=，*=，/=，%=)。

```cpp
using namespace std::chrono;
std::chrono::seconds secs(5);	

//时长和数值运算(整型和浮点型)
secs++;
std::println("{}", secs);
secs--;
std::println("{}", secs);
secs *= 10.2;
std::println("{}", secs);
secs /= 2.0;
std::println("{}", secs);
secs %= 10.2;
std::println("{}", secs)
    
//时长和时长运算
secs %= 2s;
std::println("{}", secs);
secs += 2h;
std::println("{}", secs);
secs -= 90min;
std::println("{}", secs);
```

Duration 支持基本的算术运算（+、-、*、/、%）,计算结果类型会自动转换为能表示两者的公共类型。

```cpp
	using namespace std::chrono;
	std::chrono::seconds secs(5);

	//时长和数值运算(整型和浮点型)
	auto total_sec = secs + 2h;			//seconds
	std::println("{}", total_sec);

	total_sec = secs - 1h;
	std::println("{}", total_sec);

	auto total_ = secs * 10.2;			//duration<double>
	std::println("{}", total_);

	total_ = secs / 2.0;
	std::println("{}", secs);

	total_ = secs % 10.2;
	std::println("{}", secs);
```

比较操作（==、!=、<、>等）

```cpp
	using namespace std::chrono;

	60min > 1h;
	60min >= 1h;
	60min < 1h;
	60min >= 1h;
	60min == 1h;
	60min != 1h;
```

#### 类型转换

当需要在不同精度的 duration 类型之间进行显式转换时，应使用 `std::chrono::duration_cast`，特别是从高精度向低精度转换时会发生截断。

```cpp
	using namespace std::chrono;
	//`duration_cast`转换时长到另一个时长
	std::println("{}", std::chrono::duration_cast<std::chrono::seconds>(2581ms));
	//`floor`转换时长到另一个时长,向下取整
	std::println("{}", std::chrono::floor<std::chrono::seconds>(2581ms));
	//`ceil`转换时长到另一个时长,向上取整
	std::println("{}", std::chrono::ceil<std::chrono::seconds>(2584ms));
	//`round`转换时长到另一个时长,就近取整，偶数优先
	std::println("{}", std::chrono::round<std::chrono::seconds>(2581ms));
	//`abs`获取时长的绝对值
	std::println("{}", std::chrono::abs(-3600ms));
```

## time_point(时间点)

std::chrono::time_point 表示一个具体时间，如上个世纪80年代、你的生日、今天下午、火车出发时间等，只要它能用计算机时钟表示。鉴于我们使用时间的情景不同，这个time point具体到什么程度，由选用的单位决定。一个time point必须有一个clock计时。

```cpp
template <class _Clock, class _Duration = typename _Clock::duration>
class time_point;
```

**示例**

```cpp
chrono::time_point<chrono::system_clock> s(chrono::system_clock::now());
//time_since_epoch():获取 1970-1-1 00:00:00 以来的秒数
cout << s.time_since_epoch().count() << endl;
```

## clocks(时钟)

时钟类提供了时间点的起点（epoch）和计时周期（tick period）。

### system_clock

我们的生活在时间的流逝中不断推进，这个自然的过程在C++中被封装在了`std::chrono::system_clock`这个类中。我们如同航海者使用指南针导航一样，可以借助`system_clock`在编程的海洋中导航。

`std::chrono::system_clock`是一个代表系统广泛使用的实时钟的类。它表示当前的墙上时间，从中可以获得当前时间，也可以在时间点上执行算术运算。

#### 获取当前时间

使用`now();`静态成员函数获取当前时间。

```cpp
//获取当前时间
auto  now = std::chrono::system_clock::now();
std::println("{}", now);	//202x-09-02 07:50:00.5004346

//获取自 1970-1-1 00:00:00 以来的秒数(duration)
auto secs = now.time_since_epoch();
std::println("{}", secs);	//17567994379496991[1/10000000]s
```

#### 时间信息获取

now函数返回的是`system_clock::time_point`类型，示一个时间点。但是我们通常需要更人性化的表达方式，比如年、月、日、小时、分钟和秒。

##### C风格

先将时间转成time_t类型的时间(秒数表示)。

```cpp
time_t now_time = std::chrono::system_clock::to_time_t(now);
std::println("{}", now_time);	//1756799437
```

然后使用localtime函数转成时间结构体。

```cpp
struct tm* _tm= localtime(&now_time);
std::println("{}/{}/{} {}:{}:{}", _tm->tm_year + 1900, _tm->tm_mon +1, _tm->tm_mday,
		_tm->tm_hour, _tm->tm_min, _tm->tm_sec);
```

还有一种方式是使用函数进行格式化操作，必须自己手动使用tm结构体成员。

```cpp
// 格式化输出
char time_str[100];
std::strftime(time_str, sizeof(time_str), "%Y-%m-%d %H:%M:%S", _tm);
```

##### C++风格

`std::format`可以与C++的`chrono`库一起使用，方便地格式化日期和时间。接下来学习如何使用`std::format`处理时间点、持续时间、时间格式化选项以及本地化日期和时间的显示。

**时间格式化选项**

要格式化日期和时间，可以使用扩展的格式说明符，如下所示：更多请[查看文档](https://www.cppreference.com/w/cpp/chrono/system_clock/formatter.html)

- `%Y`：四位年份
- `%m`：月份（01-12）
- `%d`：月份中的第几天（01-31）
- `%H`：小时（00-23）
- `%M`：分钟（00-59）
- `%S`：秒（00-60，因闰秒可能为60）

```cpp
std::println("{}", std::format("{:%Y/%m/%d %H:%M:%S}", now));
```

#### 时区设置

有时我们需要将时间转换到不同的时区，使用`std::chrono::locate_zone`即可获取指定的时区对象。

```cpp
// 转换到中国时区
//const std::chrono::time_zone* ny_tz = std::chrono::locate_zone("America/New_York");
const std::chrono::time_zone* ny_tz = std::chrono::locate_zone("Asia/Shanghai");
std::chrono::zoned_time zt_ny{ ny_tz, now };
std::println("Shang hai time: {}", zt_ny);
```

使用`std::chrono::current_zone`函数获取当前时区。

```cpp
auto cur_zone = std::chrono::current_zone();
std::println("{}", cur_zone->name());
```

可以通过如下方式获取所有支持的时区。

```cpp
	//获取时区数据库链表
	auto& tzdb_list = std::chrono::get_tzdb_list();
	//遍历时区数据库链表
	for (auto& tzdb : tzdb_list) {
		//获取时区数据库版本
		std::println("version:{}", tzdb.version);

		//获取时区数据库中每个时区
		for (auto& zone : tzdb.zones) {
			//获取时区名称
			std::println("name:{}", zone.name());
		}
	}
```

### steady_clock 

chrono::steady_clock 为了表示稳定的时间间隔，后一次调用now()得到的时间总是比前一次的值大（这句话的意思其实是，如果中途修改了系统时间，也不影响now()的结果），每次tick都保证过了稳定的时间间隔。

+ 获取当前时间

  ```cpp
  static time_point now();
  ```

#### 案例

##### 测量代码执行时间

```cpp
void test_b()
{
    // 开始时间点
    auto start = std::chrono::steady_clock::now();

    // 模拟一些耗时操作
	int count = 0;
	for (int i = 0; i < 10000000; i++) {
		int t = count;
		count = t + 1;
	}

    // 结束时间点
    auto end = std::chrono::steady_clock::now();

    // 计算时间间隔并转换单位
    auto elapsed_ns = end - start;
    auto elapsed_ms = std::chrono::duration_cast<std::chrono::milliseconds>(elapsed_ns);

    std::println("Elapsed time: {}",elapsed_ms);
    // 更精确的输出;可能输出类似 19.23 ms
	std::println("Elapsed time: {}",
		std::chrono::duration<double, std::milli>(elapsed_ns));
}
```

### high_resolution_clock

最后一个时钟，std::chrono::high_resolution_clock 顾名思义，这是系统可用的最高精度的时钟。实际上high_resolution_clock只不过是system_clock或者steady_clock的别名。



# 文件系统(C++17)

C++在17标准中，引入了文件系统库，可以很方便的对文件、目录进行操作。

## 库范畴定义

- **文件：**持有数据的文件系统对象，能被写入或读取，或二者皆可。文件拥有名称及属性，属性之一是文件类型：
  - *目录*：表现为目录条目的容器的文件，目录条目标识其他文件（其中一些可以是另外的嵌套的目录）。讨论到具体文件时，包含该文件目录条目的目录是其*父目录*。父目录能以相对路径名 ".." 表示。
  - *硬链接*：关联一个名字到一个既存文件的目录条目。若支持多重硬链接，则文件在最后一个到它的硬链接被移除后才被移除。
  - *符号链接*：关联一个名词到一个路径的目录条目，路径可以存在亦可不存在。
  - *常规文件*：不是其他文件类型的文件。

- **文件名：**命名一个文件的字符串。容许字符、大小写区别、最大长度以及被禁止名称是实现定义的。名称 "." （点）与 ".." （双点）在库层次拥有特殊含义。
- **路径：**标识一个文件的元素序列。它以可选的 *根名* （例如 Windows 上的 "C:" 或 "//server" ）开始，后随可选的 *根目录* （例如 Unix 上的 "/" ），后随零或更多个文件名（除了最后一个都必须是目录或到目录的链接）的序列。表示路径的字符串（*路径名*）的原生格式（如哪些字符被用作分隔符）与字符编码是实现定义的，库提供路径的可移植表示。

## 类

### path

类型 `path` 的对象表示文件系统上的路径。只有路径的语法外观得到处理：路径名可能表示不存在的路径，或甚至不允许存在于当前文件系统或操作系统的路径。

路径名拥有下列语法：

1. *根名*(可选) ：标识具有多根的文件系统（如 "C:" 或 "//myserver" ）的根。有歧义的情况下，将组成合法 *根名* 的最长序列当做 *根名* 。标准库可以在 OS API 所了解的 *根名* 外，定义额外的 *根名* 。

2. *根目录*(可选) ：目录分隔符，若存在，则标记此路径为*绝对*。若缺失（且异于根名的首元素是文件名），则路径为*相对*且要求另一路径作为解决此文件名的起始位置。

3. 零或多个下列者：

   - *文件名* ：不由目录分隔符或偏好目录分隔符组成的字符序列（操作系统或文件系统可能加上附加限制）。此名称可能标识一个文件、硬链接或目录。辨别二种特殊的 *文件名* ：
     - *.* ：由单个点字符 . 构成的文件名是指代当前目录的目录名
     - *..* ：由二个点字符 .. 构成的文件名是指代父目录的目录名。

   - *目录分隔符* ：正斜杠字符 / 或作为 `path::preferred_separator` 提供的另一种字符。若重复此字符，则它被处理成单个目录分隔符： /usr///////lib 与 /usr/lib 相同

路径能以下列算法正常化：

1. 若路径为空，则停止（空路径的正常形式是空路径）
2. 替换每个 *目录分隔符* （可以由多重斜杠组成）为单个 `path::preferred_separator` 。
3. 替换 *根名* 中的每个斜杠字符为 `path::preferred_separator` 。
4. 移除每个 *点* 和立即后随的 *目录分隔符* 。
5. 移除每个立即后随 *目录分隔符* 和一个 *点点* 的非 *点点* 文件名，还有立即跟随的 *目录分隔符* 。
6. 若存在 *根目录* ，则移除立即跟随它们的所有 *点点* 及任何 *目录分隔符* 。
7. 若最终文件名是 *点点* ，则移除任何尾随的 *目录分隔符* 。
8. 若路径为空，则添加一个 *点* （ ./ 的正常形式是 . ）

路径可由 [begin()](https://zh.cppreference.com/w/cpp/filesystem/path/begin) 与 [end()](https://zh.cppreference.com/w/cpp/filesystem/path/begin) 函数返回的迭代器逐元素遍历，这会以通用格式查看路径，并在根名、根目录及后继文件名元素上迭代（跳过目录分隔符，除了标识根目录者）。若路径中的最后元素是目录分隔符，则最后的迭代器将解引用为空元素。

调用任何的 `path` 非 const 成员函数会令所有引用该对象元素的迭代器非法。

若 OS 使用异于上述可移植*通用*语法的*原生*语法，则库函数被定义为接受“受检测格式”，以接受两种格式的路径名：当且仅当受检测格式匹配通用格式，但不为操作系统作为原生路径接受，才采用受检测格式参数。原生格式在目录路径名和文件路径名有别的 OS 上，若通用路径名以目录分隔符终止，则将它当做目录路径，否则当做常规文件。

任何情况下， path 类表型如同它以原生格式存储路径名，并自动于所需场合转换它为通用格式（每个成员函数都指定它转译的路径格式）

POSIX 系统上，通用格式就是原生格式，并且没有必要区别或转换它们。

路径可隐式转换自及转换成 [std::basic_string](https://zh.cppreference.com/w/cpp/string/basic_string) ，这使得在文件 API 上使用它们可行，例如作为到 [std::ifstream::open](https://zh.cppreference.com/w/cpp/io/basic_ifstream/open) 的参数



# 随机数