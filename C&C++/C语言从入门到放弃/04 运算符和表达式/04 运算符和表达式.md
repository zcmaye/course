# 运算符和表达式

**运算符**：运算符用于执行程序代码运算，会针对一个以上操作数来进行运算。例如：2+3，其操作数是2和3，而运算符则是“+”

**操作数**：是运算符作用于的实体，操作数指出指令执行的操作所需要数据的来源。

**表达式**：是由数字、运算符、数字分组符号（括号）、自由变量等以能<font color = red>求得数值的</font>有意义排列方法所得的组合。

**表达式书写规则**

+ 1，运算符不能相邻。例a+/b是错误的
+ 2，乘号不能省略。列x乘以y，应写成x*y，而不是xy
+ 3，可用多层括号表示运算次序，括号必须成对出现，均使用小括号。



**运算符优先级和结合性**

所谓优先级就是当一个表达式中有多个运算符时，先计算谁，后计算谁。这个其实我们在小学学算术的时候就学过，如`1+4÷2`

那么“结合性”是什么呢？优先级都是关于优先级不同的运算符参与运算时先计算谁后计算谁。但是如果运算符的优先级相同，那么先计算谁后计算谁呢？这个就是由“结合性”决定的。

比如`1+2×3÷4`，乘和除的优先级相同，但是计算的时候是从左往右，即先计算乘再计算除，所以乘和除的结合性就是从左往右。就是这么简单！

## 运算符分类

**按所需操作数分类：**

+ 单目运算符
+ 双目运算符
+ 三目运算符

**按作用分类：**

![image-20210406203856494](assets/image-20210406203856494.png)



## 算术运算符

| **符号** | **功能** |
| -------- | -------- |
| +        | 单目正   |
| -        | 单目负   |
| +        | 加       |
| -        | 减       |
| *        | 乘       |
| /        | 除       |
| %        | 取模     |

+ 单目正负不会改变操作数的值。

  ```CPP
  int num = 10;
  -num;	//表达式的值为-10  num还是为10
  ```

+ 整数相除会向下取整。

  ```cpp
  5/2   == 2
  5/2.0 == 2.5
  ```

+ 求模运算只针对整数。

  ```cpp
  5%2 == 1
  5.2%2		//语法错误
  ```

+ 求模运算的结果的符号，只与被模数(第一个操作数)有关

  ```cpp
  printf("%d\n", -5 % 2);	//-1
  printf("%d\n", 5 % -2);	//1
  ```

  

## 赋值运算符

| **符号** | **功能** |
| -------- | -------- |
| =        | 赋值     |
| +=       | 赋值     |
| -=       | 赋值     |
| *=       | 赋值     |
| /=       | 赋值     |
| %=       | 赋值     |
| <<=      | 赋值     |
| >>=      | 赋值     |

+ 将一个数据(常量或表达式)赋值给一个变量。

  ```cpp
  int age =18;
  age +=2;		//age = age +2;
  age +=5-3;		//age = age+(5-3);
  ```



## 关系运算符

| **符号** | **功能** |
| -------- | -------- |
| >        | 大于     |
| <        | 小于     |
| ==       | 等于     |
| >=       | 大于等于 |
| <=       | 小于等于 |
| !=       | 不等于   |

+ 关系表达式的值只有2种，为真(true)返回1，为假(false)返回0。
+ 所谓关系运算，就是做比较，日常生活中经常遇到一些真假判断，比如说，“张三比李四高”、“济南到北京比济南到上海近”，“5大于2”这些问题的答案是真或假。程序设计是对实际问题解决过程的模拟，常常需要做判断，像“如果这样，我就执行动作A，如果那样，我就执行动作B”，那怎么判断这样那样呢，就需要关系运算符和关系表达式。



## 逻辑运算符

| **符号** | **功能**   |
| -------- | ---------- |
| &&       | 逻辑与     |
| \|\|     | 逻辑或     |
| !        | 单目逻辑非 |

+ 逻辑表达式的值只有2种，为真(true)返回1，为假(false)返回0。
+ 一般用来连接关系表达式。

![image-20210406212213897](assets/image-20210406212213897.png)

### 短路现象

在由&&和||运算符组成的逻辑表达式中，C语言有个“节省计算”原则，当计算出一个子表达式的值后便可确定整个逻辑表达式的值时，后面的子表达式就不需要再计算了，这种表达式也称为短路表达式。

**举个栗子：**

```cpp
false  && printf("1\n");
true   && printf("2\n");

false  || printf("3\n");
true   || printf("4\n");
//output :2
//		  3	
```

对于&&符号，如果左边表达式为false，则右边表达式不会执行，即不会执行printf(“1”)，如果左边表达式为true,则右边表达式会执行，即会执行printf(“2”)，输出2

对于||符号,如果左边为true,则右边表达式不会执行，即不会执行printf("4")，如果左边表达式为false,则右边表达式会执行，即执行printf("3"),输出3。



## 特殊运算符

### 特殊算术运算符

| **符号** | **功能** |
| -------- | -------- |
| ++       | 自增     |
| --       | 自减     |

+ 对变量进行+1和-1的操作。

+ 只能对变量使用，不能用于常量和表达式
+ 前置时是先运算、后使用
+ 后置时是先使用、后运算
+ 注意：不要嵌套使用  

```cpp
int a = 1;
printf("%d", (a++ + ++a));  //1 + 3
```

**案例：** **有的同学会问，如下代码输出多少，为什么？**

```cpp
int a = 0;
printf("%d %d %d\n", a++, ++a, a);
```

**输出原因解析:**

1. 从右往左分别计算 a ++a a++
2. 首先，计算a，很显然为0
3. 然后，计算++a，很显然为1 (注意:此时还没有开始输出，所以第二步的a也是1，不再是0了)
4. 最后，计算a++，很显然a先输出，在参与运算，此时为1，但是参与运算之后，后面的两个a都变成了2
5. 总结，这个代码与函数的参数入栈顺序有关，每个编译器不一定一致，所以是C语言未定义的行为

### 逗号运算符

用逗号将多个表达式连接起来，又称为“顺序求值运算符”。整个表达式的值是最后那个逗号之后表达式的值。

**逗号表达式两种作用：**

+ 分割：

  ```cpp
  int a,b,c,d;
  ```

+ 求值：

  ```cpp
  int a = (1,3,5,7,9);
  int b = 1,3,5,7,9;
  ```

  

### 条件表达式

条件表达式可以对指定的条件进行判断，true和false分别执行不同的代码。

>条件 ？表达式1 ： 表达式2

```cpp
printf(5 > 0 ?  "正数" : "负数");
printf((5 > 0) ?  ("正数") : ("负数"));		//为了避免眼花缭乱，可以把每个表达式都加上圆括号
```

### 取地址符

&变量名：获取任何变量的地址

### sizeof

sizeof() 是一个判断数据类型或者表达式长度(字节大小)的运算符，对 sizeof() 的处理都是在编译阶段进行。

### 类型转换

(目标类型)数据：

## 位运算符

| **符号** | **功能** | **记忆技巧**     |
| -------- | -------- | ---------------- |
| &        | 按位与   | 有0则0           |
| \|       | 按位或   | 有1则1           |
| ^        | 按位异或 | 相同为0，不同为1 |
| ~        | 单目取反 | 0变1,1变0        |
| <<       | 左移     | 移位右边补0      |
| >>       | 右移     | 右移左边补0      |

+ 位运算只针对**整型**和**字符型**，而且是直接对二进制进行操作



### 按位与&

这个符号其实和逻辑与运算 && 意思一样，只不过作用在每一位上。

**有0则0：**对于每一位来说，两个数都是真，则为真，否则为假。

```cpp
3-> 0b 0000 0011
2-> 0b 0000 0010
3&2 ->0b 0000 0010
```



### 按位或|

同理，和逻辑或运算 || 意思一样，只不过作用在每一位上。

**有1则1：**对于每一位来说，但凡有个真的就是真，否则为假。

```cpp
3	-> 0b 0000 0011
2	-> 0b 0000 0010
3|2 ->0b 0000 0011
```



### 按位异或^

**相同为0，不同为1：**对于每一位来说，只要相同就为0，不同就为1。

```cpp
3	-> 0b 0000 0011
2	-> 0b 0000 0010
3^2 ->0b 0000 0001
```



### 按位取反

取反是一个单目运算符，对每一位进行取反，**即0变1，1变0**

```cpp
6	-> 0b 0000 0110
~6	-> 0b 1111 1001    //补码:最高位变成了符号位，所以结果肯定是一个负数
       0b 1000 0110	  //反码
       0b 1000 0111	  //原码
result: -7
```

思考：~0是多少？有用吗？

### 左移

左移操作就是把这些0啊1啊的整体往左移动 n 位，右边缺的就补充 0。

```cpp
3		-> 0b 0000 0011
3<<1 	-> 0b 0000 0110 ==6
    
2		-> 0b 0000 0010
2<<2 	->0b 0000 1000 == 8
```

诶，大家发现没有，左移 1 位之后这个数相当于乘2。

但是这只适用于左边溢出的高位中不包含 1 时。

如果把 1 扔了，那就肯定不是 2 倍了嘛。



### 右移

右移操作就是整体往右移动 n 位，左边缺的补充符号位。

```cpp
3		-> 0b 0000 0011
3>>1 	-> 0b 0000 0001 ==1
    
2		-> 0b 0000 0010
2>>2    -> 0b 0000 0000 == 0
```

同理，正数右移操作的效果是这个数除以 2。

### 位运算案例

1. 判断一个数的最低位是0还是1

   ```cpp
   uint32_t num = 1;
   if (num & 0x1)
   {
   	printf("& num low bit not zero\n");
   }
   ```

2. 判断一个数的最高位是0还是1

   ```cpp
   uint32_t num = 0x8000'0000;
   if ((num >> 31) & 0x1)
   {
   	printf("& num low bit not zero\n");
   }
   ```

3. 取出uint32_t类型的每个字节的数

   ```cpp
   uint32_t num = 0x12345678;
   uint8_t b1 = (uint8_t)num;
   uint8_t b2 = (uint8_t)(num >> 8);
   uint8_t b3 = (uint8_t)(num >> 16);
   uint8_t b4 = (uint8_t)(num >> 24);
   printf("%x %x %x %x\n", b1, b2, b3, b4);
   ```

4. 给定两个uint8_t类型的数，分别放入uint16_t类型的高字节和低字节

   ```cpp
   uint8_t b1 = 0x1A;
   uint8_t b2 = 0x2B;
   uint8_t b3 = 0x3C;
   uint8_t b4 = 0x4D;
   
   uint32_t res = 0;
   res = (uint8_t)b4 | (b3 << 8) | (b2 << 16) | (b1 << 24);
   printf("%X", res);
   ```

5. 现有如下几个状态

   ```cpp
   const int Play = 1 << 0;		//1 播放状态
   const int Stop = 1 << 1;		//2 停止状态
   const int Pause = 1 << 2;		//4 暂停状态
   ```

   如果用一个变量，保存多种状态，并能反向识别出该变量有哪些状态，应如何处理？

   ```cpp
   int state = Play | Stop;
   if (state & Play)
   {
   	printf("Play\n");
   }
   if (state & Stop)
   {
   	printf("Stop\n");
   }
   if (state & Pause)
   {
   	printf("Pause\n");
   }
   ```

   