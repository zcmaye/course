## 宏（Macro）

### 宏的定义

在 C 语言中，宏是由 预处理器（Preprocessor） 处理的文本替换机制。通过宏定义，我们可以在编译前阶段对源代码进行一系列替换或生成操作。宏本身并不进行类型检查，纯粹是基于文本进行的替换。

**核心特点：**

+ 预处理阶段执行：宏展开在编译器处理源码之前执行，因此不会带来运行时的函数调用开销。
+ 不进行类型检查：宏基于文本替换而非函数调用，使用时需要格外小心括号及参数顺序等问题。
+ 灵活而强大：可以用于定义常量、简化函数调用、做条件编译，以及元编程风格的代码生成。

### 宏的常见用途

+ 符号常量：使用 #define 替代具有固定值的符号。
+ 宏函数（带参数的宏）：在不涉及过多类型检查的情况下，用来编写内联式的功能代码。
+ 条件编译：通过 #if/#ifdef/#ifndef/#endif 等，针对平台或配置做差异化编译。
  

### 基础用法

宏定义基本形式如下：

```css
#define 宏名 替换文本
```

- 宏名：通常使用全大写字母（这是惯例，便于区分变量），遵循C语言标识符规则。
- 替换文本：可以是数字、字符串、表达式，甚至多行代码（通过续行符 `\`）。

> 注意：#define 指令必须单独占一行，以`#`开头，且通常放在文件顶部或头文件中。

与变量不同，宏没有类型检查，完全是文本替换，因此使用时需要格外小心。

#### 简单的常量宏

常量宏允许程序员为一组相关的常量赋予有意义的名称，使得代码更易于理解。例如，在处理星期几、方向、状态等时，使用宏可以避免使用魔法数字（如0、1、2等），从而使代码更具可读性。

> 对于整数类型，推荐使用枚举类，对于其他类型，比如字符串，则必须使用宏，因为枚举不支持字符串。

```css
#define PI 3.1415926
#define BUFFER_SIZE 1024
```

在任何使用这些宏的地方，在预编译时，都会被替换为对应的替换文本，只负责替换不负责类型检查。

#### 带参数的宏

**带参数的宏定义**是一种通过预处理指令`#define`实现的功能，用于在代码中进行参数化的文本替换。它可以简化代码、提高可读性，并减少重复代码的编写。

带参数的宏定义格式如下：

```css
#define 宏名(参数1, 参数2, ...) 替换列表
```

例如，定义一个求两个数最大值的宏：

```css
#define MAX(a, b) ((a) > (b) ? (a) : (b))
```

在使用时：

```c
int result = MAX(5, 3); // 替换后为：((5) > (3) ? (5) : (3))
```

结果为*result = 5*。

**注意事项**

- **括号的使用**：在宏体和参数周围使用括号，避免运算优先级问题。例如：

```c
#define SQUARE(x) ((x) * (x))
#define SQUARE_NO(x) x * x

SQUARE(1+2);		// 替换后为：((1+2)*(1+2)) = 9	这才是我们想要的结果！
SQUARE_NO(1+2);		// 替换后为：1+2*1+2		  = 5	这不是我们想要的结果！
```

- **参数替换**：预处理器仅进行简单的文本替换，不会检查参数类型或逻辑正确性。因此，需确保传入参数的正确性。

- **避免副作用**：如果参数包含副作用表达式（如*++i*），可能会导致多次求值，产生意外结果。例如：

```c
#define SQUARE(x) ((x) * (x))

int i = 2;
int result = SQUARE(++i); // 替换后为：((++i) * (++i))
```

#### 可变参数宏

可变参数宏能定义一个能够接受不同数量参数的宏函数，这种宏定义的主要应用场合是可以实现消息打印函数的自定义，并可以控制其起作用的时机，例如，在调试阶段打印出各种调试信息，而在正式发布时，就取消打印。

可变参数宏定义的基本语法是使用省略号（...）作为参数，表示该宏可以接受多个参数。在宏定义中，使用`__VA_ARGS__`来代替传入的所有参数。例如，以下是一个简单的可变参数宏定义的例子：

```css
#define HDY_LOG(fmt,...) printf(fmt,##__VA_ARGS__)
```

> `##__VA_ARGS__` 在没有可变参数时会自动去除前面多余的逗号。

比如：

```c
HDY_LOG("%s,%d","maye",28);
```

在这个例子中，`mlog`可以接受任意数量的参数，并将它们传递给`printf`函数。当你调用`mlog`时，`__VA_ARGS__`会被替换成所有传入的参数。

#### 多行宏

通过反斜杠 `\` 可以将宏定义延伸到多行，同时要注意换行处必须有反斜杠，并且换行符后面不能有任何字符(空格注释都不行)：

```css
#define PRINT_DEBUG_INFO(code)                  \
    printf("File: %s\n", __FILE__);             \
    printf("Line: %d\n", __LINE__);             \
    printf("Function: %s\n", __func__);         \
    printf("Code: %d\n", (code))
```

1. **多行宏** 让宏具有更复杂的行为，但仍是文本替换。
2. 在实际使用时，最好只将非常相关的逻辑封装在多行宏里，避免可读性低或维护困难。

#### 标识符拼接(##)

`##`能进行标识符拼接（token pasting），是预处理器的一项功能，它可以将两个标记连接成一个。这在宏定义中非常有用，特别是当需要生成不同的标识符名称时。

```c
#define CONCAT(a, b) a##b

int main() {
    int xy = 10;
    printf("%d", CONCAT(x, y));  // 输出10，因为CONCAT(x, y)变成了xy
}
```

#### 参数转字符串(#)

`#`能将宏参数，转成字符串。

```c
#define PRINT_VAR(var) printf(#var " = %d\n", var)

int main() {
    int x = 5;
    PRINT_VAR(x); // 宏展开后：printf("x" " = %d\n", x);
    return 0;
}
```

在调试或日志场景中，可以借此自动打印变量名称。

#### do...while(0)包裹多行宏

使用do...while(0)结构来包裹多行宏是一种常见的技巧，主要原因有以下几点：

+ **避免分号问题**：如果宏包含多条语句，在使用时如果没有用大括号包裹，可能会与周围的语句产生交互问题。例如：

```c
#define SWAP(a, b) \
     int temp = a; \
     a = b; \
     b = temp;

if (condition)
     SWAP(x, y);
else
     ... 
```

展开后就会编译错误，因为if后面跟了多条语句而没有用大括号，导致else没有对应的if。

使用do...while(0)可以解决这个问题：

```c
#define SWAP(a, b) 		\
     do { 				\
         int temp = a;	\
         a = b; 		\
         b = temp; 		\
     } while(0)

if (condition)
     SWAP(x, y);
else
     ... 
```

这样，do...while(0)被看作一条语句，所以else不会出现匹配问题。

+ **避免空语句警告**：如果使用单独的块（即只用大括号包裹），在宏后面跟上分号后，会形成一条完整的语句。但是，如果使用do...while(0)，后面跟上分号是正常的，不会产生警告。而如果使用大括号包裹，在一些编译器中可能会产生“空语句”的警告（如果大括号后面直接跟分号，实际上是一个空语句块，但通常不会警告，但do...while(0)更自然）。

+ **避免嵌套问题**：如果宏内部有循环或开关语句，使用do...while(0)可以确保宏展开后不会与外部代码的循环或开关产生混淆。

+ **保证宏的独立性**：使用do...while(0)可以确保宏在任何地方都能独立使用，不会受到周围代码结构的影响。

+ **允许在条件语句中使用**：如上例，可以在if-else中使用，而不会破坏结构。

总结：使用do...while(0)包裹多行宏，可以确保宏在展开后不会与周围的代码结构产生交互问题，保证宏的独立性和安全性。

#### `_Generic`

##### _Generic使用

在C11中引入的_Generic关键字支持编译时类型选择，允许开发人员实现轻量级泛型编程。它计算表达式的类型，并从列表中选择相应的表达式。

> `_Generic` 是 C11 标准特性，大多数现代编译器（如 GCC、Clang）均已支持，但如果使用过旧编译器（或一些嵌入式编译器），可能需要手动指定 `-std=c11` 并确认支持情况。

```css
_Generic(表达式, 
    类型1: 结果1,
    类型2: 结果2,
    ...
    默认:  默认结果
)
```

+ 表达式：要判断其类型的对象。
+ 类型1: 结果1：如果“表达式”的类型是“类型1”，则替换为“结果1”。
+ 默认：可以添加一个 default: 来指定在所有类型都不匹配时返回的结果（可选）。

例如：

```c
	int a = 10;

	const char* name = _Generic(a,
		char : "Char",
		int : "Int",
		float : "Float",
		double : "Double",
		default: "Unknown"
		);

	printf("typename is %s\n", name);	//输出：typename is Int
```

##### 配合宏使用

宏中先调用 `_Generic`，根据传入参数的类型，选择一个函数标识符，然后再用 `(x)` 调用它。例如：

```css
#define my_abs(x)  \
  _Generic((x),    \
    int:    abs,   \
    long:   labs,  \
    double: fabs   \
  )(x)
```

+ 当传入 x 的类型是 int 时，表达式替换为 abs；
+ 当类型是 long 时，替换为 labs；
+ 当类型是 double 时，替换为 fabs；
+ 如果没有写 default:，而传入了其他类型，会编译报错。

+ 整个宏最后加了一个 (x)：意思是先把 _Generic((x), ...) 这部分映射到对应的函数名（例如 abs），再调用此函数并传入 x 作为参数。

调用示例：

```c
int main() {
    int    i = -10;
    long   l = -100L;
    double d = -3.14;

    printf("my_abs(i) = %d\n", my_abs(i));     // 等价于 abs(i)
    printf("my_abs(l) = %ld\n", my_abs(l));    // 等价于 labs(l)
    printf("my_abs(d) = %f\n", my_abs(d));     // 等价于 fabs(d)

    return 0;
}
```

### 具体用例

#### 生成函数

```c
#include <stdio.h>
#include <time.h>
#include <stdlib.h>

//生成函数
#define TEST_FUN(id, ...)  void function_##id(__VA_ARGS__)

//调用函数
#define TEST_FUN_CALL(id,...)\
	do{\
		printf("---- Call function_%s\n", #id);\
		clock_t start = clock();\
		function_##id(__VA_ARGS__);\
		printf("---- function_%s time: %fs\n\n", #id, (double)(clock() - start) / CLOCKS_PER_SEC);\
	}while(0)


//宏定义函数
TEST_FUN(foo) {
	_sleep(500);
}

//宏定义带参数的函数
TEST_FUN(bar, int a, char* str) {
	printf("%d %s\n", a, str);
}

int main()
{
	//宏定义函数调用
	TEST_FUN_CALL(foo);
	TEST_FUN_CALL(bar, 11, "Hello World!");
	return 0;
}
```

#### 生成枚举

#### 打印日志

```c
#include <stdio.h>
#include <stdlib.h>

#define HDY_LOGi(fmt,...) printf("\033[36m[I]: %s[%d] : "   fmt "\033[m\n", __FILE__, __LINE__,##__VA_ARGS__)
#define HDY_LOGd(fmt,...) printf("\033[37m[D]: %s[%d] : "   fmt "\033[m\n", __FILE__, __LINE__,##__VA_ARGS__)
#define HDY_LOGw(fmt,...) printf("\033[33m[W]: %s[%d] : "   fmt "\033[m\n", __FILE__, __LINE__,##__VA_ARGS__)
#define HDY_LOGe(fmt,...) printf("\033[31m[E]: %s[%d] : "   fmt "\033[m\n", __FILE__, __LINE__,##__VA_ARGS__)
#define HDY_LOGf(fmt,...) printf("\033[1;31m[F]: %s[%d] : " fmt "\033[m\n", __FILE__, __LINE__,##__VA_ARGS__);abort()


int main()
{
	HDY_LOGi("This is a log info");
	HDY_LOGd("This is a log debug");
	HDY_LOGw("This is a log warning");
	HDY_LOGe("This is a log error");
	HDY_LOGf("This is a log error %s", "test");

	printf("Hello World\n");
	return 0;
}
```

