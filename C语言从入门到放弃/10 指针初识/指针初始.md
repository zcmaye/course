# 初识指针

## 地址

+ 什么是地址：内存是由很多得内存单元(字节)组成的,每个字节都有唯一的编号，这个编号就叫做地址。

![image-20210728160818569](assets/image-20210728160818569.png)

+ 我们原先学过的变量、数组、函数等都是放在内存中的，我们可以通过名字去使用变量、数组、函数等，但实际运行时，系统使用得是内存地址，而不是变量名，变量名只是方便我们程序员使用的。

**怎么获得变量的地址呢？**

+ 前面我们学习过scanf函数，在输入数据时用到了&符号，这个符号就是获取变量的地址的符号。

  ```c
  int age = 18;
  //输出age变量的地址
  printf("addr:%p\n",&age);
  ```

**注意：**

+ 每个内存单元之间地址是连续的
+ 在同一台机器上每个内存单元的地址是唯一的
+ 每次运行程序，变量的地址不一定一样，这是由操作系统随机分配的

## 首地址

首地址就是该变量所占的存储区域中的第一个单元的地址。

+ 以一个整型来说，需要四个字节来存储，那么每个字节都有一个地址，但是我们取地址得到的只有一个地址，这个地址叫做首地址。（大家理解这个概念就好，一般不会这么叫，就直接叫变量的地址了）

+ 为了便于访问，一个变量所占用的这几个内存单元都是连续存放，地址连续的几个单元通常就叫做一个“存储区域”。

  ![image-20220720160425846](assets/image-20220720160425846.png)

## 指针

指针实际上是一种特殊的数据类型，我们可以用来申明指针变量，用来存储地址。

![image-20210728163452903](assets/image-20210728163452903.png)

```c
int *p;
int *p1,*p2,*p3;	
```

同时定义多个指针变量时，每个标识符前面都要加*号，否则后面的会被定义成int型变量。

**取地址我们已经学习过了，那么怎么根据指针获取对应的内存的数据呢？**

&：取地址符。用于获取变量所在的首地址

\*：间接访问运算符，也叫作解引用运算符。用于获取地址对应的值。

这两个运算符的优先级一样，结合起来使用也非常简单！(如果不理解，最好加上括号；如：*(&p))

![image-20210728164145489](assets/image-20210728164145489.png)



指针作为一个变量是有大小的，其大小在32位平台是4个字节，64位平台上是8个字节，大小与指针的类型无关。

![image-20220720162037899](assets/image-20220720162037899.png)

![image-20220720162100057](assets/image-20220720162100057.png)

上图以64位平台为例，可以看到无论指针是整型、字符型、浮点型也无论一级指针还是二级指针，其在内存空间所占的大小都是4个字节。

**使用指针的好处：**

+ 1、直接访问硬件
+ 2、快速传递数据（指针表示地址）
+ 3、返回一个以上的值，返回一个（数组或者结构体的指针）
+ 4、方便处理字符串

## 指针的类型

指针使用来间接访问内存的，那么就需要知道指针指向的是什么样的数据类型，应该如何解析它。

所以我们需要一个特定类型的指针变量来存放特定类型变量的地址。

+ int*  ->  int
+ char* - > char
+ double* -> double
+ int* - >char   <font color=red>错误！错误！错误!</font>

为什么这么麻烦呢？指针不就是存储一个地址吗，为什么不能用一个通用的指针类型，来存储所有类型变量的地址呢？

因为，我们不仅仅使用指针来存储内存地址；同时也是用它来解引用那些地址的内容。这样我们就可以访问和修改这些地址对应的值了。

正如你所知，不同的数据类型有不同的大小，char 1个字节，int 4个字节，double 8个字节。不仅仅是大小方面的差异，这些变量或数据类型在存储信息的方式上也有所不同。

![image-20220720164614597](assets/image-20220720164614597.png)

上图所示，如果是int类型，那么最高位表示符号位，剩下的31个位用来存储值。

现在如果声明一个指针p指向整型变量，然后用取地址符把a的地址存放在p中，然后打印p，p的值会是多少呢？0x200，也就是byte0的地址，也就是说整型变量a的起始地址是0x200；

如果我们想知道那个地址的内容(值)，就使用*p去解引用这个地址。然后编译器看到之后就会觉得没有问题，p是一个指向整型的指针，因此我们需要看4个字节。从地址0x200开始，编译器就知道如何去提取一个整型数据。所以，它从这四个字节中得到了1025这个值。

如果p是一个字符类型的指针，那么在解引用的时候编译器只会看一个字节，因为一个字符类型只有一个字节。如果p是一个浮点型指针，尽管浮点型也是4个字节，但是浮点数4字节的信息表示缺与整型不一样。打印出来的值也会是不一样的。

### void指针

void* 类型的指针又叫万能指针，他可以指向任意的内存空间地址

+ 可以指向任何地址

  ```c
  int maye = 20;
  void* p = &maye;
  ```

+ 可以隐式自动转换为其他类型指针

  ```c
  int* pi = p;
  ```

+ 不能对void*取值操作，因为它没有类型，或者说不能判断存储的是什么类型，需要强转指定一个确定的类型才能使用

  ```c
  printf("%d\n",*p);		//error
  printf("%d\n",*(int*)p);//right
  ```





## 指针的特殊状态

我们在使用指针的时候，总是会遇到各种稀奇古怪的问题，但万变不离其宗，下面我们一起来学习指针的各种状态。

### 野指针

野指针(wild pointer)就是没有被初始化过的指针。

【示例：】

```c
#include<stdio.h>
int main()
{
    int *p;
    printf("%d\n",*p);
    return 0;
}
```

如果用Vs编译，会直接报错`error C4700: 使用了未初始化的局部变量“p”`,还是比较人性的，从根本上避免了野指针。

### 空指针

空指针就是被赋值为NULL的指针，它不指向任何的对象或者函数。（坚决不能使用空指针，否则程序就会崩）

空指针的出现是为了避免错误的引用指针而导致的难以排查的问题，不过空指针也不能直接访问，但是可以用来判断。

【示例：】

```c
#include<stdio.h>
int main()
{
    int* p = NULL;
    //判断指针是否为NULL
    if (p != NULL)
    {
        printf("%d\n", *p);
    }
    return 0;
}
```

如果把指针值为空，则可以进行判断，就算没有判断，直接对空指针进行引用，产生的报错也非常好理解。

![image-20220216200008510](assets/image-20220216200008510.png)

### 悬空指针

悬空指针是指针最初指向的内存已经被释放了的一种指针。 

【示例：】从函数中返回临时变量的地址

```c
#include<stdio.h>

int* foo()
{
    int age = 18;   //函数执行完毕，age的内存会被自动释放
    return &age;   
}
int main()
{
    int* p = foo();
    //getchar();
    printf("%d\n", *p);
    return 0;
}
```

运行上面的代码，貌似没有任何问题，的确如此，但不代表这个代码是正确的。现在我们把main函数中的getchar的注释放开，然后重新运行程序，等待几秒之后按下任意键，发现输出的结果已经不对了。

为什么？一开始的时候我们没有getchar，foo函数返回之后，接着立马输出*p，这个时候函数里面的age还没有来得及释放，所以输出没问题，但是当我们使用getchar等待一段时间后，age有足够的时间释放了，所以就会输出垃圾值。

**注意：**悬空指针是编码过程中最容易出现问题的，切记，认真检查！

## const 与 指针

const是constant的简写，只要一个变量前面用const来修饰，就意味着该变量里的数据可以被访问，不能被修改。也就是说const意味着“只读”。任何修改该变量的尝试都会导致编译错误。const是通过编译器在编译的时候执行检查来确保实现的（也就是说const类型的变量不能改是编译错误，不是运行时错误。）所以我们只要想办法骗过编译器，就可以修改const定义的常量，而运行时不会报错。

const与指针可以搭配出三种不同的含义：

+ 指针指向的内存不可修改，但指针的指向可以修改

  ```c
  int age = 18;
  const int* ptr = &age;		//常量指针
  int const* ptr = &age;		//和上面一句是等价的
  
  *ptr = 20;					//err,不能修改
  ptr = NULL;					//ok,可以修改指向
  ```

+ 指针的指向不可以修改，但指向的内存可以修改

  ```c
  int* const ptr = &age;
  *ptr = 20;	//ok
  ptr = NULL;	//err
  ```

+ 指针的指向不可以修改，指向的内存也不可以修改

  ```c
  const int* const ptr = &age;
  *ptr = 20;	//err
  ptr = NULL;	//err
  ```

**常量指针**(`指向常量的指针`)是指指向常量的指针，顾名思义，就是指针指向的是常量，即，它不能指向变量，它指向的内容不能被改变，不能通过指针来修改它指向的内容，但是指针自身不是常量，它自身的值可以改变，从而指向另一个常量。

**指针常量**(`指针是常量`)是指指针本身是常量。它指向的地址是不可改变的，但地址里的内容可以通过指针改变。有一点需要注意的是，指针常量在定义时必须同时赋初值。

## 指针的运算

**算数运算：**

+ 指针是存储的地址，地址本质就是一个整数，因此，我们可以对指针执行四种算术运算：++、--、+、-(其他运算没有意义)。

  ```c
  char* pc = NULL;
  printf("%p %p\n",pc,pc+1);	//0 1
  int* pi = NULL;
  printf("%p %p\n",pi,pi+1);	//0 4
  double* pd = NULL;
  printf("%p %p\n",pd,pd+1);	//0 8
  ```

+ 总结:
  + 指针的每一次递增，它其实会指向下一个元素的存储单元。
  + 指针的每一次递减，它都会指向前一个元素的存储单元。
  + 指针在递增和递减时跳跃的字节数(步长)取决于指针所指向变量数据类型长度，比如 int 就是 4 个字节
  + 不同类型的指针**所占内存大小都是一样**的(32位计算机4个字节，64位8个字节)

**关系运算：**

+ 指针可以用关系运算符进行比较，如 ==、< 和 >。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。

+ 总结：
  + 对相关变量的指针进行比较，才有意义
  + 大于小于常用在数组中，全等一般是判断指针是否为NULL

## 大、小端模式

+ 大端（Big-endian）和小端（Little-endian）是什么？
  + 在计算机业界，Endian表示数据在存储器中的存放顺序
+ **大端模式**：数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中
  + 这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这种存放方式符合人类的正常思维

+ **小端模式**：数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中
  + 这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。

![image-20210810165241531](assets/image-20210810165241531.png)

+ **总结**：采用大小模式对数据进行存放的主要区别在于在存放的字节顺序，大端方式将高位存放在低地址，小端方式将高位存放在高地址。采用大端方式进行数据存放符合人类的正常思维，而采用小端方式进行数据存放利于计算机处理。到目前为止，采用大端或者小端进行数据存放，其孰优孰劣也没有定论。