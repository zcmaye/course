# 字符串与指针

在各种编程语言中，字符串的地位都十分重要，C语言中并没有提供“字符串”这个特定类型，而是以特殊字符数组的形式来存储和处理字符串，这种字符数组必须以空字符’\0’结尾，因此，也将这种特定字符数组称为C风格字符串， 如何声明创建一个C风格字符串时，如何使用C风格字符串，这是本节课要学习的内容。

**存储字符串有两种形式：**

+ 字符数组形式：char str[20];
+ 字符指针形式：char* pc;

**区别：**

+ str是一个字符数组，字符串中的每个字符逐个存放，且可以随意修改
+ pc是一个字符指针，指向的是常量区的字符串，不能修改，只能访问

```cpp
char  str[20];     str=“I love China!”;    //(X) str是常量不能改变指向
char   *pc;        pc=“I love China!”;     //(√) pc是变量，可以改变指向
```

## 字符串输入

+ pc接受输入字符串时，必须先开辟内存空间

![image-20211127141247799](assets/image-20211127141247799.png)

![image-20211127141341869](assets/image-20211127141341869.png)

## 多个字符串输入

需要存储多个字符串时可以用二维数组或指针数组。

+ 二维数组：每个元素为一维数组的数组，叫二维数组。可以用个一维数组存储一个字符串。

  ```cpp
  char str[5][10];
  for (int i = 0; i < 5; i++)
  {
  	gets_s(str[i], 10);
  }
  for (int i = 0; i < 5; i++)
  {
  	puts(str[i]);
  }
  ```

+ 指针数组

  ```cpp
  char* str1[5];
  for (int i = 0; i < 5; i++)
  {
  	str1[i] = malloc(10);
  	gets_s(str1[i],10);
  }
  for (int i = 0; i < 5; i++)
  {
  	puts(str1[i]);
  	free(str1[i]);
  	str1[0] = NULL;
  }
  
  ```

  

## 字符串操作函数

C语言提供了丰富的字符串处理函数，大致可分为字符串的输入、输出、合并、修改、比较、转换、复制、搜索几类。 使用这些函数可大大减轻编程的负担。用于输入输出的字符串函数，在使用前应包含头文件"stdio.h"，使用其它字符串函数则应包含头文件"string.h"。

+ strlen 求字符串字面量长度
+ strcpy 字符串拷贝
+ strcat 字符串连接
+ strcmp 字符串比较

**自己用指针实现这些函数：**





# 如何看懂复杂的指针

指针大家都学过了，简单的指针相信大家都不放在眼里，就不再赘述，但是复杂的你能理解吗？能理解指针就学的差不多了，至于如何运用只要你看懂指针就知道应该给它赋什么值，怎么用。

+ 首先咱们一起来看看这个： `int (*fun)(int *p)`
  + 首先需要分析这个是不是一个指针，如果是，是什么指针？如果不是，那是什么？
  + 1. 根据(*fun)可知，fun是一个指针
    2. 然后看fun的后面是一个函数参数列表，可以确定是一个指向函数的指针
    3. 指向的函数的返回值是什么类型呢，再回头看看最前面发现是一个int
    4. 最后我们可以根据这个函数指针写出对应的函数

结果如下:

```c
int foo(int *p)
{
    reutrn 0;
}
```



## 右左法则

上面我们分析了一个函数指针，那结果是如何得出来的呢？全靠经验吗，NO，其实是有方法的。

这个方法叫做**右左法则**：

+ 右左法则不是C标准里面的内容，它是从C标准的声明规定中归纳出来的方法。C标准的声明规则，是用来解决如何创建声明的，而右左法则是用来解决如何辩识一个声明的。

+ 右左法则使用：
  + 1. 首先从最里面的圆括号(应该是标识符)看起，然后往右看，再往左看;
    2. 每当遇到圆括号时，就应该调转阅读方向；
    3. 一旦解析完圆括号里面所有东西，就跳出圆括号；
    4. 重复这个过程知道整个声明解析完毕。

![image-20220120153457760](assets/image-20220120153457760.png)

## 案例走起

#### 1.int (\*p[5])(int\*)

解析：

1. 从标识符p开始，p先与[]结合形成一个数组，然后与*结合，表示是一个指针数组；
2. 然后跳出这个圆括号，往后看，发现了一个函数的参数列表，说明数组里面装的是函数指针；
3. 在跳出圆括号，往前看返回类型，可以确定函数指针的类型。

#### 2. int (\*fun)(int \*p,int (\*pf)(int \*))

解析：

1. fun与*结合形成指针；
2. 往后看是一个参数列表，说明是一个函数指针，只不过参数里面还有一个函数指针；
3. 往前看可以确定函数指针的返回类型。

#### 3. int (\*(\*fun)[5])(int \*p)

解析：

1. fun与*结合，形成指针；
2. 往后看发现了一个[5]说明是一个指向数组的指针；
3. 再往前看，发现有一个*,说明数组里面存的是指针；
4. 跳出圆括号往后看，发现了参数列表，说明数组里面存的是函数指针；
5. 再往前看可以确定函数指针的返回类型。

![image-20220120185734595](assets/image-20220120185734595.png)

#### 4. int (\*(\*fun)(int \*p))[5]

解析：

1. fun与*结合，形成指针；

2. 往后看发现了参数列表，说明fun是一个函数指针；

3. 往前看遇到了*说明，函数指针的返回类型是一个指针，是什么指针继续往后解析；

4. 往后看发现了[5] 说明是一个数组指针，最前面一个int，说明fun这个函数指针的返回类型是一个数组的指针

   类型为int (*)[5]

   ![image-20220120185709724](assets/image-20220120185709724.png)

#### 5. int(\*(\*fun())())()

解析：

1. fun与()结合，说明fun是一个函数；
2. 往前看发现了一个*，说明函数返回类型为指针，什么指针呢？
3. 往后看发现了参数列表，fun函数返回的是一个函数指针，那这个函数指针的返回类型是什么呢？
4. 往前看又发现了一个*,说明函数指针返回类型也是一个指针，那这个指针是什么指针呢?
5. 往后看又发现了一个参数列表，说明是个函数指针，往前看这个函数指针返回的是int类型

![image-20220120185628198](assets/image-20220120185628198.png)

## 总结

实际当中，需要声明一个复杂指针时，如果把整个声明写成上面所示的形式，对程序可读性是一大损害。应该用typedef来对声明逐层分解，增强可读性



**指针变量有两种类型：**指针变量的类型和指针所指向的对象的类型

指针变量的类型
只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。

+ int\* ptr;	//指针的类型是int
+ char\* ptr;	//指针的类型是char
+ int\** ptr;	//指针的类型是int**
+ int(\*ptr)[3];	//指针的类型是int(*)[3]*

+ int\*(\*ptr)[4];	//指针的类型是int\*(\*)[4]

指针变量指向的对象的类型

+ 你只须把指针声明语句中的指针名字和名字左边的指针声明符\*去掉，剩下的就是指针所指向的类型。
  + int\*ptr; 	//指针所指向的类型是int
  + char\*ptr;	 //指针所指向的的类型是char
  + int\*\*ptr; 	//指针所指向的的类型是int\*
  + int(\*ptr)[3]; 	//指针所指向的的类型是int()[3]
  + int\*(\*ptr)[4]; 	//指针所指向的的类型是int\*()[4]



**注意事项:**

+ 指针变量也是变量，也有存储空间，存的是别的变量的地址。

  + 要注意指针的值，和指向的对象的值得区别

  + 普通变量中的内存空间存放的是，数值或字符等。 ----直接存取

  + 指针变量中的内存空间存放的是，另外一个普通变量的地址。----间接存取

    

+ 连续定义多个指针变量时，容易犯错误，比如：int *p,p1;只有p是指针变量，p1是整型变量

+ 避免使用为初始化的指针，很多运行错误都是由于这个原因导致的，而且这种错误又不能被编译器检查所以很难被发现，解决方法：初始化为NULL，报错就能很快找到原因

+ 指针赋值时一定要保证类型匹配，由于指针类型确定指针所指向对象的类型，操作指针是才能知道按什么类型去操作

+ 在用动态分配完内存之后一定要判断是否分配成功，分配成功后才能使用。

+ 在使用完之后一定要释放，释放后必须把指针置为NULL
