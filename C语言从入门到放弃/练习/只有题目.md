+ 传入一个三位数的正整数，看是否满足下列条件：1，是某一个数的平方，2，其中两位数字相同，如100,121

  

+ 把从键盘上输入的一个大于等于3的整数分解为质因子的成绩，如输入24时，输出结果为：2 2 2 3；输入50时，输出结果为：2 5 5；输入37时，输出结果为37

  

+ 用下列公式求cos(x)，x为角度的弧度值

  + 1，输入角度(0~360)或弧度(0~2π)时，均可计算出对应的三角函数cos(x)的值
  + 2，计算精度为：最后一项的绝对值小于10^-6

​	![image-20210910143657892](E:\GitHub\course\C语言从入门到放弃\练习\assets/image-20210910143657892.png)



+ 反序数的定义：从左向右读的的数的反序数为从右向左读得到的数；如123的反序数为321，平方镜反数的定义：一个数的平方和它的反序数的平方互为反序数，如：12是平方反镜数，因为12^2=144，21^2=441

  + 编写一个程序，输出所有二位数的平方镜反数（ps:个位数不能为0哦）

  

+ 求出指定范围内的所有素数(只能被1和自身整除的数)

  + （1），定义函数int isPrime(int num);改函数用于判断num是否为素数，是素数返回true，不是返回false
  + （2），在主函数中输入指定范围，按每行五个的格式，输出指定范围内的素数和个数

  

+ 495数学黑洞：任何一个数字都不相同的三位数，经过有限次“重排求差”操作，总会得495。“重排求差”操作:是将一个数的各位数字重排得到最大数减去最小数。请编程进行验证。

  ​		**如：**数107，“重排求差”操作序列为：710-17=693，963-369=594，954-459=495

  + （1），定义函数void digitn(int num,int *max,int *min);max为对num重排后得到的最大数，min为对num重排后得到的最小数
  + （2），主函数中，输入一个整数，输出每次处理后得到的新数

  

  

+ 哥德巴赫猜想之一是，任何一个不小于6的偶数都可以表示为两个素数之和,例如，6=3+3，8=3+5，10=3+7等，试写一个函数，验证6~100之间的所有偶数。具体要求如下:

  

  

+ 小明正看着203879这个数字发呆。原来，203879 * 203879 =41566646641这有什么神奇呢?仔细观察，203879是个6位数，并且它的每个数位上的数字都是不同的，并且它平方后的所有数位上都不出现组成它自身的数字。具有这样特点的6位数还有一个，请你找出它!再归纳一下筛选要求:

  + 1.6位正整数
  + 2.每个数位上的数字不同
  + 3.其平方数的每个数位不含原数字的任何组成数位

  