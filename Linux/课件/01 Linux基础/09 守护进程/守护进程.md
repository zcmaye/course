# 守护进程

守护进程（Daemon Process）是在操作系统后台运行的特殊进程，通常独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。一般采用以d结尾的名字，如vsftpd、sshd等。

## 主要特点

1. **长期运行**：通常在系统启动时运行，直到系统关闭
2. **无控制终端**：不与任何用户交互
3. **独立于用户会话**：即使用户注销也继续运行
4. **通常以root权限运行**：执行系统级任务

## 常见守护进程

- **系统服务**：sshd(SSH服务)、httpd(Web服务)、crond(定时任务)
- **系统管理**：syslogd(系统日志)、cupsd(打印服务)
- **网络服务**：mysqld(数据库)、ntpd(时间同步)



# systemd

在Linux中，**Systemd** 是一个系统和服务管理器，它为现代Linux操作系统提供了一种统一的方式来管理和启动守护进程。

Systemd 的优点是功能强大，使用方便，缺点是体系庞大，非常复杂。事实上，现在还有很多人反对使用 Systemd，理由就是它过于复杂，与操作系统的其他部分强耦合，违反"keep simple, keep stupid"的Unix 哲学。

![img](./assets/bg2016030703.png)

## 系统管理

Systemd 并不是一个命令，而是一组命令，涉及到系统管理的方方面面。

### 3.1 systemctl

`systemctl`是 Systemd 的主命令，用于管理系统。

```bash
# 重启系统
$ sudo systemctl reboot

# 关闭系统，切断电源
$ sudo systemctl poweroff

# CPU停止工作
$ sudo systemctl halt

# 暂停系统
$ sudo systemctl suspend

# 让系统进入冬眠状态
$ sudo systemctl hibernate

# 让系统进入交互式休眠状态
$ sudo systemctl hybrid-sleep

# 启动进入救援状态（单用户状态）
$ sudo systemctl rescue
```

### 3.2 systemd-analyze

`systemd-analyze`命令用于查看启动耗时。

```bash
# 查看启动耗时
$ systemd-analyze                                                                                       

# 查看每个服务的启动耗时
$ systemd-analyze blame

# 显示瀑布状的启动过程流
$ systemd-analyze critical-chain

# 显示指定服务的启动流
$ systemd-analyze critical-chain atd.service
```

### 3.3 hostnamectl

`hostnamectl`命令用于查看当前主机的信息。

```bash
# 显示当前主机的信息
$ hostnamectl

# 设置主机名。
$ sudo hostnamectl set-hostname rhel7
```

### 3.4 localectl

`localectl`命令用于查看本地化设置。

```bash
# 查看本地化设置
$ localectl

# 设置本地化参数。
$ sudo localectl set-locale LANG=en_GB.utf8
$ sudo localectl set-keymap en_GB
```

### 3.5 timedatectl

`timedatectl`命令用于查看当前时区设置。

```bash
# 查看当前时区设置
$ timedatectl

# 显示所有可用的时区
$ timedatectl list-timezones                                                                                   

# 设置当前时区
$ sudo timedatectl set-timezone America/New_York
$ sudo timedatectl set-time YYYY-MM-DD
$ sudo timedatectl set-time HH:MM:SS
```

### 3.6 loginctl

`loginctl`命令用于查看当前登录的用户。

```bash
# 列出当前session
$ loginctl list-sessions

# 列出当前登录用户
$ loginctl list-users

# 列出显示指定用户的信息
$ loginctl show-user ruanyf
```

## Unit

### 含义

Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。

Unit 一共分成12种。

- Service unit：系统服务
- Target unit：多个 Unit 构成的一个组
- Device Unit：硬件设备
- Mount Unit：文件系统的挂载点
- Automount Unit：自动挂载点
- Path Unit：文件或路径
- Scope Unit：不是由 Systemd 启动的外部进程
- Slice Unit：进程组
- Snapshot Unit：Systemd 快照，可以切回某个快照
- Socket Unit：进程间通信的 socket
- Swap Unit：swap 文件
- Timer Unit：定时器

`systemctl list-units`命令可以查看当前系统的所有 Unit 。

```bash
# 列出正在运行的 Unit
$ systemctl list-units

# 列出所有Unit，包括没有找到配置文件的或者启动失败的
$ systemctl list-units --all

# 列出所有没有运行的 Unit
$ systemctl list-units --all --state=inactive

# 列出所有加载失败的 Unit
$ systemctl list-units --failed

# 列出所有正在运行的、类型为 service 的 Unit
$ systemctl list-units --type=service
```

### Unit 的状态

`systemctl status`命令用于查看系统状态和单个 Unit 的状态。

```bash
# 显示系统状态
$ systemctl status

# 显示单个 Unit 的状态
$ sysystemctl status bluetooth.service

# 显示远程主机的某个 Unit 的状态
$ systemctl -H root@www.hdy.com status ssh.service
```

当使用`systemctl status`查看系统状态时，如果状态是`degraded`，通常意味着系统的某些服务或组件未能正常启动或运行，但系统仍可基本运作（非完全崩溃）。

```bash
● maye-ubuntu-pc
    State: degraded
    Units: 558 loaded (incl. loaded aliases)
```

可以使用`systemctl --failed`查看启动失败的单元。

使用`systemctl reset-failed`命令重置状态（**不会影响实际运行的服务**：`reset-failed` 仅清除状态标记，不会停止、重启或修改任何服务。）

除了`status`命令，`systemctl`还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。

```bash
# 显示某个 Unit 是否正在运行
$ systemctl is-active application.service

# 显示某个 Unit 是否处于启动失败状态
$ systemctl is-failed application.service

# 显示某个 Unit 服务是否建立了启动链接
$ systemctl is-enabled application.service
```

### Unit 管理

对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。

```bash
# 立即启动一个服务
$ sudo systemctl start ssh.service

# 立即停止一个服务(有时候，该命令可能没有响应，服务停不下来,要使用systemctl kill)
$ sudo systemctl stop ssh.service

# 重启一个服务
$ sudo systemctl restart ssh.service

# 杀死一个服务的所有子进程
$ sudo systemctl kill ssh.service

# 重新加载一个服务的配置文件
$ sudo systemctl reload ssh.service

# 重载所有修改过的配置文件
$ sudo systemctl daemon-reload

# 显示某个 Unit 的所有底层参数
$ systemctl show ssh.service

# 显示某个 Unit 的指定属性的值
$ systemctl show -p CanStop ssh.service

# 设置某个 Unit 的指定属性
$ sudo systemctl set-property ssh.service UMask=0002
```

`systemctl status ssh`能查看ssh服务的状态，下面是状态详情：

```sh
 nginx.service - A high performance web server and a reverse proxy server
     Loaded: loaded (/usr/lib/systemd/system/nginx.service; enabled; preset: enabled)
     Active: active (running) since Mon 2025-08-18 16:26:29 CST; 2min 26s ago
       Docs: man:nginx(8)
    Process: 10493 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited, status=0/SUCCESS)
    Process: 10500 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0/SUCCESS)
   Main PID: 10532 (nginx)
      Tasks: 3 (limit: 4545)
     Memory: 2.4M (peak: 5.3M)
        CPU: 20ms
     CGroup: /system.slice/nginx.service
             ├─10532 "nginx: master process /usr/sbin/nginx -g daemon on; master_process on;"
             ├─10534 "nginx: worker process"
             └─10535 "nginx: worker process"
```

各部分代表的具体含义请参见[附录-服务状态详情](#服务状态详情)。

### 依赖关系

Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。

`systemctl list-dependencies`命令列出一个 Unit 的所有依赖。

```bash
$ systemctl list-dependencies ssh.service
```

上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用`--all`参数。

```bash
$ systemctl list-dependencies --all ssh.service
```

## Unit 的配置文件

### 概述

每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。

Systemd 默认从目录`/etc/systemd/system/`读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录`/usr/lib/systemd/system/`，真正的配置文件存放在那个目录。

比如，ssh服务符号链接如下：

```css
sshd.service -> /usr/lib/systemd/system/ssh.service
```

`systemctl enable`命令用于在上面两个目录之间，建立符号链接关系。也就是说只有在`/etc/systemd/system`目录中的Unit才会开机自启！

如果使用`sudo systemctl disable ssh `命令，取消开机自启，则符号链接会自动删除。

配置文件的后缀名，就是该 Unit 的种类，比如`sshd.socket`。如果省略，Systemd 默认后缀名为`.service`，所以`sshd`会被理解成`sshd.service`。

### 配置文件状态

`systemctl list-unit-files`命令用于列出所有配置文件。

```bash
# 列出所有配置文件
$ systemctl list-unit-files

# 列出指定类型的配置文件
$ systemctl list-unit-files --type=service
```

这个命令会输出一个列表。

```css
UNIT FILE                                      STATE           PRESET  
brltty-udev.service                            static          -       
brltty.service                                 disabled        enabled 
cloud-config.service                           enabled         enabled 
cryptdisks.service                             masked          enabled 
```

这个列表显示每个配置文件的状态，一共有四种。

- enabled：已建立启动链接
- disabled：没建立启动链接
- static：该配置文件没有`[Install]`部分（无法执行），只能作为其他配置文件的依赖
- masked：该配置文件被禁止建立启动链接

注意，从配置文件的状态无法看出，该 Unit 是否正在运行。这必须执行前面提到的`systemctl status`命令。

一旦修改配置文件，就要让 Systemd 重新加载配置文件，然后重新启动（也有可能不需要重启），否则修改不会生效。

```bash
$ sudo systemctl daemon-reload
$ sudo systemctl restart httpd.service
```

### 配置文件格式

配置文件就是普通的文本文件，可以用文本编辑器打开。

#### 查看配置文件

`systemctl cat`命令可以查看配置文件的内容。

```bash
$ systemctl cat ssh

# /usr/lib/systemd/system/ssh.service
[Unit]
Description=OpenBSD Secure Shell server - maye
Documentation=man:sshd(8) man:sshd_config(5)
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStartPre=/usr/sbin/sshd -t
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/usr/sbin/sshd -t
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartPreventExitStatus=255
Type=notify
RuntimeDirectory=sshd
RuntimeDirectoryMode=0755

[Install]
WantedBy=multi-user.target
Alias=sshd.service
```

从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如`[Unit]`。注意，配置文件的区块名和字段名，都是大小写敏感的。

每个区块内部是一些等号连接的键值对。

> 注意，键值对的等号两侧不能有空格。

#### 三个区块

`[Unit]`区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。

> - `Description`：简短描述
> - `Documentation`：文档地址
> - `Requires`：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败
> - `Wants`：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败
> - `BindsTo`：与`Requires`类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行
> - `Before`：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动
> - `After`：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动
> - `Conflicts`：这里指定的 Unit 不能与当前 Unit 同时运行
> - `Condition...`：当前 Unit 运行必须满足的条件，否则不会运行
> - `Assert...`：当前 Unit 运行必须满足的条件，否则会报启动失败

`[Install]`通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。

> - `WantedBy`：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入`/etc/systemd/system`目录下面以 Target 名 + `.wants`后缀构成的子目录中
> - `RequiredBy`：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入`/etc/systemd/system`目录下面以 Target 名 + `.required`后缀构成的子目录中
> - `Alias`：当前 Unit 可用于启动的别名
> - `Also`：当前 Unit 激活（enable）时，会被同时激活的其他 Unit

`[Service]`区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。

> - `Type`：定义启动时的进程行为。它有以下几种值。
> - `Type=simple`：默认值，执行`ExecStart`指定的命令，启动主进程
> - `Type=forking`：以 fork 方式从父进程创建子进程，创建后父进程会立即退出
> - `Type=oneshot`：一次性进程，Systemd 会等当前服务退出，再继续往下执行
> - `Type=dbus`：当前服务通过D-Bus启动
> - `Type=notify`：当前服务启动完毕，会通知`Systemd`，再继续往下执行
> - `Type=idle`：若有其他任务执行完毕，当前服务才会运行
> - `ExecStart`：启动当前服务的命令
> - `ExecStartPre`：启动当前服务之前执行的命令
> - `ExecStartPost`：启动当前服务之后执行的命令
> - `ExecReload`：重启当前服务时执行的命令
> - `ExecStop`：停止当前服务时执行的命令
> - `ExecStopPost`：停止当其服务之后执行的命令
> - `RestartSec`：自动重启当前服务间隔的秒数
> - `Restart`：定义何种情况 Systemd 会自动重启当前服务，可能的值包括`always`（总是重启）、`on-success`、`on-failure`、`on-abnormal`、`on-abort`、`on-watchdog`
> - `TimeoutSec`：定义 Systemd 停止当前服务之前等待的秒数
> - `Environment`：指定环境变量

Unit 配置文件的完整字段清单，请参考[官方文档](https://www.freedesktop.org/software/systemd/man/systemd.unit.html)。

## Target

启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。

简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于"状态点"，启动某个 Target 就好比启动到某种状态。

```bash
# 查看当前系统的所有 Target
$ systemctl list-unit-files --type=target

# 查看一个 Target 包含的所有 Unit
$ systemctl list-dependencies multi-user.target

# 查看启动时的默认 Target
$ systemctl get-default

# 设置启动时的默认 Target
$ sudo systemctl set-default multi-user.target

# 切换 Target 时，默认不关闭前一个 Target 启动的进程，
# systemctl isolate 命令改变这种行为，
# 关闭前一个 Target 里面所有不属于后一个 Target 的进程
$ sudo systemctl isolate multi-user.target
```

## 日志管理

Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用`journalctl`一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是`/etc/systemd/journald.conf`。

- **日志存储位置**：
  Systemd 日志默认由 `journald` 管理，二进制文件存储在 `/var/log/journal/`。
- **传统日志文件**：
  Nginx 仍会输出日志到 `/var/log/nginx/error.log` 和 `access.log`（与 `journalctl` 互补）。

`journalctl`功能强大，用法非常多。

```bash
# 查看所有日志（默认情况下 ，只保存本次启动的日志）
$ sudo journalctl

# 查看内核日志（不显示应用日志）
$ sudo journalctl -k

# 查看系统本次启动的日志
$ sudo journalctl -b
$ sudo journalctl -b -0

# 查看上一次启动的日志（需更改设置）
$ sudo journalctl -b -1

# 查看指定时间的日志
$ sudo journalctl --since="2012-10-30 18:17:16"
$ sudo journalctl --since "20 min ago"
$ sudo journalctl --since yesterday
$ sudo journalctl --since "2015-01-10" --until "2015-01-11 03:00"
$ sudo journalctl --since 09:00 --until "1 hour ago"

# 显示尾部的最新10行日志
$ sudo journalctl -n

# 显示尾部指定行数的日志
$ sudo journalctl -n 20

# 实时滚动显示最新日志
$ sudo journalctl -f

# 查看指定服务的日志
$ sudo journalctl /usr/lib/systemd/systemd

# 查看指定进程的日志
$ sudo journalctl _PID=1

# 查看某个路径的脚本的日志
$ sudo journalctl /usr/bin/bash

# 查看指定用户的日志
$ sudo journalctl _UID=33 --since today

# 查看某个 Unit 的日志
$ sudo journalctl -u nginx.service
$ sudo journalctl -u nginx.service --since today

# 实时滚动显示某个 Unit 的最新日志
$ sudo journalctl -u nginx.service -f

# 合并显示多个 Unit 的日志
$ journalctl -u nginx.service -u php-fpm.service --since today

# 查看指定优先级（及其以上级别）的日志，共有8级
# 0: emerg
# 1: alert
# 2: crit
# 3: err
# 4: warning
# 5: notice
# 6: info
# 7: debug
$ sudo journalctl -p err -b

# 日志默认分页输出，--no-pager 改为正常的标准输出
$ sudo journalctl --no-pager

# 以 JSON 格式（单行）输出
$ sudo journalctl -b -u nginx.service -o json

# 以 JSON 格式（多行）输出，可读性更好
$ sudo journalctl -b -u nginx.serviceqq
 -o json-pretty

# 显示日志占据的硬盘空间
$ sudo journalctl --disk-usage

# 指定日志文件占据的最大空间
$ sudo journalctl --vacuum-size=1G

# 保留日志文件个数
$ sudo journalctl --vacuum-files=1

# 指定日志文件保存多久
$ sudo journalctl --vacuum-time=1years

# 清理文件后检查日志文件的完整性。该命令显示日志文件的 PASS、FAIL。
$ journalctl --verify

# 刷新和轮换日志文件。轮换是将当前活动日志文件标记为存档并从此时开始创建新日志文件的一种方法。
$ journalctl --flush --rotate
```

## 自定义systemd服务

创建和管理自定义 `systemd` 服务是 Linux 系统管理中的一项重要技能。以下是创建和管理自定义 `systemd` 服务的详细步骤。

### 程序

先准备一个程序，然后让我们的程序能通过systemd去管理！

```c
#include <stdio.h>
#include <fcntl.h>
#include <unistd.h>

int main(){
        int fd = open("hdy.log",O_WRONLY | O_CREAT,0664);
        if(fd == -1){
                perror("open error");
                return -1;
        }

        char buf[BUFSIZ];
        int counter = 0;
        while(1){
                int len = sprintf(buf,"%d Hello!I'm hdy test pro!\n",counter++);
                write(fd,buf,len);                      //写入到文件中
                write(STDOUT_FILENO,buf,len);           //写入到标准输出中
                sleep(1);
        }

        close(fd);
        return 0;
}
```

### 服务单元文件

**创建单元文件**

使用文本编辑器创建一个新的服务单元文件。命名为 `hdy.service`。

> 注意：单元文件要放到`/usr/lib/systemd/system/hdy.service`位置！



**编写单元文件**

```ini
[Unit]
Description=hdy test

[Service]
ExecStart=/home/maye/course/day10/hdy
WorkingDirectory=/home/maye
Restart=on-failure
RestartPreventExitStatus=-1		#程序返回-1时不重启

[Install]
WantedBy=multi-user.target
Alias=hdyd.service
```



**重新加载配置**

在创建或修改单元文件后，需要重新加载 `systemd` 配置，以使更改生效。

```bash
sudo systemctl daemon-reload
```

### 启动和管理服务

+ 先开启hdy服务

```bash
sudo systemctl start hdy
```

+ 然后查看一下hdy服务的状态

```bash
sudo systemctl status hdy
```

状态输出如下:

```css
● hdy.service - hdy test
     Loaded: loaded (/usr/lib/systemd/system/hdy.service; disabled; preset: enabled)
     Active: active (running) since Tue 2025-08-19 16:53:53 CST; 4s ago
   Main PID: 8117 (hdy)
      Tasks: 1 (limit: 4545)
     Memory: 160.0K (peak: 704.0K)
        CPU: 2ms
     CGroup: /system.slice/hdy.service
             └─8117 /home/maye/course/day10/hdy
```

### 查看日志

在我们的程序中，分别向文件和标准输出中写入了日志，我们来查看一下日志！

#### 文件日志

我们自己创建的日志文件在`/home/maye/hdy.log`中，直接使用`tail -f /home/maye/hdy.log`就可以查看实时日志了！

```bash
maye@maye-ubuntu-pc:~$ tail -f /home/maye/hdy.log

238 Hello!I'm hdy test pro!
239 Hello!I'm hdy test pro!
240 Hello!I'm hdy test pro!
241 Hello!I'm hdy test pro!
242 Hello!I'm hdy test pro!
243 Hello!I'm hdy test pro!
244 Hello!I'm hdy test pro!
245 Hello!I'm hdy test pro!
246 Hello!I'm hdy test pro!
```

#### systemd日志

那么我们向标准输出中写入的日志，输出到哪里了呢？答案是systemd的日志中，使用journalctl命令即可查看！

```bash
maye@maye-ubuntu-pc:~$ sudo journalctl -u hdy

8月 19 16:31:36 maye-ubuntu-pc systemd[1]: /usr/lib/systemd/system/hdy.service:8: Failed to par>8月 19 16:31:36 maye-ubuntu-pc systemd[1]: Started hdy.service - hdy test.
8月 19 16:31:36 maye-ubuntu-pc hdy[7704]: 0 Hello!I'm hdy test pro!
8月 19 16:31:37 maye-ubuntu-pc hdy[7704]: 1 Hello!I'm hdy test pro!
8月 19 16:31:38 maye-ubuntu-pc hdy[7704]: 2 Hello!I'm hdy test pro!
8月 19 16:31:39 maye-ubuntu-pc hdy[7704]: 3 Hello!I'm hdy test pro!
```

如果想要滚动查看实时日志，则需要使用如下命令：

```bash
sudo journalctl -u hdy -f

8月 19 17:01:28 maye-ubuntu-pc hdy[8117]: 455 Hello!I'm hdy test pro!
8月 19 17:01:29 maye-ubuntu-pc hdy[8117]: 456 Hello!I'm hdy test pro!
8月 19 17:01:30 maye-ubuntu-pc hdy[8117]: 457 Hello!I'm hdy test pro!
8月 19 17:01:31 maye-ubuntu-pc hdy[8117]: 458 Hello!I'm hdy test pro!
```

#### 日志文件位置

systemd-journald二进制日志文件，存储在`/var/log/journal`目录中！主要有如下两个日志文件：

##### system.journal(系统日志)

此日志文件中存储的是系统级别日志（所有系统服务、内核、后台进程的日志），影响整个系统的日志信息。

**日志来源：**

- 系统服务（如 `sshd`、`nginx`、`docker`）
- 内核消息（`kern` 级别）
- 系统守护进程（如 `cron`、`systemd` 自身）
- 所有用户的登录/认证日志

**文件位置：**

```bash
/var/log/journal/<machine-id>/system.journal
# 或
/var/log/journal/<machine-id>/system@*.journal  # 归档文件
```

**查看方法：**

```bash
# 查看整个系统日志
sudo journalctl -f                  # 实时跟踪
sudo journalctl -b                  # 本次启动的日志
sudo journalctl -u nginx.service    # 查看特定服务日志
```

##### user-x.journal(系统日志)

此日志文件中存储的是用户级别日志（特定用户（UID=1000）的桌面环境、用户应用程序日志），仅影响该用户会话的日志信息。

**日志来源：**

- 桌面环境（GNOME、KDE、X11/Wayland）
- 用户启动的图形应用程序
- 用户 session 的服务（如 `systemd --user` 管理的服务）
- 用户级别的 systemd 单元

**查看方法：**

```bash
# 查看用户日志（需要权限）
sudo journalctl --user-unit=app-name  # 查看用户单元
sudo journalctl _UID=1000             # 查看UID=1000的用户日志(使用id命令查看当前用户id)

# 以对应用户身份查看
sudo -u <username> journalctl --user
```

# 守护进程编程

下面介绍如何在Linux下用C语言编写守护进程。

## 创建守护进程的步骤

+ **创建子进程**

首先通过 *fork()* 创建一个子进程，然后**父进程退出**。这样可以使子进程在后台运行，并且父进程退出后，子进程会被 *init* 进程接管，成为孤儿进程。

```c
pid_t pid = fork();
if (pid < 0) {
    exit(1);
}
if (pid > 0) {  // 父进程退出
    exit(0);
}
```

+ **在子进程中创建新会话**

在子进程中调用 *setsid()* 创建一个新的会话，使其成为会话组长和进程组长，并脱离控制终端。

```c
if (setsid() < 0) {
    exit(1);
}
```

+ **改变工作目录**

将工作目录更改为根目录，以避免占用可能无法卸载的文件系统。

```c
chdir("/");
```

+ **重设文件权限掩码**

将文件权限掩码设置为0，以确保守护进程创建的文件具有预期的权限。

```c
umask(0);
```

+ **关闭文件描述符**

关闭从父进程继承的所有打开的文件描述符，以释放资源。

```c
for (int x = 0; x < sysconf(_SC_OPEN_MAX); x++) {
    close(x);
}
```

## 示例代码

编写一个守护进程，每隔2S钟获取一次系统时间，并将这个时间写入磁盘文件。

**分析：**

+ 首先要按照1.3介绍的守护进行的步骤创建一个守护进程，

+ 每隔2S钟：使用setitimer函数设置时钟，该时钟发送的是SIGALRM信号，

+ 信号操作：注册信号处理函数,signal或者sigaction,还有一个信号处理函数

+ 获取一次系统时间：time函数的使用，ctime函数的使用

+ 写入磁盘文件：文件操作函数：open、write、close

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <time.h>
#include <string.h>
#include <sys/time.h>
#include <sys/stat.h>
#include <signal.h>

int fd = -1;

void handler(int signum)
{
        time_t _time =  time(NULL);
        const char* str = ctime(&_time);
        write(fd,str,strlen(str));
}

void quit(int signum) {
        write(fd,"daemon quit",strlen("daemon quit"));
        close(fd);
}

void daemonize() {
        //创建子进程
        pid_t pid = fork();
        if(pid == -1){
                exit(1);
        }
        //父进程退出
        if(pid>0){
                exit(0);
        }
        //改变工作目录
        chdir("/");

        //重设文件权限掩码
        umask(0);

        //关闭文件描述符
        close(STDIN_FILENO);
        close(STDOUT_FILENO);
        close(STDERR_FILENO);
}


int main()
{
        daemonize();

        //守护进程逻辑
        struct sigaction sig={0};
        sig.sa_handler = handler;
        sigemptyset(&sig.sa_mask);
        sigaction(SIGALRM,&sig,NULL);
        //-- SIGTERM信号杀死程序
        {
                struct sigaction sig={0};
                sig.sa_handler = quit;
                sigemptyset(&sig.sa_mask);
                sigaddset(&sig.sa_mask,SIGALRM);
                sigaction(SIGTERM,&sig,NULL);
        }

        struct itimerval val={0};
        val.it_value.tv_sec = 3;
        val.it_interval.tv_sec = 1;
        setitimer(ITIMER_REAL,&val,NULL);

        //打开文件
        fd = open("daemon.log",O_WRONLY | O_CREAT,0664);
        if(fd==-1){
                exit(1);
        }

        while(1) {
                sleep(1);
        }

        return 0;
}
```

## 注意

+ 必须使用root启动守护进程

```bash
sudo ./daemon
```



# 将进程后台运行方法

对于C/C++编写的服务器程序，选择后台运行方式取决于您的具体需求和场景。以下是详细的解决方案分析：

## 1. 选择方案比较

| 方案                | 适用场景                       | 是否需要修改代码 | 管理便利性 |
| ------------------- | ------------------------------ | ---------------- | ---------- |
| nohup               | 临时测试/简单部署              | 不需要           | 低         |
| 系统服务(如systemd) | 生产环境长期服务               | 通常不需要       | 高         |
| 代码实现守护进程    | 需要完全控制进程行为的专业应用 | 需要             | 中         |

## 2. 推荐方案及具体实现

### 方案一：使用nohup（最简单）

**适用场景**：快速测试或简单部署

```bash
nohup ./your_web_server > server.log &
```

**优点**：

- 无需修改代码
- 简单快捷

**缺点**：

- 不适合生产环境
- 缺乏完善的进程管理

### 方案二：系统服务（推荐生产环境使用）

**使用systemd创建服务**：

1. 创建服务文件 `/etc/systemd/system/web-server.service`：

```ini
[Unit]
Description=My C++ Web Server
After=network.target

[Service]
Type=simple
ExecStart=/path/to/your_web_server
WorkingDirectory=/path/to/working_dir
Restart=always
User=www-data
Group=www-data

[Install]
WantedBy=multi-user.target
```

2. 启用并启动服务：

```bash
sudo systemctl daemon-reload
sudo systemctl enable web-server
sudo systemctl start web-server
```

**优点**：

- 专业的生产级解决方案
- 自动重启、日志管理完善
- 无需修改原有代码

### 方案三：修改代码实现守护进程

**适用场景**：需要精细控制进程行为的专业应用

在您的Web服务器代码中添加守护进程化逻辑：

```cpp
#include <unistd.h>
#include <sys/stat.h>
#include <fstream>

void daemonize() {
    // 第一次fork
    pid_t pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS); // 父进程退出
    
    // 创建新会话
    if (setsid() < 0) exit(EXIT_FAILURE);
    
    // 第二次fork（可选，防止获取终端控制）
    pid = fork();
    if (pid < 0) exit(EXIT_FAILURE);
    if (pid > 0) exit(EXIT_SUCCESS);
    
    // 设置工作目录
    chdir("/");
    
    // 重设文件权限掩码
    umask(0);
    
    // 关闭标准文件描述符
    close(STDIN_FILENO);
    close(STDOUT_FILENO);
    close(STDERR_FILENO);
    
    // 重定向到日志文件（可选）
    std::freopen("/var/log/web_server.log", "a", stdout);
    std::freopen("/var/log/web_server.err", "a", stderr);
}

int main() {
    daemonize();
    
    // 您的Web服务器主逻辑
    start_web_server();
    
    return 0;
}
```

**优点**：

- 完全控制进程行为
- 不依赖外部工具

**缺点**：

- 需要修改代码
- 需要自行处理日志轮转等系统管理功能

### 方案四：使用包装脚本

如果不希望修改代码，可以创建一个包装脚本实现守护进程化：

```bash
#!/bin/bash

# 守护进程化
function daemonize() {
    umask 0
    cd /
    setsid "$@" &
    disown %1
}

# 启动Web服务器
daemonize /path/to/your_web_server
```

然后运行：

```bash
chmod +x wrapper.sh
./wrapper.sh > t.log
```

## 3. 生产环境最佳实践建议

1. **推荐组合方案**：

   - 保持Web服务器代码不变（作为普通前台程序）
   - 使用systemd管理进程
   - 在程序中实现良好的日志系统

2. **日志处理建议**：

   - 使用syslog或专业的日志库

   - 避免直接写文件，除非实现日志轮转

   - 示例代码：

     ```cpp
     #include <syslog.h>
     
     int main() {
         openlog("web_server", LOG_PID, LOG_DAEMON);
         syslog(LOG_INFO, "Server started");
         // ...
         closelog();
     }
     ```

3. **安全建议**：

   - 不要以root身份运行
   - 使用chroot等沙盒技术（如需要）
   - 实现适当的资源限制

## 4. 各方案选择指南

- **开发测试阶段**：使用`nohup`或`screen/tmux`方便调试
- **生产环境**：使用systemd服务
- **需要特殊控制**：修改代码实现守护进程
- **快速部署**：使用包装脚本

选择哪种方案主要取决于您的运维需求和程序的使用场景。对于大多数Web服务器应用，使用systemd管理是最专业和可靠的方式。

# 附录

## 服务状态详情

### 1. 服务基本信息

```css
 nginx.service - A high performance web server and a reverse proxy server
```

服务单元名称（`nginx.service`）和简短描述。

### 2. 服务加载状态

```css
Loaded: loaded (/usr/lib/systemd/system/nginx.service; enabled; preset: enabled)
```

- **`loaded`**：服务配置文件已加载。
- **路径**：`/usr/lib/systemd/system/nginx.service`（Systemd 单元文件位置）。
- **`enabled`**：服务已设置为开机自启。
- **`preset: enabled`**：默认策略为启用（可能由发行版预设）。

### 3. 服务运行状态

```css
Active: active (running) since Mon 2025-08-18 16:26:29 CST; 2min 26s ago
```

- **`active (running)`**：服务正在运行。
- **启动时间**：`2025-08-18 16:26:29 CST`（时间可能因时区不同）。
- **运行时长**：`2min 26s`（服务已持续运行的时间）。

### 4. 文档信息

```css
Docs: man:nginx(8)
```

可通过 `man 8 nginx` 命令查看 Nginx 的手册文档。

### 5. 启动进程记录

```css
Process: 10493 ExecStartPre=/usr/sbin/nginx -t -q -g daemon on; master_process on; (code=exited, status=0/SUCCESS)
Process: 10500 ExecStart=/usr/sbin/nginx -g daemon on; master_process on; (code=exited, status=0/SUCCESS)
```

- **`ExecStartPre`**：服务启动前执行的命令（此处是 `nginx -t -q` 测试配置文件语法）。
  - **`code=exited, status=0/SUCCESS`**：命令成功执行（状态码 0）。
- **`ExecStart`**：实际启动 Nginx 的命令。
  - **参数说明**：
    - `-g daemon on`：以守护进程模式运行。
    - `-g master_process on`：启用主进程管理模式。

### 6. 主进程信息

```css
   Main PID: 10532 (nginx)
```

- **`Main PID`**：Nginx 主进程的 PID（进程 ID）为 `10532`。
- **括号内容**：进程对应的命令名称（`nginx`）。

### 7. 资源使用情况

```css
      Tasks: 3 (limit: 4545)
     Memory: 2.4M (peak: 5.3M)
        CPU: 20ms
```

- **`Tasks`**：当前服务共运行 3 个子进程（1 个 master + 2 个 worker），系统限制为 4545 个进程。
- **`Memory`**：当前内存占用 2.4MB，峰值占用 5.3MB。
- **`CPU`**：累计占用 CPU 时间 20 毫秒。

### 8. CGroup 进程树

```css
 CGroup: /system.slice/nginx.service
         ├─10532 "nginx: master process /usr/sbin/nginx -g daemon on; master_process on;"
         ├─10534 "nginx: worker process"
         └─10535 "nginx: worker process"
```

- **`CGroup`**：Linux 控制组（用于资源隔离）。

- **进程树结构**：

  - **`10532`**：Nginx 主进程（Master Process），负责管理 worker 进程。
  - **`10534` 和 `10535`**：两个工作进程（Worker Process），实际处理请求。


## 读懂配置文件

一个服务怎么启动，完全由它的配置文件决定。下面就来看，配置文件有些什么内容。

前面说过，配置文件主要放在`/usr/lib/systemd/system`目录，也可能在`/etc/systemd/system`目录。找到配置文件以后，使用文本编辑器打开即可。

`systemctl cat`命令可以用来查看配置文件，下面以`sshd.service`文件为例，它的作用是启动一个 SSH 服务器，供其他用户以 SSH 方式登录。

```bash
# /usr/lib/systemd/system/ssh.service
[Unit]
Description=OpenBSD Secure Shell server - maye
Documentation=man:sshd(8) man:sshd_config(5)
After=network.target auditd.service
ConditionPathExists=!/etc/ssh/sshd_not_to_be_run

[Service]
EnvironmentFile=-/etc/default/ssh
ExecStartPre=/usr/sbin/sshd -t
ExecStart=/usr/sbin/sshd -D $SSHD_OPTS
ExecReload=/usr/sbin/sshd -t
ExecReload=/bin/kill -HUP $MAINPID
KillMode=process
Restart=on-failure
RestartPreventExitStatus=255
Type=notify
RuntimeDirectory=sshd
RuntimeDirectoryMode=0755

[Install]
WantedBy=multi-user.target
Alias=sshd.service
```

可以看到，配置文件分成几个区块，每个区块包含若干条键值对。

下面依次解释每个区块的内容。

###  [Unit] 区块：启动顺序与依赖关系。

`Unit`区块的`Description`字段给出当前服务的简单描述，`Documentation`字段给出文档位置。

接下来的设置是启动顺序和依赖关系，这个比较重要。

> `After`字段：表示如果`network.target`或`auditd.service`需要启动，那么`sshd.service`应该在它们之后启动。

相应地，还有一个`Before`字段，定义`sshd.service`应该在哪些服务之前启动。

注意，`After`和`Before`字段只涉及启动顺序，不涉及依赖关系。

举例来说，某 Web 应用需要 postgresql 数据库储存数据。在配置文件中，它只定义要在 postgresql 之后启动，而没有定义依赖 postgresql 。上线后，由于某种原因，postgresql 需要重新启动，在停止服务期间，该 Web 应用就会无法建立数据库连接。

设置依赖关系，需要使用`Wants`字段和`Requires`字段。

> `Wants`字段：表示`sshd.service`与`sshd-keygen.service`之间存在"弱依赖"关系，即如果"sshd-keygen.service"启动失败或停止运行，不影响`sshd.service`继续执行。
>
> `Requires`字段则表示"强依赖"关系，即如果该服务启动失败或异常退出，那么`sshd.service`也必须退出。
>
> 注意，`Wants`字段与`Requires`字段只涉及依赖关系，与启动顺序无关，默认情况下是同时启动的。

`ConditionPathExists=!/etc/ssh/sshd_not_to_be_run`这个条件用于 systemd 服务单元文件（如 `sshd.service`），作用是：**如果文件 `/etc/ssh/sshd_not_to_be_run` 存在，则禁止 SSH 服务启动**。

这是一种通过文件存在性控制服务启停的常见方法

### [Service] 区块：启动行为

`Service`区块定义如何启动当前服务。

#### 启动命令

许多软件都有自己的环境参数文件，该文件可以用`EnvironmentFile`字段读取。

> `EnvironmentFile`字段：指定当前服务的环境参数文件。该文件内部的`key=value`键值对，可以用`$key`的形式，在当前配置文件中获取。

上面的例子中，sshd 的环境参数文件是`/etc/default/sshd`。

配置文件里面最重要的字段是`ExecStart`。

> `ExecStart`字段：定义启动进程时执行的命令。

上面的例子中，启动`sshd`，执行的命令是`/usr/sbin/sshd -D $SSHD_OPTS`，其中的变量`$SSHD_OPTS`就来自`EnvironmentFile`字段指定的环境参数文件。

与之作用相似的，还有如下这些字段。

> - `ExecReload`字段：重启服务时执行的命令
> - `ExecStop`字段：停止服务时执行的命令
> - `ExecStartPre`字段：启动服务之前执行的命令
> - `ExecStartPost`字段：启动服务之后执行的命令
> - `ExecStopPost`字段：停止服务之后执行的命令

请看下面的例子。

```bash
[Service]
ExecStart=/bin/echo execstart1
ExecStart=
ExecStart=/bin/echo execstart2
ExecStartPost=/bin/echo post1
ExecStartPost=/bin/echo post2
```

上面这个配置文件，第二行`ExecStart`设为空值，等于取消了第一行的设置。

使用`journalctl -u hdy `命令查看运行结果，如下。

> execstart2
> 	post1
> 	post2

所有的启动设置之前，都可以加上一个连词号（`-`），表示"抑制错误"，即发生错误的时候，不影响其他命令的执行。比如，`EnvironmentFile=-/etc/default/ssh`（注意等号后面的那个连词号），就表示即使`/etc/default/ssh`文件不存在，也不会抛出错误。

#### 启动类型

`Type`字段定义启动类型。它可以设置的值如下。

> - simple（默认值）：`ExecStart`字段启动的进程为主进程
> - forking：`ExecStart`字段将以`fork()`方式启动，此时父进程将会退出，子进程将成为主进程
> - oneshot：类似于`simple`，但只执行一次，Systemd 会等它执行完，才启动其他服务
> - dbus：类似于`simple`，但会等待 D-Bus 信号后启动
> - notify：类似于`simple`，启动结束后会发出通知信号，然后 Systemd 再启动其他服务
> - idle：类似于`simple`，但是要等到其他任务都执行完，才会启动该服务。一种使用场合是为让该服务的输出，不与其他服务的输出相混合

下面是一个`oneshot`的例子，笔记本电脑启动时，要把触摸板关掉，配置文件可以这样写。

```bash
[Unit]
Description=Switch-off Touchpad

[Service]
Type=oneshot
ExecStart=/usr/bin/touchpad-off

[Install]
WantedBy=multi-user.target
```

上面的配置文件，启动类型设为`oneshot`，就表明这个服务只要运行一次就够了，不需要长期运行。

如果关闭以后，将来某个时候还想打开，配置文件修改如下。

```bash
[Unit]
Description=Switch-off Touchpad

[Service]
Type=oneshot
ExecStart=/usr/bin/touchpad-off start
ExecStop=/usr/bin/touchpad-off stop
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
```

上面配置文件中，`RemainAfterExit`字段设为`yes`，表示进程退出以后，服务仍然保持执行。这样的话，一旦使用`systemctl stop`命令停止服务，`ExecStop`指定的命令就会执行，从而重新开启触摸板。

#### 重启行为

`Service`区块有一些字段，定义了重启行为。

> `KillMode`字段：定义 Systemd 如何停止 sshd 服务。

上面这个例子中，将`KillMode`设为`process`，表示只停止主进程，不停止任何sshd 子进程，即子进程打开的 SSH session 仍然保持连接。这个设置不太常见，但对 sshd 很重要，否则你停止服务的时候，会连自己打开的 SSH session 一起杀掉。

`KillMode`字段可以设置的值如下。

> - control-group（默认值）：当前控制组里面的所有子进程，都会被杀掉
> - process：只杀主进程
> - mixed：主进程将收到 SIGTERM 信号，子进程收到 SIGKILL 信号
> - none：没有进程会被杀掉，只是执行服务的 stop 命令。

接下来是`Restart`字段。

> `Restart`字段：定义了 sshd 退出后，Systemd 的重启方式。

上面的例子中，`Restart`设为`on-failure`，表示任何意外的失败，就将重启sshd。如果 sshd 正常停止（比如执行`systemctl stop`命令），它就不会重启。

`Restart`字段可以设置的值如下。

> - no（默认值）：退出后不会重启
> - on-success：只有正常退出时（退出状态码为0），才会重启
> - on-failure：非正常退出时（退出状态码非0），包括被信号终止和超时，才会重启
> - on-abnormal：只有被信号终止和超时，才会重启
> - on-abort：只有在收到没有捕捉到的信号终止时，才会重启
> - on-watchdog：超时退出，才会重启
> - always：不管是什么退出原因，总是重启

对于守护进程，推荐设为`on-failure`。对于那些允许发生错误退出的服务，可以设为`on-abnormal`。

`RestartPreventExitStatus` 字段用于 **指定某些退出状态码时禁止自动重启服务**。它通常与 `Restart=` 参数配合使用，用于更精细地控制服务的重启行为。

> RestartPreventExitStatus=255  # 当退出码是255 时，不重启。

还有一个没有写出的RestartSec`字段。

> `RestartSec`字段：表示 Systemd 重启服务之前，需要等待的秒数。用于 **控制服务崩溃后自动重启的等待时间**。它可以避免服务频繁崩溃时无限快速重启，导致系统资源耗尽或日志爆炸。

#### 运行时目录

`RuntimeDirectory`字段指定在运行时自动创建的目录，避免手动管理目录。目录在`/run/sshd`位置。

`RuntimeDirectoryMode`字段设置运行时目录的权限。

### [Install] 区块

`Install`区块，定义如何安装这个配置文件，即怎样做到开机启动。

> `WantedBy`字段：表示该服务所在的 Target。

`Target`的含义是服务组，表示一组服务。`WantedBy=multi-user.target`指的是，sshd 所在的 Target 是`multi-user.target`。

这个设置非常重要，因为执行`systemctl enable sshd.service`命令时，`sshd.service`的一个符号链接，就会放在`/etc/systemd/system`目录下面的`multi-user.target.wants`子目录之中。

Systemd 有默认的启动 Target。

```bash
$ systemctl get-default
multi-user.target
```

上面的结果表示，默认的启动 Target 是`multi-user.target`。在这个组里的所有服务，都将开机启动。这就是为什么`systemctl enable`命令能设置开机启动的原因。

使用 Target 的时候，`systemctl list-dependencies`命令和`systemctl isolate`命令也很有用。

> ```bash
> # 查看 multi-user.target 包含的所有服务
> $ systemctl list-dependencies multi-user.target
> 
> # 切换到另一个 target
> # shutdown.target 就是关机状态
> $ sudo systemctl isolate shutdown.target
> ```

一般来说，常用的 Target 有两个：一个是`multi-user.target`，表示多用户命令行状态；另一个是`graphical.target`，表示图形用户状态，它依赖于`multi-user.target`。官方文档有一张非常清晰的 [Target 依赖关系图](https://www.freedesktop.org/software/systemd/man/bootup.html#System Manager Bootup)。

### Target 的配置文件

Target 也有自己的配置文件。

```bash
$ systemctl cat multi-user.target

[Unit]
Description=Multi-User System
Documentation=man:systemd.special(7)
Requires=basic.target
Conflicts=rescue.service rescue.target
After=basic.target rescue.service rescue.target
AllowIsolate=yes
```

注意，Target 配置文件里面没有启动命令。上面输出结果中，主要字段含义如下。

> `Requires`字段：要求`basic.target`一起运行。
>
> `Conflicts`字段：冲突字段。如果`rescue.service`或`rescue.target`正在运行，`multi-user.target`就不能运行，反之亦然。
>
> `After`：表示`multi-user.target`在`basic.target` 、 `rescue.service`、 `rescue.target`之后启动，如果它们有启动的话。
>
> `AllowIsolate`：允许使用`systemctl isolate`命令切换到`multi-user.target`。

### 修改配置文件后重启

修改配置文件以后，需要重新加载配置文件，然后重新启动相关服务。

```bash
# 重新加载配置文件
$ sudo systemctl daemon-reload

# 重启相关服务
$ sudo systemctl restart foobar
```



[linux下Systemd 入门教程：命令篇_linux systemd-CSDN博客](https://blog.csdn.net/chengziwang/article/details/112470603)

[10分钟学会linux自定义服务（systemctl）_linux systemctl enable-CSDN博客](https://blog.csdn.net/arv002/article/details/121779213)

[systemctl添加自定义系统服务 - 菜鸟++ - 博客园](https://www.cnblogs.com/keystone/p/13158117.html)

[Linux上systemctl 和 service 两个命令的区别和联系_linux service systemctl-CSDN博客](https://blog.csdn.net/happyblreay/article/details/140145686)

[高效日志管理：通过 Systemd Journal 收集日志的终极指南 - 我和你并没有不同 - 博客园](https://www.cnblogs.com/testzcy/p/18222623)

[Systemd 入门教程：命令篇 - 阮一峰的网络日志](https://ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html)