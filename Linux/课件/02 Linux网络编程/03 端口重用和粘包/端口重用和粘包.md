# 端口复用

## 引入

先来一段代码，思考如何同时运行两个此程序会发生什么?

```c
#include <sys/socket.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

#include "socket_wrap.h"

int createServer(uint16_t port)
{

        //创建socket
        int fd = hdy_socket(AF_INET,SOCK_STREAM,0);

        //绑定地址和端口号
        struct sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(port);
        addr.sin_addr.s_addr = INADDR_ANY;

        hdy_bind(fd,(struct sockaddr*)&addr,sizeof(addr));

        //监听
        hdy_listen(fd,5);

        return fd;
}


int main()
{
        int fd = createServer(8080);

        printf("server listen on prot:%d\n",8080);

        char buffer[BUFSIZ]="GET /user HTTP/1.1\r\nContent-type:application/json\r\nContent-Lenght:12\r\n";
        while(1) {
                //接受连接
                int newSocket = hdy_accept(fd,NULL,NULL);
                printf("new connection\n");

                //发送消息
                int ret = hdy_write(newSocket,buffer,strlen(buffer));
                if(ret>0) {
                        printf("write success!\n");
                }
        }

        hdy_close(fd);
        return 0;
}
```

当运行第一个时，运行正常；

当运行第二个时，出现错误：`[ERROR] socket_wrap.c:33  : bind error (Address already in use) `。

为什么会出现错误呢？这是因为第一个程序已经占用了8080端口，当第二个程序启动时，发现这个端口已经占用了，就不能再绑定了，所以报错~

> 有时候即使没有开两个服务器，当你重启服务器时，socket还没有来得及回收，从而导致重启时，检测到端口占用！所以这个问题要解决~

## 套接字选项

一般情况下端口号对应着唯一的一个进程，当操作系统检测到发送给这个端口的消息，就会转给对应的进程处理！

如果有两个或多个进程绑定同一个端口号，那么操作系统将无法区分转给哪个进程！

但是为了发挥多核CPU的性能，Linux 内核从 3.9 版本开始引入一个新的 socket 选项 SO_REUSEPORT，又称为 port sharding，允许多个套接字监听同一个IP 和端口组合。

使用`setsockopt`函数来设置socket选项。函数原型如下：

```c
int setsockopt(int sockfd, int level, int optname,
               const void optval[.optlen],
               socklen_t optlen);
```

**参数：**

+ sockfd：要设置选项的socket描述符
+ level：选项定义的层次，一般设置`SOL_SOCKET`即可，其他选项如下
  + SOL_SOCKET：通用套接字选项
  + IPPROTO_IP：IPV4套接字
  + IPPROTO_IPV6：IPV6套接字
  + IPPROTO_TCP：TCP选项

+ optname：选项名称，有下列几种数值：

![image-20250901200615341](./assets/image-20250901200615341.png)

+ optval：选项值指针，指向存放选项待设置的新值的缓冲区。
+ optlen：选项值(optval)内存大小

**返回值：**成功执行时，返回0。失败返回-1，errno被设为以下的某个值

+ EBADF：sockfd不是有效的文件描述词
+ EFAULT：optval指向的内存并非有效的进程空间
+ EINVAL：在调用setsockopt()时，optlen无效
+ ENOPROTOOPT：指定的协议层不能识别选项
+ ENOTSOCK：socket描述的不是套接字
  

[setsockopt()函数功能介绍 - 启云 - 博客园](https://www.cnblogs.com/eeexu123/p/5275783.html)

## 端口复用

接下来我们把开始的代码设置端口复用，再看看效果。

### 服务器

```c
int createServer(uint16_t port)
{
    //创建socket
    int fd = hdy_socket(AF_INET,SOCK_STREAM,0);
    
    //设置端口复用
    int optval = 1;
    if(setsockopt(fd,SOL_SOCKET,SO_REUSEPORT,&optval,sizeof(optval))!=0){
        perror("setsockopt error");
    }
    
    //代码已省略...
```

### 客户端

客户端我们可以自己写代码实现，但是为了方便我们这里直接使用`nc`命令。

> *nc*（Netcat）是一款功能强大的网络工具，被誉为网络安全界的“瑞士军刀”。它支持端口扫描、文件传输、简单聊天、HTTP请求模拟等多种功能，适用于网络调试和安全测试。

```c
 nc localhost 8080
```

### 测试

先启动两个服务器，然后启栋客户端，接受到数据之后，再启动客户端，多连接几次服务器做测试！效果如下：两个服务都能收到客户端的连接，但是不是同时收到的，系统会自动选择对应的socket。

服务器一：

![image-20250901201803783](./assets/image-20250901201803783.png)

服务器二：

![image-20250901201820795](./assets/image-20250901201820795.png)

客户端：

![image-20250901205234029](./assets/image-20250901205234029.png)

## 查看套接字

使用ss来查看套接字统计信息，功能类似于 netstat，但速度更快，提供更详细的网络连接状态信息。

> ss 是 Socket Statistics（套接字统计）的缩写，用于显示和分析系统的网络连接状态。

```css
maye@maye-ubuntu-pc:~/course/day16$ ss -tlnpe | grep -i 8080
LISTEN 0      5            0.0.0.0:8080      0.0.0.0:*    users:(("server",pid=10500,fd=3)) uid:1000 ino:263230 sk:280 cgroup:/user.slice/user-1000.slice/session-104.scope <->
LISTEN 0      5            0.0.0.0:8080      0.0.0.0:*    users:(("server",pid=10498,fd=3)) uid:1000 ino:262872 sk:281 cgroup:/user.slice/user-1000.slice/session-104.scope <->
```

注意到最后一列中的信息，可以看到监听 9090 端口的是两个不同的 socket，它们的 inode 号分别是 263230和 262872。

`ss`的选项解释如下。

```css
-t, --tcp
    显示 TCP 的 socket
-l, --listening
    只显示 listening 状态的 socket，默认情况下是不显示的。
-n, --numeric
    显示端口号而不是映射的服务名
-p, --processes
    显示进程名
-e, --extended
    显示 socket 的详细信息
```

# TCP粘包/拆包

在TCP的socket编程中，发送端和接收端都有成对的socket。发送端为了将多个发往接收端的包，更加高效的的发给接收端，于是采用了优化算法（Nagle算法），将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，然后进行封包。那么这样一来，接收端就必须使用高效科学的拆包机制来分辨这些数据

## 粘包/拆包问题分析

**粘包问题**

粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。

**拆包问题**

拆包是指在基于TCP协议的通讯中，数据包在传输过程中被分割成多个较小的数据包的过程。具体来说，当应用程序发送一个完整的数据包到网络层时，由于TCP协议的特点，这个数据包可能会被拆分成多个更小的数据包进行传输，以便适应网络传输的限制和优化传输效率。这种行为在TCP协议中是正常且常见的，但有时会导致接收端在重组数据包时遇到困难，即所谓的“拆包问题”。

![无标题](./assets/无标题.png)

上图中演示了以下几种情况：

- 正常的理想情况，两个包恰好满足TCP缓冲区的大小或达到TCP等待时长，分别发送两个包；
- 粘包：两个包较小，间隔时间短，发生粘包，合并成一个包发送；
- 拆包：一个包过大，超过缓存区大小，拆分成两个或多个包发送；
- 拆包和粘包：Packet1过大，进行了拆包处理，而拆出去的一部分又与Packet2进行粘包处理。

## 常见的解决方案

对于粘包和拆包问题，常见的解决方案有三种：

- 发送端将每个包都封装成**固定的长度**，比如100字节大小。如果不足100字节可通过补0或空等进行填充到指定长度；
- 发送端在每个包的末尾使用固定的**分隔符**，例如\r\n。如果发生拆包需等待多个包发送过来之后再找到其中的\r\n进行合并；例如，FTP协议；
- 将消息分为**头部和消息体**，头部中保存整个消息的长度，只有读取到足够长度的消息之后才算是读到了一个完整的消息；



