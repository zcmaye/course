## 事件循环

### 简介

对于大多数长时间运行程序来说，都会有主循环的存在。

+ 如窗口界面程序，就是等待键盘、鼠标等外设的输入，界面做出相应的变化(游戏，软件等)

+ 网络程序中，也需要有事件循环，来不断地处理网络IO。

### event模块

libhv下的event模块封装了多种平台的IO多路复用机制，提供了统一的事件接口，是libhv的核心模块。

libhv中的事件包括**IO事件**、**timer定时器事件**、**idle空闲事件**、**自定义事件**（见hloop_post_event接口，作用类似于windows窗口消息机制的PostMessage）。

#### 创建事件循环

使用`hloop_new`创建一个事件循环对象，然后使用`hloop_run`让事件循环跑起来，由于没有注册事件，所以此时事件循环在空跑！

```c
#include "hv/hloop.h"

int main() {
    // 新建一个事件循环结构体
    hloop_t* loop = hloop_new(0);

    // 运行事件循环
    hloop_run(loop);

    // 释放事件循环结构体
    hloop_free(&loop);
    return 0;
}
```

#### 添加定时器事件

##### 普通定时器

普通定时器是是相对间隔时间的，每隔一定时间调用触发并调用回调函数。

在事件循环运行之前，添加一个时间间隔为1000毫秒的定时器，并把`on_timer`作为回调。

```c
// 定时器回调函数
static void on_timer(htimer_t* timer) {
    printf("time=%lus\n", (unsigned long)time(NULL));
}

int main() {
    
    // 添加一个定时器
    htimer_add(loop, on_timer, 1000, INFINITE);

    // 运行事件循环
    hloop_run(loop);
}
```

上面代码，每隔一秒钟调用一次`on_timer`函数。

##### 周期定时器

用于添加**类 Crontab 格式的周期性定时器**。它基于日历时间（真实时间），而不是相对间隔时间。

`htimer_add_period`函数用于在事件循环上注册一个定时器，这个定时器会像 Linux 系统中的 `cron` 任务一样，在指定的分钟、小时、日、月、星期等时间点触发。

函数原型：

```c
htimer_t* htimer_add_period(
    hloop_t* loop,          // 事件循环指针
    timer_cb cb,            // 定时器触发时的回调函数
    int minute,             // 分钟 (0 - 59)
    int hour,               // 小时 (0 - 23)
    int day,                // 日 (1 - 31)
    int week,               // 星期 (0 - 6, 0代表星期日)
    int month,              // 月 (1 - 12)
    int repeat,             // 重复次数，-1 表示无限重复
);
```

参数详解：

| 参数     | 取值范围       | 特殊值说明                                   |
| :------- | :------------- | :------------------------------------------- |
| `minute` | 0 - 59         | `-1` 表示“每一分钟”                          |
| `hour`   | 0 - 23         | `-1` 表示“每一小时”                          |
| `day`    | 1 - 31         | `-1` 表示“每一天”                            |
| `week`   | 0 - 6 (0=周日) | `-1` 表示“不按星期指定”                      |
| `month`  | 1 - 12         | `-1` 表示“每一月”                            |
| `repeat` | 整数           | `-1` 表示永久重复，`0` 或 `1` 表示只执行一次 |

**关键规则：**

- `day` 和 `week` 参数是**互斥**的。通常只设置其中一个，另一个设为 `-1`。
- 定时器的触发时间是由这5个时间字段（分、时、日、月、周）**共同决定**的。

以下是一些案例：

```css
/*
 * minute   hour    day     week    month       cb
 * 0~59     0~23    1~31    0~6     1~12
 *  -1      -1      -1      -1      -1          cron.minutely		每分钟执行一次
 *  30      -1      -1      -1      -1          cron.hourly			每小时30分执行一次	
 *  30      1       -1      -1      -1          cron.daily			每天凌晨1点30执行一次
 *  30      1       15      -1      -1          cron.monthly		每月15号凌晨1点30执行一次
 *  30      1       -1       5      -1          cron.weekly			每周5凌晨1点30执行一次
 *  30      1        1      -1      10          cron.yearly			每年10月1日凌晨1点30执行一次
 */
```

#### 空闲事件

**空闲事件（idle event）** 是一种特殊的事件类型，它会在事件循环没有其他更紧迫的任务（如 I/O 事件或定时器事件）需要处理时才会被触发。这使其非常适合执行那些不紧急、可以在系统"空闲"时运行的后台任务。

```c
#include "hv/hloop.h"

void idle_callback(hidle_t* idle) {
    printf("Processing task in idle time.\n");
}

int main() {
    hloop_t* loop = hloop_new(0);
    
    // 添加一个无限重复的空闲事件
    hidle_t* idle = hidle_add(loop, idle_callback, INFINITE);
    
    hloop_run(loop);
    hloop_free(&loop);
    return 0;
}
```

空闲事件在以下场景中特别有用：

- **低优先级后台任务**：执行像定期刷新日志缓冲区、收集非关键性统计信息等不影响主流程的任务。
- **资源清理与维护**：在系统相对空闲时进行一些资源回收或状态检查工作。
- **渐进式处理**：将一个大型任务分解成多个小步骤，在连续的 idle 回调中逐步执行，避免长时间阻塞事件循环。

#### 自定义事件

**自定义事件** 是一种强大的机制，允许你向事件循环注入自己的任务，并像处理内置的 I/O 或定时器事件一样处理它们。这对于线程间通信、解耦复杂逻辑或执行非阻塞的异步操作非常有用。

```c
void custom_event_handler(hevent_t* event)
{
	if (event->event_type == HEVENT_TYPE_CUSTOM) {
		printf("custom event handler 1\n");
	}
	else if (event->event_type == HEVENT_TYPE_CUSTOM + 1) {
		printf("custom event handler 2\n");
	}
    if (event->userdata) {
		printf("userdata =%d\n", *(int*)event->userdata);
		free(event->userdata);
	}
}

void post_custom_event(htimer_t* timer)
{
	//创建自定义事件
	hevent_t ev = { 0 };
	ev.event_type = HEVENT_TYPE_CUSTOM + hv_rand(0, 1);
	ev.cb = custom_event_handler;
    //设置用户数据
	ev.userdata = malloc(sizeof(int));
	if (ev.userdata) {
		*(int*)ev.userdata = hv_rand(100, 200);
	}

	hloop_post_event(hevent_loop(timer),&ev);
}

void test_event_custom()
{
	hloop_t* loop = hloop_new(0);

	htimer_add(loop, post_custom_event, 1000, INFINITE);

	hloop_run(loop);

	hloop_free(&loop);
}
```

