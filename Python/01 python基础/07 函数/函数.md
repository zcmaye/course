# 函数

函数是一段可重复使用的代码块，用于执行特定的任务。

## 为什么要使用函数？

1. **代码复用**：避免重复编写相同的代码，提高开发效率。例如，有多个地方需要计算两个数的和，就可以定义一个`add`函数，在需要的地方直接调用，而不需要每次都重新编写加法代码。
2. **提高可读性**：将复杂的任务分解为多个小的、功能明确的函数，使代码结构更加清晰，易于理解和维护。比如，一个程序实现文件读取、数据处理、结果输出等功能，可以分别定义`read_file`、`process_data`、`output_result`等函数，每个函数专注于一个特定的任务，这样整个程序的逻辑就一目了然。
3. **便于调试**：当程序出现问题时，由于函数功能单一，更容易定位和解决问题。如果是数据处理部分出错，只需要检查`process_data`函数的代码即可。

## 函数的定义

和变量一样，要想使用一个函数，定义是不可缺少的，函数定义有4个要素：<font color=red>返回值、函数名、参数列表和函数体</font>，参数列表和返回类型对应着输入输出，函数名是函数的标识，而函数体是一段可执行的代码块，实现特定的算法或功能。

函数通过`def`关键字来定义，其基本语法格式如下：

```python
def 函数名(参数列表):
    函数体
    return 返回值
```

### 无参无返回值函数

一个函数既不接受参数，也不返回值，那么这个函数就是无参无返回值的函数。

```python
def print_msg():
    print("I'm maye!")    
```

调用此函数`print_msg()`，会打印`I'm maye!`。

### 有参无返回值函数

一个函数只接受参数，但不返回值，那么这个函数就是有参无返回值的函数。

```python
def print_name(name):
    print(f"I'm {name}")
```

调用此函数`print_name('玩蛇')`，会打印`I’m 玩蛇`。

### 有参有返回值函数

一个函数既接受参数，也返回值，那么这个函数就是有参有返回值的函数。

`return`语句用于结束函数的执行，并将一个值返回给函数的调用者。

#### 返回一个值

```python
def get_sum(a,b):
    return a+b
```

调用方式如下:

```python
ret = get_sum(2,4)
print(f"sum is {ret}")
```

在这个例子中，`get_sum`函数计算两个数的和，并通过`return`语句将结果返回，调用者可以将返回值赋给变量`ret`并进行后续操作。

#### 返回多个值

Python 函数可以返回多个值，实际上是返回一个元组。

```python
def get_coordinates():
    x = 10
    y = 20
    return x, y
x_value, y_value = get_coordinates()
print(f"x = {x_value}, y = {y_value}")
```

因为返回多个值，python会将这多个值，打包成元组，因此实际上`x_value, y_value = get_coordinates()`语句是直接将元组进行了解构！



### 函数返回None值

如果一个函数没有返回值，那么打印返回值将会是什么结果呢?

```python
def foo():
    pass
```

+ `pass`是一个空语句，它不执行任何操作，主要用于占位，以保证代码结构的完整性。pass通常用于函数、分支体！！！

```python
print(foo())	#输出None
```



## 函数参数

### 1. 形参和实参

+ **形参（形式参数）**：在函数定义时，括号内列出的参数名称，它只是一个占位符，代表函数在调用时需要接收的数据类型和位置。例如在`def add(a, b):`中，`a`和`b`就是形参。
+ **实参（实际参数）**：在函数调用时，传递给函数的具体值。例如`add(3, 5)`中，`3`和`5`就是实参，它们会按照顺序依次赋值给形参`a`和`b`。

### 2. 位置参数

实参按照顺序依次对应形参进行赋值。例如：

```python
def greet(name, age):
    print(f"Hello, {name}! You are {age} years old.")
greet("Alice", 25)
```

在这个例子中，`"Alice"`对应`name`形参，`25`对应`age`形参。

### 3. 关键字参数

在函数调用时，通过参数名来指定实参的赋值，而不依赖于顺序。例如：

```python
def greet(name, age):
    print(f"Hello, {name}! You are {age} years old.")
greet(age = 25, name = "Alice")
```

这样即使参数顺序颠倒，也能正确赋值。位置参数和关键字参数可以混合使用，但位置参数必须在关键字参数之前。例如`greet("Alice", age = 25)`是正确的，而`greet(age = 25, "Alice")`会报错。

### 4. 默认参数

在函数定义时，可以给参数设置默认值。当函数调用时，如果没有传递该参数的值，则使用默认值。例如：

```python
def greet(name, age = 18):
    print(f"Hello, {name}! You are {age} years old.")
greet("Bob")
greet("Charlie", 30)
```

在调用`greet("Bob")`时，`age`参数没有传入值，就会使用默认值`18`；而调用`greet("Charlie", 30)`时，`age`会被赋值为`30`。注意，有默认值的参数必须放在没有默认值的参数之后，否则会报错。

### 5. 可变参数

#### 5.1 基本使用

1. **`*args`（可变位置参数）**：用于接收任意数量的位置参数，这些参数会被封装成一个元组。例如：

```python
def sum_numbers(*args):
    total = 0
    for num in args:
        total += num
    return total
print(sum_numbers(1, 2, 3))
print(sum_numbers(1, 2, 3, 4, 5))
```

2. **`**kwargs`（可变关键字参数）**：用于接收任意数量的关键字参数，这些参数会被封装成一个字典。例如：

```python
def print_info(**kwargs):
    for key, value in kwargs.items():
        print(f"{key}: {value}")
print_info(name = "Alice", age = 25, city = "New York")
```

#### 5.2 可变参数解包

在 Python 中，可变参数解包是一种强大的特性，它允许你将列表、元组、字典等可迭代对象中的元素拆分并作为独立的参数传递给函数。可变参数解包分为两种：位置参数解包（使用单个星号 `*`）和关键字参数解包（使用两个星号 `**`）。下面为你详细介绍这两种解包方式。

##### 5.2.1 位置参数解包（`*`）

当你有一个列表、元组或其他可迭代对象，并且想将其中的元素作为位置参数传递给函数时，可以使用单个星号 `*` 进行解包。

**示例代码**

```python
def add_numbers(a, b, c):
    return a + b + c

numbers = [1, 2, 3]
result = add_numbers(*numbers)
print(result)
```

**代码解释**

- 定义了一个 `add_numbers` 函数，它接受三个位置参数。
- 创建了一个包含三个元素的列表 `numbers`。
- 使用 `*numbers` 对列表进行解包，将列表中的元素拆分成独立的参数传递给 `add_numbers` 函数，相当于调用 `add_numbers(1, 2, 3)`。

##### 5.2.2 关键字参数解包（`**`）

如果你有一个字典，并且想将字典中的键值对作为关键字参数传递给函数，可以使用两个星号 `**` 进行解包。

**示例代码**

```python
def greet(name, age):
    print(f"Hello, {name}! You are {age} years old.")

person_info = {'name': 'Alice', 'age': 25}
greet(**person_info)
```

**代码解释**

- 定义了一个 `greet` 函数，它接受两个关键字参数 `name` 和 `age`。
- 创建了一个包含 `name` 和 `age` 键值对的字典 `person_info`。
- 使用 `**person_info` 对字典进行解包，将字典中的键值对拆分成独立的关键字参数传递给 `greet` 函数，相当于调用 `greet(name='Alice', age=25)`。

##### 5.2.3 组合使用

在实际应用中，你可以将位置参数解包和关键字参数解包组合使用，以实现更灵活的参数传递。

**示例代码**

```python
def combined_function(a, b, c, **kwargs):
    print(f"位置参数: {a}, {b}, {c}")
    print("关键字参数:")
    for key, value in kwargs.items():
        print(f"{key}: {value}")

numbers = [1, 2, 3]
person_info = {'name': 'Bob', 'age': 30}
combined_function(*numbers, **person_info)
```

**代码解释**

- 定义了一个 `combined_function` 函数，它接受三个位置参数和任意数量的关键字参数。
- 创建了一个包含三个元素的列表 `numbers` 和一个包含 `name` 和 `age` 键值对的字典 `person_info`。
- 使用 `*numbers` 对列表进行解包，将列表中的元素作为位置参数传递给函数；使用 `**person_info` 对字典进行解包，将字典中的键值对作为关键字参数传递给函数。

**注意事项**

- 位置参数解包和关键字参数解包必须与函数定义的参数类型和数量相匹配，否则会引发 `TypeError` 异常。
- 解包操作只能用于可迭代对象（如列表、元组、字典等）。

通过可变参数解包，你可以更方便地将可迭代对象中的元素传递给函数，提高代码的灵活性和可读性。

### 6. 参数限制

#### 6.1仅限位置参数（`/`）

在 Python 3.8 及以后的版本中，引入了仅限位置参数的概念，使用斜杠 `/` 来分隔。斜杠左边的参数必须通过位置传递，不能使用关键字参数。

```python
def func(a, b, /, c):
    return a + b + c

print(func(1, 2, 3))
print(func(1, 2, c=3))
# 下面这行代码会报错，因为 a 是仅限位置参数，不能用关键字传递
# print(func(a=1, 2, 3))
```

#### 6.2 仅限关键字参数（`*`）

星号 `*` 可以作为分隔符，星号后面的参数必须使用关键字参数传递。

```python
def func2(a, *, b):
    return a + b

print(func2(1, b=2))
# 下面这行代码会报错，因为 b 是仅限关键字参数，必须用关键字传递
# print(func2(1, 2))
```

#### 6.3 结合使用

斜杠`/`和星号`*`可以在同一个函数定义中结合使用，这样可以更精确地控制参数的传递方式。

**示例代码**

```python
def combined_function(a, b, /, c, *, d):
    return a + b + c + d


# 正确调用
result = combined_function(1, 2, 3, d=4)
print(result)
```

在这个例子中，`a`和`b`是仅限位置参数，`c`可以用位置或关键字参数传递，`d`是仅限关键字参数。

### 7. 形参和实参关系

实参传递给形参时，本质上是传递对象的引用（Python 中一切皆对象），具体表现取决于对象是可变对象还是不可变对象。

- **不可变对象**：如 `int`、`float`、`str`、`tuple` 等。当传递不可变对象作为实参时，形参获得的是对象值的副本，形参的修改不会影响实参。例如：

```python
def modify_number(num):
    num = num + 1
    print(f"函数内部的 num 值: {num}")

x = 10
modify_number(x)
print(f"函数外部的 x 值: {x}")
```

在这个例子中，`x` 是不可变的 `int` 类型对象，传递给 `modify_number` 函数后，形参 `num` 获得了 `x` 值的副本，在函数内部对 `num` 的修改不会影响到外部的 `x`。

- **可变对象**：如 `list`、`dict`、`set` 等。当传递可变对象作为实参时，形参和实参指向同一个对象，形参的修改会影响实参。例如：

```python
def modify_list(lst):
    lst.append(4)
    print(f"函数内部的 lst 值: {lst}")

my_list = [1, 2, 3]
modify_list(my_list)
print(f"函数外部的 my_list 值: {my_list}")
```

这里 `my_list` 是可变的 `list` 类型对象，传递给 `modify_list` 函数后，形参 `lst` 和实参 `my_list` 指向同一个列表对象，在函数内部对 `lst` 的修改会影响到外部的 `my_list`。

**总结**

- 形参是函数定义时的占位符，实参是函数调用时的具体数据。
- 实参通过位置或关键字的方式传递给形参。
- 传递不可变对象时，形参修改不影响实参；传递可变对象时，形参修改会影响实参。

## 作用域






# 函数递归

递归也是一种函数调用，只不过是函数自己调用自己，是一种特殊的函数调用，调用自己同调用别人是一模一样的。

+ 使用递归必须要满足的两个条件
  + 要有递归公式。
  + 要有终止条件。
+ 递归和循环的关系
  + 递归和循环存在很多关系。理论上讲，所有的循环都可以转化成递归
  + 循环又称迭代。递归算法与迭代算法设计思路的主要区别在于：函数或算法是否具备收敛性！当且仅当一个算法存在预期的收敛效果时，采用递归算法才是可行的。否则就不能使用递归算法。所谓收敛性就是指要有终止条件，不能无休止地递归下去。
+ 递归的优缺点
  + 递归的优点是简化程序设计，结构简洁清晰，容易编程，可读性强，容易理解。在很多情况下使用递归是必要的，它往往能把复杂问题分解为更简单的步骤，而且能够反映问题的本质。我们一开始可能发现递归理解起来也不容易，这是因为我们的“见识”太少了！等将来学习树和图的时候你才能真正领会到递归是多么的“好理解”！
  + 递归的缺点也很明显：速度慢，运行效率低，对存储空间的占用比循环多。严格讲，循环几乎不浪费任何存储空间，而递归浪费的空间实在是太大了，而且速度慢。因为递归是用栈机制实现的，每深入一层都要占用一块栈数据区域。

**通过一个简单的程序了解递归**

```cpp
int foo(int n)
{
    if(n == 0)
    {
        return 0;
	}
    printf("I love you\n");
    foo(n-1);
}
```

**递归求斐波拉契数列**

前面我们已经学习了，用循环求斐波拉契数列，现在我们要用递归来实现。

```cpp
int fibonacci(int n)
{
    if(n==0||n==1)
    {
        return 1;
    }else
    {
        return fibonacci(n - 1) + fibonacci(n-2);
    }
}
```



## 