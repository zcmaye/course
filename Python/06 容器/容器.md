# 容器

> 容器：用于存储和组织数据

Python中有哪些容器呢?

list(列表)、tuple(元组)、str(字符串)、set(集合)、dict(字典)，这些容器都各有特点，但都满足可容纳多个元素的特性。

## 列表

### 什么是列表？

列表是有序地元素集合，列表内的元素类型可以不同。

**思考**：如果一个班级100位学生，每个人的姓名都要存储，应该如何书写程序？声明100个变量吗？

**答**：No，我们使用列表就可以了，列表一次可以存储多个数据！

### 列表定义

列表使用中括号`[]`来定义，列表内的元素使用逗号分隔。

```python
#定义变量
var = [element1,element2,...]

#定义空列表
var = []
var = list()
```

**案例:**

```python
nums = [1,2,3,4,5]
print(nums)
print(type(nums))

#output: [1, 2, 3, 4, 5]
#    	 <class 'list'>
```

根据输出可以看出nums确实是list类型的变量。

> 注意：虽然列表可以存储不同数据类型的元素，但一般用来存储相同类型的元素！！！

### 列表元素访问

#### 遍历列表

+ 列表可以直接试用for循环进行遍历

  ```python
  for v in nums:
      print(v)
  ```

+ 还可以使用下标(索引)来访问列表中的每个元素

  ```python
  for i in range(len(nums)):
      print(nums[i])
  ```

  **下标是什么？**

  下标表示此元素在列表中的序号，但是序号是从0开始，而不是1，为什么呢？

  **因为索引其实是每个元素的地址，相对于第一个元素的偏移量！**

  因此，列表的索引有效范围是[0~len(list))，也就是从0到列表元素个数-1，访问无效索引，会出发异常`IndexError: list index out of range`。

+ 如，有以下列表：

  ```python
  heros = ["钢铁侠", "寡妇", "绿巨人"]
  ```

  可以通过索引访问指定的元素：

  ```python
  print(heros[0])
  print(heros[2])
  ```

  当列表元素比较多时，想要方便访问后面的元素，也可以使用负数索引，最后一个元素的索引为-1。

  ```python
  print(heros[-1])
  print(heros[-2])
  ```

  > 为什么从后往前访问，开始索引为-1，而不是-0呢？因为没有-0这个数QAQ！

#### 列表切片

列表切片是 Python 中非常强大且常用的功能，它允许你获取列表的子集而不改变原列表。

**基本语法**

```python
list[start:stop:step]
```

- `start`: 起始索引（包含）
- `stop`: 结束索引（不包含）
- `step`: 步长（默认为1）

**基本示例：**

```python
nums = [1,2,3,4,5,"maye"]
# 获取索引0到3（不包含3）的元素
print(nums[0:3])  # 输出: [1, 2, 3]
print(nums[:3])   # 输出: [1, 2, 3]

# 获取索引2到5（不包含5）的元素
print(nums[2:5])   # 输出: [3, 4, 5]

# 从索引3到结束
print(nums[3:])   # 输出: [4, 5, 'maye']

# 获取所有元素（复制列表）
print(nums[:])    # 输出: [1, 2, 3, 4, 5, 'maye']
print(id(nums),id(nums[:])) #打印id，查看是否是真的复制了一份
```

**步长使用**

```python
# 每两个元素取一个
print(nums[::2])  # 输出: [1, 3, 5]

# 从索引1开始，每两个元素取一个
print(nums[1::2]) # 输出: [2, 4, 'maye']

# 反向步长（反转列表）
print(nums[::-1]) # 输出: ['maye', 5, 4, 3, 2, 1]
```

#### 列表操作

##### 添加元素

+ 尾部追加一个元素

  ```python
  nums.append(8848)
  ```

+ 拓展列表

  ```python
  nums.extend([33, 44, 55])
  ```

  除了使用extend拓展列表，还可以使用上面的切片语法。

  ```python
  nums[len(nums):] = [888]	#相当于nums.append(888)
  nums[len(nums):] = [12,13]	#相当于nums.extend([12,13])
  ```

+ 列表加法和乘法

  ```python
  s = [1, 2, 3]
  t = [4, 5, 6]
  print(s + t)	#[1, 2, 3, 4, 5, 6]
  
  print(s * 3)	#[1, 2, 3, 1, 2, 3, 1, 2, 3]
  ```

+ 指定位置插入

  ```python
  nums.insert(0,77)	#在索引为0的位置插入77，其他元素都在77后面
  nums.insert(len(nums),99) #在尾部追加99，相当于append
  ```

##### **删除元素**

+ 删除指定元素

  ```python
  nums.remove(99)
  ```

  > 注意：1. 当列表中存在多个相同元素时，只删除第一个
  >
  > 	    2. 当删除的元素在类表中不存在时，抛出异常`ValueError: list.remove(x): x not in list`

+ 按索引删除元素

  ```python
  nums.pop(0) #删除索引为0的元素
  ```

+ 清空列表

  ```python
  nums.clear()
  ```

##### 排序

+ 升序

  ```python
  nums.sort()
  ```

+ 降序

  ```python
  nums.sort()			#先升序排列
  nums.reverse()		#再翻转列表
  ```

+ sort函数还支持参数

  ```python
  nums.sort(reverse=True) #在排序完成后直接翻转，就完成了升序排列
  ```

##### 其他

+ 统计元素个数

  ```python
  nums.count(5) #统计元素5在列表中的数量
  ```

+ 查找元素索引

  ```python
  nums.index(55) #查找55元素所在的索引
  nums[nums.index(55)] = 520
  
  #index还支持起始索引和结束索引
  nums.index(55,2,7)	#从索引2开始到7结束，找55元素
  ```

+ 列表拷贝

  ```python
  nums_cp = nums.copy();
  #nums_cp = nums[:];
  print(id(nums_cp),id(nums)) #查看两个列表的地址，会发现不一样
  ```

  如果直接试用赋值语法`nums_cp = nums`，则会发现两个列表的id是一样的。

#### 嵌套列表

列表嵌套是指一个列表包含其他列表作为其元素，这是 Python 中处理多维数据的常用方式。

```python
# 二维列表 (矩阵)
matrix = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]

# 创建一个三个元素都是0的一维列表
A = [0]*3
print(A)

# 将A列表的每个元素都修改为一个列表(二维列表)
for i in range(3):
    A[i] = [0]*3
print(A)

# 访问元素
print(matrix[0][1])  # 输出: 2 (第1行第2列)
```

> ⚠️ **注意**：不要用 `[[0]*3]*3` 这种方式，会导致内部列表是同一个对象的引用！
>
> 可以使用is运算符来比较两个对象是不是同一个（`is` 用于检查两个变量是否引用**同一个对象**（内存中的同一块地址），而不仅仅是值是否相等）

##### 访问嵌套列表元素

+ 直接遍历

  ```python
  for row in matrix:
      for v in row:
          print(v)
  ```

  

#### 列表推导式

+ 基本形式

  ```python
  x = [i**2 for i in range(5)] # 输出 [0, 1, 4, 9, 16]
  ```

  如果不使用列表推导式，则需要如下实现

  ```python
  x = []
  for i in range(10):
      i.append(i**2)
  ```

+ 带条件

  ```python
  evens = [x for x in range(10) if x % 2 == 0] # 输出 [0, 2, 4, 6, 8]
  ```

+ 嵌套循环

  ```python
  ls = [[x, y] for x in [1,2] for y in [3,4]] # 输出 [[1, 3], [1, 4], [2, 3], [2, 4]]
  
  ls = [[x, y] for x in range(10) if x%2==0 for y in range(10) if y % 3 == 0] # 输出 [[0, 0], [0, 3], [0, 6], [0, 9], [2, 0], [2, 3], [2, 6], [2, 9], [4, 0], [4, 3], [4, 6], [4, 9], [6, 0], [6, 3], [6, 6], [6, 9], [8, 0], [8, 3], [8, 6], [8, 9]]
  ```

  





