# Qt元对象系统

元对象系统是一个基于标准C++的扩展，为Qt提供了信号与槽机制、实时类型信息、动态属性系统。

## 1. 什么是元对象？

在计算机科学中，元对象是这样一个东西：它可以操纵、创建、描述、或执行其他对象。元对象描述的对象称为基对象。元对象可能存在这样的信息：基础对象的类型、接口、类、方法、属性、变量、控制结构等。

## 2. 元对象系统组成

Qt中的元对象系统基于一下三个东西:

### QObject

QObject是 QT 对象模型的核心，绝大部分的 Qt类都是从这个类继承而来。

### Q_OBJECT

Q_OBJECT宏必须出现在类定义的私有部分，用来开启信号和槽、动态属性系统，或Qt元对象系统提供的其他服务。

```jade
#define Q_OBJECT \
public: \
    QT_WARNING_PUSH \
    Q_OBJECT_NO_OVERRIDE_WARNING \
    static const QMetaObject staticMetaObject; \
    virtual const QMetaObject *metaObject() const; \
    virtual void *qt_metacast(const char *); \
    virtual int qt_metacall(QMetaObject::Call, int, void **); \
    QT_TR_FUNCTIONS \
private: \
    Q_OBJECT_NO_ATTRIBUTES_WARNING \
    Q_DECL_HIDDEN_STATIC_METACALL static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); \
    QT_WARNING_POP \
    struct QPrivateSignal {}; \
    QT_ANNOTATE_CLASS(qt_qobject, "")
```



### MOC

MOC编译器为QObject子类提供了一些实现元对象特性所需要的一些代码。就比如说信号，大家知识在类声明的时候声明了所需要的信号，在MOC编译时，会为信号添加函数定义。

[百度文库元对象系统](https://wenku.baidu.com/view/00c9dfa2cf22bcd126fff705cc17552707225e01.html)

[知乎](https://zhuanlan.zhihu.com/p/425820672)

[Qt内省机制](https://blog.csdn.net/wanywhn/article/details/80293581)

[QObject简单介绍](https://blog.csdn.net/aidem_brown/article/details/80236188)



## 3. 信号与槽

前面已经讲过了



## 4. 内存管理

### 1. 简介

C++中 new 和 delete 必须配对使用：delete少了，则内存泄露，多了麻烦更大。Qt中使用了new却很少delete，因为Qt实现了其独特的内存管理机制。

QObject 以对象树的形式组织起来。当为一个对象创建子对象时，子对象会自动地添加到父对象的children()列表中。父对象拥有子对象的所有权，比如父对象可以在自己的析构函数中删除它的孩子对象。使用findChild()或findChildren()通过名字和类型查询孩子对象。

```cpp
 QObject(QObject *parent = nullptr)
```

（1）QObject及其派生类的对象，如果其parent非nullptr，那么其parent析构时会析构该对象。

（2）父子关系：父对象、子对象、父子关系。这是Qt中所特有的，与类的继承关系无关，传递参数是与parent有关（基类、派生类，或父类、子类，这是对于派生体系来说的，与parent无关）。

### 2. 关联图

在Qt中，最基础和核心的类是：QObject，QObject内部有一个名为children的QObjectList列表，会保存所有子对象，还有一个指针parent，用来指向父对象，当自己析构时，会先把自己从parent列表中删除并且析构所有的children。

![img](assets/35081b7e738c4725bb7075189052f4d6.png)

### 3. 详解

#### 3.1 对象分配在栈上

当把对象分配到栈上时，内存会随着对象的生命周期而释放，非常安全！

```cpp
int main(int argc,char*argv[])
{
    QApplication a(argc,argv);

    QObject obj;

    qInfo()<<"hello Qt!";
    return a.exec();
}
```

#### 3.2 对象分配在堆上

##### 问题

当把对象分配到堆上时，如果忘记`delete`，内存就不会释放，会发生内存泄漏

```cpp
#include<QApplication>
#include<QDebug>
int main(int argc,char*argv[])
{
    QApplication a(argc,argv);

    QObject* obj = new QObject;

    qInfo()<<"hello Qt!";
    return a.exec();
}
```

##### 释放内存

+ 使用`delete`或者Qt提供的成员函数`deleteLater()`释放内存

```cpp
int main(int argc,char*argv[])
{
    QApplication a(argc,argv);

    QObject* obj = new QObject;
    
    //delete obj;				//①
    //obj->deleteLater();		//②

    qInfo()<<"hello Qt!";
    return a.exec();
}
```

+ 使用指定父对象的方式自动管理内存

```cpp
#include<QApplication>
#include<QDebug>

class MyObject:public QObject
{
public:
    MyObject(QObject* parent = nullptr)
        :QObject(parent)
        {
            qInfo()<<"MyObject created!";
        }
    ~MyObject()
    {
        qInfo()<<"MyObject destory!";
    }
};

int main(int argc,char*argv[])
{
    QApplication a(argc,argv);
    
    {
        MyObject parent;
        {
            MyObject* obj = new MyObject(&parent);
            //obj->deleteLater();
            //MyObject obj;
        }
    }
    
    qInfo()<<"hello Qt!";
    return a.exec();
}
```

### 4. 对象名

在Qt中可以给对象设置对象名，从而可以使用findChild()通过名称(和类型)查找对象；还可以通过findChildren()找到一组对象。

+ 设置对象名

  ```cpp
  void QObject::setObjectName(const QString &name);
  ```

+ 获取对象名

  ```cpp
  QString QObject::objectName() const;
  ```

+ 通过对象名查找对象

  ```cpp
  template <typename T>
  T findChild(const QString &name = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
  ```

  根据指定的名称name和指定的类型T(T可以是父类)查找子对象，如果没有这样的子对象，则返回nullptr；

  + 此示例返回名为“button1”的 parentWidget 的子 QPushButton，即使该按钮不是父级的直接子级：

    ```cpp
     QPushButton *button = parentWidget->findChild<QPushButton *>("button1");
    ```

  + 这个例子返回了parentWidget的QListWidget子组件:

    ```cpp
     QListWidget *list = parentWidget->findChild<QListWidget *>();
    ```

  + 这个例子返回了parentWidget(它的直接父元素)的一个名为"button1"的子QPushButton:

    ```cpp
     QPushButton *button = parentWidget->findChild<QPushButton *>("button1", Qt::FindDirectChildrenOnly);
    ```

  + 这个例子返回一个parentWidget的QListWidget子组件，它的直接父组件:

    ```cpp
     QListWidget *list = parentWidget->findChild<QListWidget *>(QString(), Qt::FindDirectChildrenOnly);
    ```

    

+ 通过类型查找对象

  ```cpp
   QList<T> findChildren(const QString &name = QString(), Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
   QList<T> findChildren(const QRegularExpression &re, Qt::FindChildOptions options = Qt::FindChildrenRecursively) const
  ```

  根据指定的名称name和指定的类型T(T可以是父类)查找子对象，如果没有这样的子对象，则返回nullptr；
  
  + 以下示例显示了如何查找名为 widgetname 的指定父 Widget 的子 Widget 列表：
  
    ```cpp
     QList<QWidget *> widgets = parentWidget.findChildren<QWidget *>("widgetname");
    ```
  
  + 这个例子返回了parentWidget的所有子QPushButton:
  
    ```cpp
     QList<QPushButton *> allPButtons = parentWidget.findChildren<QPushButton *>();
    ```
  
  + 这个例子返回所有与parentWidget直接关联的QPushButton:
  
    ```cpp
     QList<QPushButton *> childButtons = parentWidget.findChildren<QPushButton *>(QString(), Qt::FindDirectChildrenOnly);
    ```
  
    

## 5. 属性系统

>  The Property System

Qt提供了一个复杂的属性系统，类似于一些编译器供应商提供的属性系统。然而，作为一个独立于编译器和平台的库，Qt不依赖于像__property或[property]这样的非标准编译器特性。Qt解决方案可以在Qt支持的每一个平台上使用任何标准的c++编译器。它基于元对象系统，也通过信号和插槽提供对象间通信。

属性的行为类似于类数据成员，但它具有通过元对象系统访问的附加特性。我们先来看属性的基本使用，附加特性稍后再说QAQ！

### 获取/设置属性值

首先，咱们通过帮助文档可以知道，QObject类就只有一个`objectName`属性。

![image-20220820202124001](assets/image-20220820202124001.png)

那么我们就可以通过获取属性值的函数获取`objectName`的值。

```cpp
 qInfo()<<obj->property("objectName").toString();
```

同样我们可以通过修改属性值的函数修改`objectName`的值。

```cpp
obj->setProperty("objectName","OBJ");
```

QObject::setProperty() 也可用于在运行时向类的实例添加新属性。

当使用名称和值调用它时，如果QObject中存在具有给定名称的属性，并且给定值与属性的类型兼容，则将值存储在属性中，并返回true。

如果该值与属性的类型不兼容，则不会更改该属性，并返回 false。

但是如果具有给定名称的属性在 QObject 中不存在（即，如果它没有使用 Q_PROPERTY() 声明），具有给定名称和值的新属性会自动添加到 QObject，但 false 仍然回来。这意味着返回 false 不能用于确定是否实际设置了特定属性，除非您事先知道该属性已经存在于 QObject 中。

请注意，动态属性是在每个实例的基础上添加的，即它们被添加到 QObject，而不是 QMetaObject。通过将属性名称和无效的 QVariant 值传递给 QObject::setProperty()，可以从实例中删除属性。 QVariant 的默认构造函数构造了一个无效的 QVariant。



### 自己声明属性

除了通过`setProperty`动态添加属性之外，怎样才能在代码中，声明属性呢？

要声明属性，请在继承 QObject 的类中使用 Q_PROPERTY() 宏。

```css
 Q_PROPERTY(type name
            (READ getFunction [WRITE setFunction] |
             MEMBER memberName [(READ getFunction | WRITE setFunction)])
            [RESET resetFunction]
            [NOTIFY notifySignal]
            [REVISION int | REVISION(int[, int])]
            [DESIGNABLE bool]
            [SCRIPTABLE bool]
            [STORED bool]
            [USER bool]
            [BINDABLE bindableProperty]
            [CONSTANT]
            [FINAL]
            [REQUIRED])
```

属性的行为类似于类数据成员，但它具有通过元对象系统访问的附加特性。

+ 如果未指定 MEMBER 变量，则需要 READ 访问器函数。 它用于读取属性值。 理想情况下，const 函数用于此目的，它必须返回属性的类型或对该类型的 const 引用。 例如，QWidget::focus 是一个带有 READ 函数的只读属性，QWidget::hasFocus()。

+ WRITE 访问器函数是可选的。 它用于设置属性值。 它必须返回 void 并且必须只接受一个参数，该参数可以是属性的类型，也可以是指向该类型的指针或引用。 例如，QWidget::enabled 具有 WRITE 函数 QWidget::setEnabled()。 只读属性不需要 WRITE 函数。 例如，QWidget::focus 没有 WRITE 功能。

+ 如果未指定 READ 访问器函数，则需要 MEMBER 变量关联。 这使得给定的成员变量可读可写，而无需创建 READ 和 WRITE 访问器函数。 如果您需要控制变量访问，除了 MEMBER 变量关联之外，仍然可以使用 READ 或 WRITE 访问器函数。
+ RESET 功能是可选的。 它用于将属性设置回其特定于上下文的默认值。 例如，QWidget::cursor 有典型的 READ 和 WRITE 函数，QWidget::cursor() 和 QWidget::setCursor()，它还有一个 RESET 函数，QWidget::unsetCursor()，因为没有调用 QWidget:: setCursor() 可以表示重置为特定于上下文的光标。 RESET 函数必须返回 void 并且不带任何参数。
+ NOTIFY 信号是可选的。 如果已定义，则应指定该类中的一个现有信号，该信号在属性值更改时发出。 MEMBER 变量的 NOTIFY 信号必须采用零个或一个参数，该参数必须与属性的类型相同。 该参数将采用属性的新值。 NOTIFY 信号只应在属性真正被更改时发出，以避免在 QML 中不必要地重新评估绑定，例如。 当没有显式设置器的 MEMBER 属性需要时，Qt 会自动发出该信号。

+ REVISION 编号或 REVISION() 宏是可选的。 如果包含，它定义了要在 API 的特定修订版中使用的属性及其通知信号（通常用于暴露于 QML）。 如果不包含，则默认为 0。

+ DESIGNABLE 属性指示该属性是否应在 GUI 设计工具（例如 Qt Designer）的属性编辑器中可见。 大多数属性都是可设计的（默认为 true）。 有效值为真和假。

+ SCRIPTABLE 属性指示脚本引擎是否可以访问此属性（默认为 true）。 有效值为真和假。
+ STORED 属性指示该属性是否应该被认为是独立存在的，或者取决于其他值。 它还指示在存储对象的状态时是否必须保存属性值。 大多数属性是 STORED 的（默认为 true），但例如，QWidget::minimumWidth() 的 STORED 为 false，因为它的值只是从属性 QWidget::minimumSize() 的宽度分量中获取的，它是一个 QSize。

+ USER 属性指示该属性是被指定为该类的面向用户的属性还是用户可编辑的属性。 通常，每个类只有一个 USER 属性（默认为 false）。 例如，QAbstractButton::checked 是（可检查）按钮的用户可编辑属性。 请注意，QItemDelegate 获取和设置小部件的 USER 属性。

+ BINDABLE bindableProperty 属性表明该属性支持绑定，并且可以通过元对象系统 (QMetaProperty) 设置和检查与该属性的绑定。 bindableProperty 命名 QBindable<T> 类型的类成员，其中 T 是属性类型。 这个属性是在 Qt 6.0 中引入的。

+ CONSTANT 属性的存在表明属性值是常量。 对于给定的对象实例，常量属性的 READ 方法在每次调用时都必须返回相同的值。 对于对象的不同实例，该常数值可能不同。 常量属性不能有 WRITE 方法或 NOTIFY 信号。

+ FINAL 属性的存在表明该属性不会被派生类覆盖。 这在某些情况下可用于性能优化，但并非由 moc 强制执行。 必须注意永远不要覆盖 FINAL 属性。

+ REQUIRED 属性的存在表明该属性应该由该类的用户设置。 这不是由 moc 强制执行的，并且对于暴露给 QML 的类最有用。 在 QML 中，除非设置了所有 REQUIRED 属性，否则无法实例化具有 REQUIRED 属性的类。

可以继承 READ、WRITE 和 RESET 函数。 它们也可以是虚拟的。 当它们在使用多重继承的类中被继承时，它们必须来自第一个继承的类。

属性类型可以是 QVariant 支持的任何类型，也可以是用户定义的类型。 在此示例中，类 QDate 被认为是用户定义的类型。

```cpp
 Q_PROPERTY(QDate date READ getDate WRITE setDate)
```

因为QDate是用户定义的，所以必须在属性声明中包含<QDate>头文件。

**示例：**

```cpp
class MyObject:public QObject
{
    Q_OBJECT
    Q_PROPERTY(QString name READ getName WRITE setName RESET unsetName NOTIFY nameChanged)
public:
    MyObject(QObject*parent = nullptr)
    :QObject(parent){}

    QString getName()
    {
         qInfo()<<__FUNCTION__;
        return m_name;
    }
    void setName(const QString& name)
    {
        qInfo()<<__FUNCTION__;
        emit nameChanged(name);		//需要自己发射信号
        m_name = name;     
    }
    void unsetName()
    {
        qInfo()<<__FUNCTION__;
        m_name ="unknown";
    }
signals:
    void nameChanged(const QString&);
private:
    QString m_name;
};


int main(int argc,char*argv[])
{
   QApplication a(argc,argv);
   MyObject obj;

   QObject::connect(&obj,&MyObject::nameChanged,[](auto name)
                    {
                        qInfo()<<"slot:"<<name;
                    });
   //通过函数访问 
   obj.setName("maye");		
   qInfo()<<obj.getName();	//输出maye 
   obj.unsetName();			//把name重置为 unknown
    
    //通过属性接口访问 
   obj.setProperty("name","顽石");
   qInfo()<<obj.property("name").toString();	//输出"顽石"
   obj.setProperty("name",QVariant());			//把name重置为 unknown
    
    return a.exec();
}
```

在上面的代码中，使用属性“name”就相当于使用了成员变量m_name;而且通过属性接口访问或设置属性值时，也是通过自己写的函数实现的。



### 使用绑定属性

三种不同的类型可用于实现 可绑定属性:

+ QProperty
+ QObjectBindableProperty
+ QObjectComputedProperty

第一个是可绑定属性的通用类。后两个只能在QObject中使用。

有关更多信息(包括示例)，请参阅上面提到的类以及实现和使用可绑定属性的一般技巧。



## 6. 实时类型信息

### 何为内省

所谓内省是指面向对象语言的一种在运行期间查询对象信息的能力， 比如如果该语具有运行期间检查对象型别的能力，那么我们称它是型别内省（`type intropection`）的，型别内省可以用来实施多态。

C++的内省比较有限，它仅支持上面所说的型别内省， C++的型别内省是通过运行时类型识别（`RTTI`）(`Run-Time Type Information`)中的`typeid` 以及`dynamic_case`关键字来实现的，举例说明：

```cpp
// Dog 派生于 Animal, jump为虚函数  
if (Dog *pdog = dynamic_case<Animal*>(obj))     
{     
   p->cry();     
}     
//我们还可以通过typeid萃取到对象的型别信息，比如对象的名称   
std::cout << typeid(obj).name() << std::endl   
```

----

Qt拓展了C++的内省机制，（实际上，它并没有采用C++的RTTI),而是提供了更为强大的元对象(`meta object`)机制，来实现内省。接下来，就让我们看看，Qt是如何扩展c++内省机制的。

要深刻理解Qt的内省机制，首先理解`QObject`，`QObject`类是整个Qt对象模型的心脏，Qt对象模型最为核心的功能是提供一种无缝的对象通讯机制，即就是我们所熟知的信号和槽。`QObject`主要有三大职责： 内存管理、内省(`intropection`)与事件处理。本文将集中在在内省的讨论。以下代码介绍了`QObject`类提供的内省方法:

```cpp
//判断该类是否继承自指定的类
bool inherits(const char *className) const;

QWidget* w = new QWidget;
w.inherits("QObject");		//true
w.inherits("QWidget");		//false
```

让我们再来一下`QObject::inherits`方法的底层实现：

```cpp
inline bool inherits(const char *classname) const   
{ 
    return const_cast<QObject *>(this)->qt_metacast(classname) != 0; 
}  
```

原来，`QObject::inherits`是通过`qt_metacast()`这个虚函数实现的， 事实上每个`QObject`的派生类都必须实现`metaObject()`以及其他`qt_metacall()`方法，从而满足自省方法`className`, `inherits`等方法的调用（当然还有其他用途）。

而所有有关派生从`QObject`的子类中的内省方法无须有用户实现，用户只要在类中声明宏`Q_OBJECT`即可，Qt的元对象编译器（`moc`)负责实现派生`QObject`的子类中的内省方法。

```java
#define Q_OBJECT \
public: \
    QT_WARNING_PUSH \
    Q_OBJECT_NO_OVERRIDE_WARNING \
    static const QMetaObject staticMetaObject; \
    virtual const QMetaObject *metaObject() const; \
    virtual void *qt_metacast(const char *); \
    virtual int qt_metacall(QMetaObject::Call, int, void **); \
    QT_TR_FUNCTIONS \
private: \
    Q_OBJECT_NO_ATTRIBUTES_WARNING \
    Q_DECL_HIDDEN_STATIC_METACALL static void qt_static_metacall(QObject *, QMetaObject::Call, int, void **); \
    QT_WARNING_POP \
    struct QPrivateSignal {}; \
    QT_ANNOTATE_CLASS(qt_qobject, "")
```

此外，所有的`Qt widgets`类均继承自`QObject`, `QObject`所提供的`isWidgetType`自省方法可以很方便让`QObject`子对象查询自己是否是`Wideget`, 而且它会比 `qobject_cast<QWidget *>(obj)` 或者`obj->inherits`快很多。原因`qobject_cast()`和`inherits()`都是借助元对象系统来实现其功能的，`isWidgetType()`是`QObject`本身的标志位得以实现。

更多自省方法定义在[`QMetaObject`](#附录)。



### 总结

1. Qt是通过`QObject`、`QMetaObject`类实现其内省机制,
2. `QObject`暴露给用户的共有自省方法有`objectName()`, `inherits()`， `isWidgetType()`等
3. 大多数自省方法是`QObject`派发给`QMetaObject`实现 (e.g. `QMetaObject::className`)，元对象模型编译器`moc`负责自省方法的实现
4. 更多自省方法定义在`QMetaObject`，是为了信号槽通讯、事件派发等机制





# 附录

## QMetaObject

QMetaObject 类包含有关 Qt 对象的元信息。

##### 向类添加附加信息

Q_CLASSINFO()宏，它可用于将附加的<名称-值>对附加到类的元对象，例如：

```cpp
 Q_CLASSINFO("Version", "3.0.0")
```

然后通过`QMetaObject `以下几个函数访问类信息。

```cpp
 QMetaClassInfo classInfo(int index) const
 int classInfoCount() const
 int classInfoOffset() const
 const char *className() const
```



```cpp
QMetaMethod constructor(int index) const
 int constructorCount() const
 QMetaEnum enumerator(int index) const
 int enumeratorCount() const
 int enumeratorOffset() const
 int indexOfClassInfo(const char *name) const
 int indexOfConstructor(const char *constructor) const
 int indexOfEnumerator(const char *name) const
 int indexOfMethod(const char *method) const
 int indexOfProperty(const char *name) const
 int indexOfSignal(const char *signal) const
 int indexOfSlot(const char *slot) const
 bool inherits(const QMetaObject *metaObject) const
 QMetaType metaType() const
 QMetaMethod method(int index) const
 int methodCount() const
 int methodOffset() const
 QObject *newInstance(QGenericArgument val0 = QGenericArgument(nullptr), QGenericArgument val1 = QGenericArgument(), QGenericArgument val2 = QGenericArgument(), QGenericArgument val3 = QGenericArgument(), QGenericArgument val4 = QGenericArgument(), QGenericArgument val5 = QGenericArgument(), QGenericArgument val6 = QGenericArgument(), QGenericArgument val7 = QGenericArgument(), QGenericArgument val8 = QGenericArgument(), QGenericArgument val9 = QGenericArgument()) const
 QMetaProperty property(int index) const
 int propertyCount() const
 int propertyOffset() const
 const QMetaObject *superClass() const
 QMetaProperty userProperty() const
```

