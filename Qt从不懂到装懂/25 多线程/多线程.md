# 多线程

## 线程概念的起源

**1.1 单核 CPU**

在早期的单核 CPU 时代还没有线程的概念，只有进程。操作系统作为一个大的“软件”，协调着各个硬件（如CPU、内存，硬盘、网卡灯）有序的工作着。在双核 CPU 诞生以前，我们用的 Windows 操作系统依然可以一边用 word 写文档一边听着音乐，作为整个系统唯一可以完成计算任务的 CPU 是如何保证两个进程“同时进行”的呢？**时间片轮转调度**！

注意这个关键字「轮转」。每个进程会被操作系统分配一个时间片，即**每次被 CPU 选中来执行当前进程所用的时间。时间一到，无论进程是否运行结束，操作系统都会强制将 CPU 这个资源转到另一个进程去执行**。为什么要这样做呢？因为只有一个单核 CPU，假如没有这种轮转调度机制，那它该去处理写文档的进程还是该去处理听音乐的进程？无论执行哪个进程，另一个进程肯定是不被执行，程序自然就是无运行的状态。如果 CPU 一会儿处理 word 进程一会儿处理听音乐的进程，起初看起来好像会觉得两个进程都很卡，但是 CPU 的执行速度已经快到让人们感觉不到这种切换的顿挫感，就真的好像两个进程在“并行运行”。

![img](https://pic3.zhimg.com/80/v2-0ae120b1a3510dddaf3cf464895a0776_720w.jpg)

如上图所示，每一个小方格就是一个时间片，大约100ms。假设现在我同时开着 Word、QQ、网易云音乐三个软件，CPU 首先去处理 Word 进程，100ms时间一到 CPU 就会被强制切换到 QQ 进程，处理100ms后又切换到网易云音乐进程上，100ms后又去处理 Word 进程，如此往复不断地切换。**我们将其中的 Word 单独拿出来看，如果时间片足够小，那么以人类的反应速度看就好比最后一个处理过程，看上去就会有“CPU 只处理 Word 进程”的幻觉**。随着芯片技术的发展，CPU 的处理速度越来越快，在保证流畅运行的情况下可以同时运行的进程越来越多。

**1.2 多核 CPU**

随着运行的进程越来越多，人们发现进程的创建、撤销与切换存在着较大的时空开销，因此业界急需一种轻型的进程技术来减少开销。于是上世纪80年代出现了一种叫 SMP（Symmetrical Multi-Processing）的对称多处理技术，就是我们所知的线程概念。线程切换的开销要小很多，这是因为每个进程都有属于自己的一个完整虚拟地址空间，而线程隶属于某一个进程，与进程内的其他线程一起共享这片地址空间，基本上就可以利用进程所拥有的资源而无需调用新的资源，故对它的调度所付出的开销就会小很多。

![img](https://pic4.zhimg.com/80/v2-10425b0a0856632b913d445dbdfa4deb_720w.jpg)

以 QQ 聊天软件为例，上文我们一直都在说不同进程如何流畅的运行，此刻我们只关注一个进程的运行情况。如果没有线程技术的出现，当 QQ 这个进程被 CPU “临幸”时，我是该处理聊天呢还是处理界面刷新呢？如果只处理聊天，那么界面就不会刷新，看起来就是界面卡死了。**有了线程技术后，每次 CPU 执行100ms，其中30ms用于处理聊天，40ms用于处理传文件，剩余的30ms用于处理界面刷新，这样就可以使得各个组件可以“并行”的运行了**。于是乎我们可以提炼出两点关于多线程的适用场景：

- 通过使用多核 CPU 提高处理速度。
- 保证 GUI 界面流畅运行的同时可以执行其他计算任务。

## Qt线程操作

Qt的线程类为QThread，是独立于平台的线程操作类。

### 基本操作函数

```cpp
//获取当前线程对象地址
[static] QThread *QThread::currentThread()
//获取可在系统上运行的理想线程数。 这是通过查询系统中实际的和逻辑的处理器核数来完成的。 如果无法检测到处理器核数，则该函数返回1。 
[static] int QThread::idealThreadCount()
//强制当前线程休眠n毫秒。      
[static] void QThread::msleep(unsigned long msecs)   
//强制当前线程休眠n秒  
[static] void QThread::sleep(unsigned long secs)    
//强制当前线程休眠n微秒      
[static] void QThread::usleep(unsigned long usecs)  
//放弃执行当前线程， 把机会让给别的线程，注意，操作系统决定切换到哪个线程。  
[static] void QThread::yieldCurrentThread()    
```

### 使用线程

Qt 线程有多种有三种方式

#### 第一种：全局函数

QThread有两个静态成员函数create，创建一个新的QThread对象，它将使用参数args执行函数f。(必须在C++17及以上才可以使用)  

```cpp
[static] QThread *QThread::create(Function &&f, Args &&... args)
[static] QThread *QThread::create(Function &&f)
```

新线程没有启动——它必须通过显式调用start()来启动。 这允许您连接到它的信号，将QObjects移动到线程，选择新线程的优先级，等等。 函数f将在新线程中被调用。  

**注意：**不要对返回的QThread实例多次调用start(); 这样做将导致未定义的行为。 

例如：如果我们需要在保证ui界面正常响应时，使用死循环来输出递增的变量，这时就需要使用多线程了。

```cpp
auto fun = []()                                                  
{                                                                
    int i= 0;                                                    
    while(i<200)                                                 
    {                                                            
        QThread::msleep(20);                                     
                                                                 
        qDebug()<<"i"<<i++;                                      
    }                                                            
};                                                               
QThread *thr =  QThread::create(fun);                            
connect(thr,&QThread::started,this,[](){qDebug()<<"start";});    
connect(thr,&QThread::finished,this,[=](){thr->deleteLater();qDebug()<<"finished";});
thr->start();                                                    
```

#### 第二种：继承QThread

QThread类中有一个virtual函数QThread::run()，要创建一个新的线程，我们只需定义一个MyThread类，让其继承QThread，然后重新实现QThread::run()。

run函数是线程的起始点。 在调用start()之后，新创建的线程调用这个函数。 默认实现只是调用exec()。  

**MyThread.h**

```cpp
#include <QThread>
class MyThread : public QThread
{
    Q_OBJECT
public:
    explicit MyThread(QObject *parent = nullptr);
    ~MyThread();
protected:
    void run() override;
signals:

};
```

**MyThread.cpp**

```cpp
#include "mythread.h"
#include<QDebug>
MyThread::MyThread(QObject *parent)
    : QThread(parent)
{}
MyThread::~MyThread()
{
    qDebug()<<   "MyThread::~MyThread()";
}

void MyThread::run()
{
    int i= 0;
    while(i<200)
    {
        QThread::msleep(20);
        if(i==150)
            break;
        qDebug()<<"i"<<i++;
    }
}
```

**Widget.cpp**

```cpp
#include "widget.h"
#include<QDebug>
#include<QThread>

Widget::Widget(QWidget *parent)
    : QWidget(parent)
    , ui(new Ui::Widget)
{
    ui->setupUi(this);
    thr = new MyThread(this);
    connect(thr,&QThread::started,this,[](){qDebug()<<"start";});
    connect(thr,&QThread::finished,this,[](){qDebug()<<"finished";});
    thr->start();
}

Widget::~Widget()
{
    thr->quit();
    delete thr;

    delete ui;
}
```



#### 第三种：移动到线程

- 首先创建一个工作对象，需要注意不能指定父对象。
  Worket *worker = new Worker;
- 创建一个Qthread子线程对象
  QThread *thread = new QThread(this);
- 把我们的自定义线程类，加入到子线程（若是worker 指定了父对象，此处就会出错。）
  worker ->moveToThread(thread);
- 启动子线程，只是把线程开启了，并没有启动线程处理函数
  thread.start();
- 启动线程处理函数，必须通过signal - slot的方式。

```cpp
class Worker : public QObject
  {
      Q_OBJECT
  public slots:
      void doWork(const QString &parameter) {
          QString result;
          /* ... here is the expensive or blocking operation ... */
          emit resultReady(result);
      }

  signals:
      void resultReady(const QString &result);
  };

  class Controller : public QObject
  {
      Q_OBJECT
      QThread workerThread;
  public:
      Controller() {
          Worker *worker = new Worker;
          worker->moveToThread(&workerThread);
          connect(&workerThread, &QThread::finished, worker, &QObject::deleteLater);
          connect(this, &Controller::operate, worker, &Worker::doWork);
          connect(worker, &Worker::resultReady, this, &Controller::handleResults);
          workerThread.start();
      }
      ~Controller() {
          workerThread.quit();
          workerThread.wait();
      }
  public slots:
      void handleResults(const QString &);
  signals:
      void operate(const QString &);
  };
```

