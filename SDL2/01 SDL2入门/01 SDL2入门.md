## SDL 简介

### 什么是 SDL？

Simple DirectMedia Layer 是一个跨平台开发库，旨在通过 OpenGL 和 Direct3D 提供对音频、键盘、鼠标、游戏杆和图形硬件的低级访问。它被视频播放软件、模拟器和流行游戏使用，包括[Valve](http://valvesoftware.com/)的获奖目录和许多[Humble Bundle](https://www.humblebundle.com/)游戏。

SDL 正式支持 Windows、Mac OS X、Linux、iOS 和[Android](https://wiki.libsdl.org/Android)。可以在源代码中找到对其他平台的支持。

SDL 是用 C 编写的，在本机上与 C++ 一起使用，并且有适用于其他几种语言的绑定，包括 C# 和 Python。

SDL 2.0 在[zlib 许可](http://www.gzip.org/zlib/zlib_license.html)下分发。此许可证允许您在任何软件中自由使用 SDL。简单直接媒体层库 (SDL) 是一个通用 API，它提供对音频、键盘、鼠标、游戏杆、通过 OpenGL 的 3D 硬件以及跨多个平台的 2D 帧缓冲区的低级别访问。

### SDL 可以做什么？

**视频**

- 3D图形：SDL 可与 OpenGL API 或 Direct3D API 结合使用，用于 3D 图形
- 加速 2D 渲染 API：支持简单的旋转、缩放和 alpha 混合，所有这些都使用现代 3D API 加速，使用 OpenGL 和 Direct3D 支持加速
- 创建和管理多个窗口

**输入事件**

- 提供的事件和 API 函数用于：
  - 应用程序和窗口状态更改
  - 鼠标输入
  - 键盘输入
  - 操纵杆和游戏控制器输入
  - 多点触控手势
- 可以使用[SDL_EventState](https://wiki.libsdl.org/SDL_EventState) ()启用或禁用每个事件
- 事件在发布到内部事件队列之前通过用户指定的过滤器函数
- 线程安全事件队列

**力反馈**

- Windows、Mac OS X 和 Linux 支持力反馈

**音频**

- 设置8位和16位音频、单声道立体声或5.1环绕声的音频播放，如果硬件不支持格式，可选择转换
- 音频在单独的线程中独立运行，通过用户回调机制填充
- 专为定制软件混音器设计，但[SDL_mixer](http://www.libsdl.org/projects/SDL_mixer/)提供完整的音频/音乐输出库

**文件 I/O 抽象**

- 用于打开、读取和写入数据的通用抽象
- 对文件和内存的内置支持

**共享对象支持**

- 加载共享对象（Windows 上的 DLL，Mac OS X 上的 .dylib，Linux 上的 .so）
- 共享对象中的查找函数

**线程**

- 简单的线程创建API
- 简单线程本地存储API
- 互斥体、信号量和条件变量
- 无锁编程的原子操作

**计时器**

- 获取经过的毫秒数
- 等待指定的毫秒数
- 在单独的线程中创建与代码一起运行的计时器
- 使用高分辨率计数器进行分析

**CPU 特性检测**

- 查询CPU数量
- 检测 CPU 特性和支持的指令集

**大端小端支持**

- 检测当前系统的字节序
- 用于快速交换数据值的例程
- 读取和写入指定字节序的数据

**电池管理**

- 查询电源管理状态

### SDL 在哪些平台上运行？

**视窗**

- 使用 Win32 API 进行显示，利用 Direct3D 进行硬件加速
- 使用 DirectSound 和 XAudio2 作为声音

**Mac OS X**

- 使用 Cocoa 进行视频显示，利用 OpenGL 进行硬件加速
- 使用 Core Audio 播放声音

**Linux**

- 使用 X11 进行视频显示，利用 OpenGL 进行硬件加速
- 使用 ALSA、OSS 和 PulseAudio API 来处理声音

**IOS**

- 使用 UIKit 进行视频显示，利用 OpenGL ES 2.0 进行硬件加速
- 使用 Core Audio 播放声音

**安卓**

- 使用 JNI 接口进行视频显示，利用 OpenGL ES 1.1 和 2.0 进行硬件加速
- 对声音使用 JNI 音频回调



## 如何获取和安装 SDL

### SDL2库下载

+ [SDL2](https://libsdl.org/download-2.0.php)

+ [SDL2_image、SDL2_ttf、SDL2_mixer、SDL2_net](https://libsdl.org/projects/)

+ [SDL2_gfx 官网](https://www.ferzkopp.net/wordpress/2016/01/02/sdl_gfx-sdl2_gfx/)     [SDL2_gfx Github](https://github.com/topics/sdl2-gfx)

SDL 作为动态链接库。动态链接库包含 3 个部分：

- 头文件 (Library.h)
- 库文件（Windows 的Library.lib 或 *nix 的libLibrary.a）
- 二进制文件（Windows 的Library.dll 或*nix 的Library.so）

你的编译器需要能够在编译时找到头文件，以便它知道SDL 函数和结构是什么。可以将编译器配置为在 SDL 头文件所在的附加目录中进行搜索，或者将头文件与编译器附带的其余头文件一起放入。如果编译器提示找不到 SDL.h，则意味着头文件不在编译器查找头文件的位置。

在编译器编译所有源文件后，它必须将它们链接在一起。为了使程序正确链接，它需要知道所有函数的地址，包括 SDL 函数的地址。对于动态链接库，这些地址在库文件中。库文件具有导入地址表，因此您的程序可以在运行时导入函数。与头文件一样，您可以将编译器配置为在 SDL 库文件所在的附加目录中进行搜索，或者将库文件与编译器附带的其余库文件一起放入。您还必须告诉链接器链接到链接器中的库文件。如果链接器报错找不到-lSDL或SDL2.lib，它意味着库文件不在链接器寻找库文件的地方。 如果链接器报错了一个未定义的引用，这可能意味着它没有链接这个库。  

在您的程序被编译和链接之后，您需要能够在运行时链接到该库。为了运行动态链接的应用程序，您需要能够在运行时导入库二进制文件。当您运行程序时，您的操作系统需要能够找到库二进制文件。您可以将库二进制文件放在与可执行文件相同的目录中，也可以放在操作系统保存库二进制文件的目录中。

### SDL2 Visual studio2019配置



### 创建第一个窗口

现在你已经设置了 SDL，是时候制作一个在屏幕上显示的基本 SDL 图形应用程序了。

```c
//Using SDL and standard IO
#include <SDL.h>

//屏幕尺寸常量
const int SCREEN_WIDTH = 640;
const int SCREEN_HEIGHT = 480;
```

在源文件的顶部，我们包含了SDL.h头文件，这样才能使用SDL提供的函数。接着声明了我们要渲染的窗口的宽度和高度。  



```c
int main( int argc, char* args[] )
{
    //我们要渲染到的窗口
    SDL_Window* window = NULL;
    
    //窗口包含的表面
    SDL_Surface* screenSurface = NULL;

    //初始化SDL
    if( SDL_Init( SDL_INIT_VIDEO ) == -1 )
    {
        SDL_Log("SDL could not initialize! SDL_Error: %s\n", SDL_GetError() );
    }
```

主函数与我们平常写的无参版本不同，主函数的实参必须是一个整数，后跟一个char*数组，返回类型必须是一个整数，这一点很重要。 任何其他类型的main函数都会导致对main的引用未定义。 SDL需要这种类型的main，以便与多个平台兼容。  

然后声明我们将要创建的SDL窗口。 接下来，我们有一个屏幕SDL表面。 SDL表面就是一个二维图像。 2D图像可以从文件中加载，也可以是窗口中的图像。 在本例中，它将是我们在屏幕上看到的窗口内部的图像。  

在声明窗口和屏幕表面之后，我们初始化SDL。 你不能在没有初始化SDL的情况下调用任何SDL函数。 因为我们所关心的是使用SDL的视频子系统，所以我们将只给它传递SDL_INIT_VIDEO标志。  

当出现错误时，SDL_Init返回-1。 当有一个错误产生时，我们想打印到控制台发生了什么，此时用SDL_Log往控制台输出信息，这个函数和printf类似。

SDL_GetError返回SDL函数产生的最新错误。  SDL_GetError是一个非常有用的函数。 无论什么时候出了问题，你都需要知道原因。 SDL_GetError将让您知道任何SDL函数内部是否发生了任何错误。  

```c
	else
    {
        //创建窗口
        window = SDL_CreateWindow( "SDL Tutorial", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, SCREEN_WIDTH, SCREEN_HEIGHT, SDL_WINDOW_SHOWN );
        if( window == NULL )
        {
            printf( "Window could not be created! SDL_Error: %s\n", SDL_GetError() );
        }
```

如果SDL成功初始化，我们将需要使用SDL_CreateWindow创建一个窗口。 第一个参数设置窗口的标题:  

![image-20211231154845965](assets/image-20211231154845965.png)

接下来的两个参数定义创建窗口的x和y位置。 因为我们不关心它是在哪里创建的，我们只是把SDL_WINDOWPOS_UNDEFINED作为x和y的位置，让系统自由选择。  

接下来的两个参数定义窗口的宽度和高度。 最后一个参数是创建标志。 SDL_WINDOW_SHOWN确保在创建窗口时显示该窗口。  

如果有错误，SDL_CreateWindow返回NULL。 如果没有窗口，我们将错误打印到控制台。  



```c
		else
		{
			//获取窗口表面
			screenSurface = SDL_GetWindowSurface(window);

			//填充表面为红色
			SDL_FillRect(screenSurface, NULL, SDL_MapRGB(screenSurface->format,0xFF,0,0));
			
			//更新表面
			SDL_UpdateWindowSurface(window);

			//等待2秒
			SDL_Delay(2000);
		}
	}
```

如果窗口被成功创建，我们想要得到窗口的表面，以便我们可以绘制到它。 调用SDL_GetWindowSurface函数即可获得窗口表面。

为了保持本教程的简单，我们在这里所要做的就是使用SDL_FillRect将窗口的表面填充为红色。 不要太担心这个函数。 本教程只关注如何弹出窗口。  

关于渲染，需要知道的一件重要的事情是，仅仅因为你在屏幕表面绘制了一些东西并不意味着你会看到它。 在你完成所有的绘制之后，你需要更新窗口，让它显示你绘制的所有内容。 调用SDL_UpdateWindowSurface就可以做到这一点。  

如果我们所做的是创建窗口，填充它，并更新它，我们将看到的是窗口闪烁一秒钟，然后关闭。 为了防止它消失，我们将调用SDL_Delay。 SDL_Delay将等待给定的毫秒数。 一毫秒是千分之一秒。 这意味着上面的代码将使窗口等待2000 /1000秒或2秒。  

需要注意的重要一点是，当SDL延迟时，它不能接受来自键盘或鼠标的输入。 当您运行这个程序时，如果它没有响应，请不要惊慌。 我们没有给它处理鼠标和键盘的代码。  

```cpp
	//销毁窗口
	SDL_DestroyWindow(window);

	//退出SDL子系统
	SDL_Quit();
	
	return 0;
}
```

在窗口延迟2秒后，我们将销毁窗口以释放它的内存。 这也将处理我们从它获得的SDL_Surface。 在所有东西都被释放之后，我们退出SDL并返回0以终止程序。 

 

### SDL2教程

+ [SDL2 维基文档](https://wiki.libsdl.org/wiki/index)

+ [SDL2各种教程集合](https://wiki.libsdl.org/Tutorials)

