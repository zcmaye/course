# 子查询

子查询（Subquery）是指嵌套在其他查询中的查询。子查询可以出现在 `SELECT`、`INSERT`、`UPDATE`、`DELETE` 语句中，也可以出现在 `WHERE` 或 `HAVING` 子句中。子查询的结果可以作为外部查询的条件或数据源。

SQL 中子查询的使用大大增强了  SELECT  查询的能力，因为很多时候查询需要从结果集中获取数据，或者需要从同一个表中先计算得出一个数据结果，然后与这个数据结果（可能是某个标量，也可能是某个集合）进行比较。

## 需求分析

### 实际问题

如下图，我们要求谁的薪资比ALLEN的薪资高：

![](assets/1.1.png)

如何求出所有比ALLEN的薪资更高的薪资呢？

+ 我们先使用学过的知识来解决问题

  ```sql
  #方式一：分开查询
  SELECT sal FROM emp WHERE ename='ALLEN';	-- 4600
  SELECT ename,sal FROM emp WHERE sal > 4600;	
  
  #方式二：自连接
  SELECT e2.ename,e2.sal
  FROM emp e1 JOIN emp e2
  ON e2.sal > e1.sal		-- 非等值连接
  WHERE e1.ename = 'ALLEN';
  
  +-------+---------+
  | ename | sal     |
  +-------+---------+
  | JONES | 6975.00 |
  | BLAKE | 5850.00 |
  | CLARK | 5450.00 |
  | SCOTT | 6000.00 |
  | KING  | 8000.00 |
  | FORD  | 6000.00 |
  +-------+---------+
  6 rows in set (0.00 sec)
  ```

+ 使用子查询

  ```sql
  SELECT ename,sal
  FROM emp
  WHERE sal > 
  (
  	SELECT sal 
  	FROM emp 
  	WHERE ename='ALLEN'
  );
  
  +-------+---------+
  | ename | sal     |
  +-------+---------+
  | JONES | 6975.00 |
  | BLAKE | 5850.00 |
  | CLARK | 5450.00 |
  | SCOTT | 6000.00 |
  | KING  | 8000.00 |
  | FORD  | 6000.00 |
  +-------+---------+
  6 rows in set (0.00 sec)
  ```

可以看到，使用子查询的方式更加直观，逻辑清晰。

## 子查询分类

子查询的分类方式多样，核心分类标准包括“**返回结果类型**”、“**与主查询的关联方式**”、“**子查询位置**”等。不同分类的子查询适用场景不同，掌握分类逻辑是灵活运用的前提。

### 按返回结果分类

我们按子查询返回的结果，将子查询分为**标量子查询**、**单行子查询** 、 **多行子查询** 、**表子查询**。

+ 标量子查询(scalar subquery)：返回1行1列一个值
+ 单行子查询(row subquery)：返回的结果集是 1 行 N 列
+ 多行子查询(列子查询)(column subquery)：返回的结果集是 N 行 1列
+ 表子查询(table subquery)：返回的结果集是 N 行 N 列

### 按相关性分类

该分类依据子查询是否依赖主查询的字段值来划分，决定了子查询的执行方式（单次执行或多次执行）。

+ 非相关子查询（Non-Correlated Subquery）：子查询不依赖主查询的任何字段，可独立执行，执行结果一次性传递给主查询，仅需执行一次。
+ 相关子查询(Correlated Subquery)：子查询中使用了主查询的表字段，导致子查询的执行依赖主查询的每一行数据——主查询遍历一行数据，子查询就会使用该行的字段值执行一次，两者形成“行级关联”。

### 按子查询位置分类

该分类从子查询的执行时机和作用逻辑出发。子查询可以位于一下子句中：

+ SELECT子句：适用于标量子查询
+ FROM子句：派生表、内联视图
+ WHERE子句：
  + 比较运算符后
  + IN/NOT IN后
  + EXISTS/NOT EXISTS后
  + ANY/SOME/ALL后
+ HAVING子句

## 标量子查询

### 规范

- 必须返回**单行单列**
- 可使用所有标量运算符（= 、!= 、<>、< 、<=、> 、>=、算术运算符）
- NULL处理需谨慎

### 示例

#### SELECT子句中

+ 查询每个员工的编号、姓名、职位、入职日期、薪资以及公司平均薪资

```sql
SELECT empno,ename,job,hiredate,sal,
(SELECT AVG(sal) FROM emp) AS company_avg_sal	-- 每条记录都添加公司平均薪资
FROM emp;
```

+ 查询每个员工的编号、姓名、职位、入职日期、薪资以及公司平均薪资，还需要输出一个薪资级别，如果员工薪资大于等于公司平均薪资的1.3倍，则为Hight，小于等于公司平均薪资的0.7倍则为Low，否则为Normal。

```sql
SELECT empno,ename,job,hiredate,sal,
(SELECT AVG(sal) FROM emp) AS company_avg_sal,
  CASE
    WHEN sal >= (SELECT AVG(sal) FROM emp) * 1.3 THEN 'High'
    WHEN sal <= (SELECT AVG(sal) FROM emp) * 0.7 THEN 'Low'
    ELSE 'Normal'
  END
FROM emp;
```

#### WHERE子句中

+ 查询出基本工资比ALLEN低的全部员工信息

```mysql
SELECT * FROM emp WHERE sal<(SELECT sal FROM emp WHERE ename='ALLEN');
```

+ 查询基本工资高于公司平均工资的全部员工信息

```mysql
SELECT * FROM emp WHERE sal > (SELECT AVG(sal) FROM emp);
```

+ 查询出与ALLEN从事同一工作，并且基本工资高于员工编号为7521的全部员工信息

```mysql
SELECT * FROM emp WHERE job=(SELECT job FROM emp WHERE ename='ALLEN') 
AND sal>(SELECT sal FROM emp WHERE empno=7521)
#把ALLEN自己去掉
AND ename<>'ALLEN';
```

#### HAVING子句中

+ 查询部门编号、员工人数、平均工资，并且要求这些部门的平均工资高于公司平均薪资。

```mysql
SELECT deptno,COUNT(deptno) cnt,AVG(sal) avgsal 
FROM emp 
GROUP BY deptno
HAVING avgsal>
(
	SELECT AVG(sal) FROM emp
);
```

+ 查询出所有部门中平均工资最高的部门名称及平均工资

```mysql
-- 连接查询LIMIT
SELECT dname,AVG(sal) dept_avg_sal
FROM emp 
LEFT JOIN dept d
ON emp.deptno = d.deptno
GROUP BY d.deptno
ORDER BY dept_avg_sal DESC
LIMIT 1;

-- 子查询
SELECT dname,ROUND(AVG(sal),2) dept_avg_sal
FROM emp 
LEFT JOIN dept d
ON emp.deptno = d.deptno
GROUP BY d.deptno
HAVING dept_avg_sal >= (
  SELECT MAX(avg_sal) FROM (
      SELECT AVG(sal) avg_sal FROM emp GROUP BY deptno
    ) AS t
);
```



## 行子查询

### 规范

- 必须返回**单行多列**
- 可使用所有标量运算符（= 、!= 、<>、< 、<=、> 、>=、IN、NOT IN）
- NULL处理需谨慎

### 示例

+ 查询与SCOTT从事统一工作且工资相同的员工信息

```mysql
SELECT * FROM emp WHERE (job,sal) = (SELECT job,sal FROM emp WHERE ename='SCOTT')
AND ename<>'SCOTT';
```

+ 查询编号和薪资都小于SCOTT的员工信息

```sql
SELECT * FROM emp WHERE (empno,sal) < (SELECT empno,sal FROM emp WHERE ename='SCOTT');
```



## 列子查询

### 规范

- 必须返回**多行单列**

+ 在使用多行子查询需要使用多行比较操作符：

| 操作符   | 含义                                                         |
| -------- | ------------------------------------------------------------ |
| [NOT] IN | 等于列表中的任意一个                                         |
| ANY      | 需要和单行比较操作符一起使用(>、<、=、<>...)，与子查询结果中任何一个值比较，一个成立 |
| ALL      | 需要和单行比较操作符一起使用(>、<、=、<>...)，和子查询返回的所有值比较，同时成立 |
| SOME     | 实际上是ANY的别名，作用相同，一般用ANY                       |

### IN操作符

IN 运算符用来判断表达式的值是否位于给出的列表中；如果是，返回值为 1，否则返回值为 0。

NOT IN 的作用和 IN 恰好相反，NOT IN 用来判断表达式的值是否不存在于给出的列表中；如果不是，返回值为 1，否则返回值为 0。

+ 查询出与每个部门中最低工资相同的员工信息
  + 按照部门分组，统计每个部门的最低工资
  + 根据最低工资查询出员工信息

```mysql
SELECT * FROM emp WHERE sal IN(SELECT MIN(sal) FROM emp GROUP BY deptno)
AND deptno IS NOT NULL;
```



### ANY操作符

ANY关键字是一个MySQL运算符，如果子查询条件中ANY的比较结果为TRUE，则它会**返回布尔值TRUE** 。

+ 查询工资比任何管理工资都要高的员工信息
  + 查找出每个管理的薪资
  + 每个员工的薪资与每个管理的薪资比较

```mysql
SELECT * FROM emp WHERE sal > ANY(
SELECT MIN(sal) FROM emp WHERE job='MANAGER' GROUP BY deptno);
```



### ALL操作符

ALL关键字是一个MySQL运算符，如果子查询条件中ALL的比较结果为TRUE，则它会**返回布尔值TRUE** 。

+ 案例同ANY操作符



## 表子查询

### 规范

- 必须返回**多行多列**，也就是说返回一个表格
- 可使用所有标量运算符（= 、!= 、<>、< 、<=、> 、>=、IN、NOT IN）
- NULL处理需谨慎

### WHERE子句中

用在WHERE子句中，主要用于 IN、NOT IN。

+ 在emp表中，得到与10号部门任何一个员工入职日期和领导相同的员工信息(用在where子句中)

```mysql
SELECT * FROM emp
WHERE (DATE_FORMAT(hiredate,'%Y'),mgr) IN (SELECT DATE_FORMAT(hiredate,'%Y') hiryear,mgr FROM emp WHERE deptno=10);
```

### FROM子句中

用在FROM子句中，主要用于作为数据源(派生表)，也就说把子查询的结果当做一张表，来连接查询。

+ 查询出每个部门的编号、名称、位置、部门人数、平均工资（用在from子句中）

```mysql
#以前学的多表联合查询
SELECT d.deptno,d.dname,d.loc,COUNT(e.deptno),ROUND(AVG(sal),2) FROM
dept d LEFT JOIN emp e
ON e.deptno=d.deptno
GROUP BY d.deptno,d.dname,d.loc;

#用子查询联合查询
SELECT dept.deptno,dept.dname,dept.loc,d.count,d.avgsal 
FROM dept LEFT JOIN (
    SELECT deptno,COUNT(*) count,AVG(sal) avgsal  
    FROM emp 
    GROUP BY deptno
) d
ON dept.deptno=d.deptno;
```

+ 查询出所有在'SALESMAN'部门工作的员工编号、姓名、基本工资、奖金、职位、雇佣日期、部门的最高和最低工资。(where和from子句同时使用)

```mysql
#1,方法一
SELECT e.empno,e.ename,e.sal,e.comm,e.job,e.hiredate,minsal,maxsal,e.deptno  
FROM emp e JOIN (
    SELECT deptno,MIN(sal) minsal,MAX(sal) maxsal 
    FROM emp 
    GROUP BY deptno
) td
ON e.deptno=td.deptno AND e.deptno=(SELECT deptno FROM dept WHERE dname='SALESMAN');

#2方法二
SELECT e.empno,e.ename,e.sal,e.comm,e.job,e.hiredate,minsal,maxsal,e.deptno  
FROM emp e JOIN (
    SELECT deptno,MIN(sal) minsal,MAX(sal) maxsal 
    FROM emp 
    GROUP BY deptno
	HAVING deptno=(SELECT deptno FROM dept WHERE dname='SALESMAN')
) td
ON e.deptno=td.deptno;
```


+ 查询出比‘ALLEN’或‘CLACRK’薪资多的所有员工的编号、姓名、基本工资、部门名称、领导姓名、部门人数。

```mysql
SELECT e.empno,e.ename,e.sal,d.dname,me.ename 领导,temp.count 
FROM emp e 
JOIN dept d ON e.deptno=d.deptno
LEFT JOIN emp me ON e.mgr=me.empno
JOIN (
      SELECT deptno,COUNT(deptno) count 
      FROM emp e 
      GROUP BY deptno
    ) temp 
ON temp.deptno=e.deptno
AND e.sal > ANY(
        SELECT sal 
        FROM emp 
        WHERE ename IN('ALLEN','CLARK')
    )
AND e.ename NOT IN('ALLEN','CLARK');
```



+ 列出公司各个部门的经理(假设每个部门只有一个经理，job为‘MANAGER’)的姓名、薪资、部门名称、部门人数、部门平均工资。

```mysql
SELECT e.ename,e.sal,d.dname,temp.count,temp.avgsal
FROM emp e 
JOIN dept d ON e.deptno=d.deptno 
JOIN (
    SELECT deptno, COUNT(deptno) count,AVG(sal) avgsal 
    FROM emp 
    GROUP BY deptno
  ) temp 
ON temp.deptno=e.deptno
AND job='MANAGER';
```

+ 查询出所有薪资高于公司平均薪资的员工编号、姓名、基本工资、职位、雇佣日期、所在部门名称、部门位置、上级领导姓名、工资等级、部门人数、平均工资、平均服务年限。

```mysql
SELECT e.empno,e.ename,e.sal,e.job,e.hiredate,d.dname,d.loc,me.ename 领导,s.grade,temp.count,temp.avgsal,temp.avgyear
FROM emp e 
JOIN dept d ON e.deptno=d.deptno AND e.sal>(SELECT AVG(sal) FROM emp)
LEFT JOIN emp me ON e.mgr=me.empno
JOIN salgrade s ON e.sal BETWEEN s.losal AND s.hisal
JOIN (
  SELECT deptno,COUNT(deptno) count,AVG(sal) avgsal,AVG(TIMESTAMPDIFF(MONTH,hiredate,CURDATE())/12) avgyear 
  FROM emp 
  GROUP BY deptno
) temp 
ON temp.deptno=e.deptno;
```

**TIMESTAMPDIFF** 是 MySQL 中用于计算两个日期或日期时间值之间差值的函数。

```sql
SELECT TIMESTAMPDIFF(MONTH,hiredate,CURDATE()) FROM emp;
```

## 在SELECT字句中使用子查询

+ 查询出公司每个部门的编号、名称、位置、部门人数、平均工资

```mysql
#1多表查询
SELECT d.deptno,d.dname,d.loc,COUNT(e.deptno),AVG(e.sal)
FROM emp e RIGHT JOIN dept d
ON e.deptno=d.deptno
GROUP BY deptno;
#2
SELECT d.deptno,d.dname,d.loc,temp.cnt,temp.avgsal
FROM dept d LEFT JOIN (SELECT deptno,COUNT(deptno) cnt,AVG(sal) avgsal FROM emp GROUP BY deptno) temp
ON d.deptno=temp.deptno;
#3 关联子查询
SELECT d.deptno,d.dname,d.loc,
(SELECT COUNT(deptno) FROM emp WHERE deptno=d.deptno) cnt,
(SELECT AVG(sal) FROM emp WHERE deptno=d.deptno) avgsal
FROM dept d;
```

## 相关子查询

如果子查询的执行依赖外部查询，通常情况下都是因为子查询中的表用到了外部的表，并进行了条件关联，因此每执行一次外部查询，子查询都要重新计算一次，这样的子查询就成为关联子查询。

### 概念

子查询的执行依赖于外层查询的当前行值，外层查询每处理一行，子查询就执行一次。

![image-20220321154622164](assets/image-20220321154622164.png)

### WHERE中的相关子查询

#### 比较运算符相关

+ 查找工资高于部门平均工资的员工

```sql
SELECT * FROM emp e
WHERE sal >= (
    SELECT AVG(sal) 
    FROM emp 
    WHERE deptno = e.deptno
);
```

+ 查找入职时间早于部门经理的员工

```sql
SELECT * FROM emp e
WHERE hiredate > (
    SELECT hiredate 
    FROM emp 
    WHERE empno = e.mgr 
    AND deptno = e.deptno
);
```

+ 查询一个员工都没有的部门信息

```SQL
SELECT * FROM dept d
WHERE  (
  SELECT COUNT(*)
  FROM emp
  WHERE deptno = d.deptno
) = 0;
```

#### EXISTS/NOT EXISTS 相关查询

在SQL中提供了EXISTS操作符用于判断子查询是否有数据返回。如果子查询中有数据返回，EXISTS结构返回true，否则返回false。

+ 查询工作地点在`ChangSha`的所有员工

```sql
SELECT * FROM emp e
WHERE EXISTS(
  SELECT 1
  FROM dept
  WHERE deptno = e.deptno
  AND loc = 'ChangSha'
);
```

+ 查询公司领导者

```sql
SELECT * FROM emp e
WHERE EXISTS (
    SELECT 1 
    FROM emp 
    WHERE mgr = e.empno
);
```

+ 查询一个员工都没有的部门信息

```sql
SELECT * FROM dept d
WHERE NOT EXISTS (
  SELECT 1
  FROM emp
  WHERE deptno = d.deptno
);
```

### SELECT中的相关子查询

+ 查询每个员工的编号、姓名、职位、入职日期、薪资以及**部门**平均薪资

```sql
SELECT empno,enamE,job,hiredate,sal,
(SELECT AVG(sal) FROM emp WHERE deptno = e.deptno) dept_avg_sal, -- 部门平均薪资
(SELECT AVG(sal) FROM emp) company_avg_sal -- 公司平均薪资
FROM emp e;
```

+ 查询部门信息以及每个部门对应员工数

```sql
SELECT deptno,dname,loc,
(
    SELECT COUNT(*) 
    FROM emp 
    WHERE deptno = d.deptno
)
FROM dept d;
```



### 理解关联子查询

初学SQL的人都会觉得SQL的关联子查询难以理解，为什么？这是有原因的。

关联子查询的执行逻辑和通常的SELECT语句的执行逻辑完成不一样。这就是SQL关联子查询难以理解的原因。

我们首先来看看正常情况下SELECT的书写顺序和执行顺序：

```mysql
-- 书写顺序 SELECT > FROM > WHERE > GROUP BY > HAVING > ORDER BY
-- 执行顺序 FROM > WHERE > GROUP BY > HAVING > SELECT > ORDER BY
```

#### 正常查询分析

+ 查询每个部门的人数

```mysql
SELECT deptno,COUNT(*) cnt
FROM emp
WHERE sal>4000
GROUP BY deptno
HAVING cnt >1
ORDER BY deptno;
```

1、FROM emp：从指定的表获取数据

2、WHERE sal>1000：筛选工资大于1000的

3、GROUP BY：以deptno进行分组

4、HAVING cnt>1：刷选出组内数据大于1的

5、SELECT deptno,COUNT(*) cnt：查询结果集中的指定字段

6、最后以deptno进行排序

#### 关联子查询分析

+ 查询员工中工资大于本部门平均工资的员工的部门编号、姓名、薪资

```mysql
SELECT e.ename,e.sal,e.deptno 
FROM emp e 
WHERE e.sal > 
(
    SELECT avg(sal) 
    FROM emp 
    WHERE deptno =  e.deptno  
    GROUP BY deptno
) ORDER BY deptno;
```

**记住，关联子查询和正常的SELECT语句完全不同。**

1、先执行主查询：

```sql
> SELECT e.ename,e.sal,e.deptno FROM emp e;

+-------+---------+--------+
| ename | sal     | deptno |
+-------+---------+--------+
| KING  | 8000.00 |     10 |
| JONES | 6975.00 |     20 |
| SCOTT | 6000.00 |     20 |
| FORD  | 6000.00 |     20 |
| ALLEN | 4600.00 |     30 |
| BLAKE | 5850.00 |     30 |
+-------+---------+--------+
6 rows in set (0.00 sec)
```

2、从主查询的结果中依次取deptno值，通过`WHERE deptno =  e.deptno`传入子查询，子查询变成:

```mysql
> SELECT avg(sal) FROM emp WHERE deptno =  20  GROUP BY deptno;

+-------------+
| avg(sal)    |
+-------------+
| 5375.000000 |
+-------------+
1 row in set (0.00 sec)
```

然后讲子查询的结果返回给主查询：

```mysql
> SELECT e.ename,e.sal,e.deptno FROM emp e WHERE e.sal > 5375 ORDER BY deptno;

+-------+---------+--------+
| ename | sal     | deptno |
+-------+---------+--------+
| CLARK | 5450.00 |     10 |
| KING  | 8000.00 |     10 |
| JONES | 6975.00 |     20 |
| SCOTT | 6000.00 |     20 |
| FORD  | 6000.00 |     20 |
| BLAKE | 5850.00 |     30 |
+-------+---------+--------+
6 rows in set (0.00 sec)
```

> 值得注意的是：这里并不会拿着5375去与emp表中所有的记录的sal去比较，应该是与拿到的记录的sal比较(也就是从主查询的结果中依次取deptno所在的记录)
>
> 因为只有这样效率才会高，否则每一次都全表扫描，效率会非常低！

3、重复第二步过程，即可获取最终结果集。
