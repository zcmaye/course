# 数据管理

## 插入(INSERT)数据

在 MySQL 中，`INSERT INTO` 语句用于向表中添加新记录，可插入单行、多行或通过查询结果插入数据。

### 插入单行数据

#### 省略列名

插入数据时，可以不用写插入的字段名，但顺序必须与表定义一致。插入语法如下：

```sql
INSERT INTO 表名 VALUES(value1，value2...);  
```

例如，向emp表中插入一条记录：

```sql
INSERT INTO emp VALUES (8888,'maye','CLERK',7369,'2019-09-19',6000,NULL,20);
```

如果表中有自增主键列，可省略该列，MySQL 会自动生成值。

#### 指定列名

指定列名适用于只为部分列赋值，未指定的列将使用默认值。插入语法如下：

```mysql
INSERT INTO 表名 (字段1，字段2...) VALUES	(value1，value2...);  
```

例如，向emp表中再插入一条记录：

```sql
INSERT INTO emp(empno,ename,job,mgr,hiredate,sal,comm,deptno)
VALUES (7777,'宏定义','CLERK',7369,'2024-06-04',4000,NULL,20);
```

### 批量插入多行数据

批量插入多行数据能一次性插入多条记录，可提升性能。插入语法如下：

```mysql
INSERT INTO 表名 (字段1，字段2...) VALUES	
								(value1，value2...),
								(value1，value2...),
								...;  
								
INSERT INTO 表名 VALUES	
				(value1，value2...),
				(value1，value2...),
				...;  								
```

例如，给40号部门插入多个员工：

```sql
INSERT INTO emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) VALUES
(1001,'张三','SALESMAN',7839,'2024-10-15',10000,NULL,40),
(1002,'李四','SALESMAN',1001,'2024-11-15',8000,NULL,40),
(1003,'王五','SALESMAN',1001,'2024-12-15',7500,NULL,40),
(1004,'赵六','SALESMAN',1001,'2025-01-15',7000,NULL,40);
```

### 从查询结果插入

从查询结果插入可将一个表的查询结果直接插入到另一个表。插入语法如下：

```sql
INSERT INTO 表名 SELECT filed_list FROM...
```

+ 我们先来**创建**一张名为`myemp`的表：

```sql
CREATE TABLE  myemp (
	empno		SMALLINT  PRIMARY KEY,
	ename		VARCHAR(10),
	job			VARCHAR(9),
	mgr			SMALLINT,
	hiredate	DATE,
	sal			DECIMAL(7,2),
	comm		SMALLINT,
	deptno		SMALLINT
);
```

+ 然后将`emp`表中的所有数据插入到`myemp`表中去：

```sql
INSERT INTO myemp SELECT * FROM emp;
```

这样`myemp`表中的数据就和emp表中的数据一样了。

+ 当然也可以写上条件甚至多表查询，比如将所有职位为`SALESMAN`的员工插入到myemp表中：

```sql
INSERT INTO myemp SELECT * FROM emp WHERE job = 'SALESMAN';
```

报错了！！`1062 - Duplicate entry '1001' for key 'myemp.PRIMARY'`，因为我们的表中empno字段是主键，也就是说不允许重复不允许为空！！所以才会提示`1001`重复了。

我们可以先把表删除掉从新创建或者直接使用如下SQL语句：

```sql
mysql> TRUNCATE myemp;
Query OK, 0 rows affected (0.35 sec)
```

然后再执行上面的插入语句，即可成功插入：

```sql
mysql> INSERT INTO myemp SELECT * FROM emp WHERE job = 'SALESMAN';

Query OK, 8 rows affected (0.05 sec)
Records: 8  Duplicates: 0  Warnings: 0
```

查询一下myemp表：

```sql
mysql> SELECT * FROM myemp;
+-------+--------+----------+------+------------+----------+------+--------+
| empno | ename  | job      | mgr  | hiredate   | sal      | comm | deptno |
+-------+--------+----------+------+------------+----------+------+--------+
|  1001 | 张三   | SALESMAN | 7839 | 2024-10-15 | 10000.00 | NULL |     40 |
|  1002 | 李四   | SALESMAN | 1001 | 2024-11-15 |  8000.00 | NULL |     40 |
|  1003 | 王五   | SALESMAN | 1001 | 2024-12-15 |  7500.00 | NULL |     40 |
|  1004 | 赵六   | SALESMAN | 1001 | 2025-01-15 |  7000.00 | NULL |     40 |
|  7499 | ALLEN  | SALESMAN | 7698 | 2011-02-20 |  4600.00 |  300 |     30 |
|  7521 | WARD   | SALESMAN | 7698 | 2011-02-22 |  4250.00 |  500 |     30 |
|  7654 | MARTIN | SALESMAN | 7698 | 2011-09-28 |  4250.00 | 1400 |     30 |
|  7844 | TURNER | SALESMAN | 7698 | 2011-09-08 |  4500.00 |    0 |     30 |
+-------+--------+----------+------+------------+----------+------+--------+
8 rows in set (0.00 sec)
```

### 特殊插入方式

这些特殊插入方式，都需要检测数据是否存在重复，也就是说，插入的记录中有字段必须是主键或者唯一键！

#### 忽略插入(INSERT IGNORE INTO)

**INSERT IGNORE** 语句用于在插入数据时**忽略**重复的记录，从而避免因主键或唯一键冲突而导致的错误。

```sql
mysql> INSERT IGNORE INTO emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) VALUES
    -> (1001,'张三','SALESMAN',7839,'2024-10-15',10000,NULL,40),
    -> (1005,'周三','SALESMAN',1001,'2024-11-15',8000,NULL,40);
    
Query OK, 1 row affected, 1 warning (0.06 sec)
Records: 2  Duplicates: 1  Warnings: 1
```

因为`1001`主键冲突，所以插入失败，产生了警告，但不报错；`1005`这条记录插入成功！

#### 替换插入(REPLACE INTO)

**INSERT REPLACE** 语句用于在插入数据时**替换**重复的记录，从而避免因主键或唯一键冲突而导致的错误。

```sql
mysql> REPLACE INTO emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) VALUES
    -> (1001,'张三','CLERK',7839,'2024-10-15',10000,NULL,20);
    
Query OK, 2 rows affected (0.06 sec)
```

`2 rows affected`有两行收到影响是因为，删除旧行（1 行）+ 插入新行（1 行）= 2 行受影响。

如果不存在重复记录，则和`INSERT INTO`的行为一致，也就是直接插入：

```sql
REPLACE INTO emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) VALUES
(1006,'谭sir','CLERK',7839,'2024-10-15',10000,NULL,20);
```

#### 更新插入(ON DUPLICATE KEY UPDATE)

**ON DUPLICATE KEY UPDATE** 语句用于在插入数据时**替换**重复的字段，从而避免因主键或唯一键冲突而导致的错误。

> 如果表中存在该记录，则按新的数据进行修改，不存在则插入。（与replace into的区别在于：replace是完全替换成新的数据记录，而更新插入是修改不同的字段数据，新纪录中没有的部分依然采用老记录中的字段数据。）

```sql
mysql> INSERT INTO emp(empno,ename,job,mgr,hiredate,sal,comm,deptno) VALUES
    -> (1006,'谭sir','HELLO',7839,'2024-10-15',9000,NULL,30)
    -> ON DUPLICATE KEY UPDATE sal= VALUES(sal),deptno = VALUES(deptno);
Query OK, 2 rows affected, 2 warnings (0.10 sec)
```

这样`1006`的薪资就修改为9000，部门修改为30了；至于职位，因为没有在`ON DUPLICATE KEY UPDATE`后面指定，则不会被修改。

## 更新(UPDATE)数据

在 MySQL 中，使用 **UPDATE** 语句可以修改或更新表中的数据。**UPDATE** 语句的基本语法如下：

```mysql
UPDATE table_name
SET column1 = value1, column2 = value2,...
[WHERE condition]
[ORDER BY ...]
[LIMIT ...];
```

语法说明如下：

- `table_name`：用于指定要更新的表名称。
- `SET` 子句：用于指定表中要修改的列名及其列值。其中，每个指定的列值可以是表达式，也可以是该列对应的默认值。如果指定的是默认值，可用关键字 DEFAULT 表示列值。
- `WHERE` 子句：可选项。用于限定表中要修改的行。若不指定，则修改表中所有的行。
- `ORDER BY` 子句：可选项。用于限定表中的行被修改的次序。
- `LIMIT` 子句：可选项。用于限定被修改的行数。

### 更新字段

+ 将张三(员工编号为1001)的薪资修改为9800元，并且每个月都有500元的奖金：

  ```sql
  mysql> UPDATE emp SET sal=9800,comm=500 WHERE empno=1001;
  
  Query OK, 1 row affected (0.04 sec)
  Rows matched: 1  Changed: 1  Warnings: 0
  ```

+ 将40号部门所有工资大于7000的，员工薪资下调1000元：

  ```sql
  mysql> UPDATE emp SET sal = sal - 1000 WHERE deptno=40 AND sal>7000;
  
  Query OK, 3 rows affected (0.05 sec)
  Rows matched: 3  Changed: 3  Warnings: 0
  ```

+ 将所有奖金为NULL或为0的员工的奖金更新为薪资的10%：

  ```sql
  mysql> UPDATE emp SET comm = sal * 0.1 WHERE comm IS NULL OR comm=0;
  
  Query OK, 18 rows affected (0.04 sec)
  Rows matched: 18  Changed: 18  Warnings: 0
  ```

### 子查询更新

在MySQL中，**UPDATE**语句经常与子查询（subquery）结合使用，以便根据其他表中的数据或复杂条件来更新表中的记录。子查询可以在UPDATE语句的SET或WHERE子句中使用，但需要注意的是，更新的表不能在SET和WHERE子句中用于子查询，这可能会导致错误。

#### 非相关子查询

以下是一个使用子查询的UPDATE语句的例子，它展示了如何在不违反MySQL规则的情况下正确地执行更新操作：

+ 将部门人数少于5个的所有员工的奖金修改为薪资的20%。

```sql
mysql> UPDATE emp SET comm = sal * 0.2
    -> WHERE deptno IN (
    ->   SELECT deptno FROM emp GROUP BY deptno HAVING COUNT(*) < 5
    -> );
    
ERROR 1093 (HY000): You can't specify target table 'emp' for update in FROM clause
```

为什么报错了呢？因为更新的表不能在SET和WHERE子句中用于子查询，这可能会导致错误。说人话<font color=red>不能边用select查出同一表中的某些值，再update这个表(在同一语句中)</font>

那如何解决这个错误呢？我们可以将这个子查询在套一层子查询：

```sql
mysql> UPDATE emp SET comm = sal * 0.2
    -> WHERE deptno IN (
    ->   SELECT * FROM (
    ->     SELECT deptno FROM emp GROUP BY deptno HAVING COUNT(*) < 5
    ->   )t
    -> );
    
Query OK, 7 rows affected (0.00 sec)
Rows matched: 7  Changed: 7  Warnings: 0
```

或者使用连接查询实现：

```sql
mysql> UPDATE emp JOIN(
    ->  SELECT deptno FROM emp GROUP BY deptno HAVING COUNT(*) < 5
    -> )t ON emp.deptno = t.deptno
    -> SET comm = sal * 0.2;
    
Query OK, 3 rows affected (0.05 sec)
Rows matched: 7  Changed: 3  Warnings: 0
```

+ 将所有编号(empno)以`10`开头并且以`10`开头员工数量大于2的部门的所有员工姓名前面加上`hr_`前缀：

```sql
-- 首先查询以10开头的员工信息
SELECT * FROM emp WHERE empno LIKE '10%';

-- 然后查询不同部门中以10开头的员工的编号和人数
SELECT empno,deptno,COUNT(*) OVER(PARTITION BY deptno) cnt FROM emp WHERE empno LIKE '10%';

-- 最后结合更新语句
UPDATE emp SET ename=CONCAT('hr_',ename) WHERE empno IN (
  SELECT empno FROM (
    SELECT empno,deptno,COUNT(*) OVER(PARTITION BY deptno) cnt FROM emp WHERE empno LIKE '10%'
  )t
  WHERE t.cnt > 2
);
```

#### 相关更新

使用相关子查询依据一个表中的数据更新另一个表的数据。

+ 在emp中增加一个dname字段，数据为员工对应的部门名称。

  + 先添加字段

  ```mysql
  mysql> ALTER TABLE emp ADD  dname VARCHAR(20);
  
  Query OK, 0 rows affected (0.18 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  ```
  
  + 再更新数据
  
  ```mysql
  mysql> UPDATE emp e
      -> SET dname=(
      ->         SELECT dname FROM dept d
      ->         WHERE e.deptno = d.deptno
      ->     );
  Query OK, 22 rows affected (0.07 sec)
  Rows matched: 22  Changed: 22  Warnings: 0
  ```
  



## 删除(DELETE)数据

`DELETE` 语句用于**删除 MySQL 表中的记录**，可配合 `WHERE` 条件精确控制删除范围，避免误删全表数据。删除语法如下：

```mysql
DELETE FROM table_name
[WHERE condition]
[ORDER BY ...]
[LIMIT row_count];
```

语法说明：

- `table_name`：指定要删除数据的表名。
- `ORDER BY` 子句：可选项。表示删除时，表中各行将按照子句中指定的顺序进行删除。
- `WHERE` 子句：可选项。表示为删除操作限定删除条件，若省略该子句，则代表删除该表中的所有行。
- `LIMIT` 子句：可选项。用于告知服务器在控制命令被返回到客户端前被删除行的最大值。

### 单表条件删除

+ 删除姓名为`张三`的员工：

```sql
mysql> DELETE FROM emp WHERE ename = '张三';
Query OK, 1 row affected (0.05 sec)
```

### 子查询删除

+ 删除所有在 `OPERATIONS`部门且入职日期早于 `2024-12-01` 的员工：

```sql
mysql> DELETE FROM emp WHERE empno IN (
    ->   SELECT empno FROM emp e JOIN dept d ON e.deptno= d.deptno
    ->   WHERE d.dname = 'OPERATIONS' AND hiredate < '2024-12-01'
    -> );
ERROR 1093 (HY000): You can't specify target table 'emp' for update in FROM clause
```

哦豁，报错了，不过这报错我们在更新那里学过了，修改一下即可！

**子查询方式：**

```sql
mysql> DELETE FROM emp WHERE empno IN (
    ->   SELECT * FROM(
    ->     SELECT empno FROM emp e JOIN dept d ON e.deptno= d.deptno
    ->     WHERE d.dname = 'OPERATIONS' AND hiredate < '2024-12-01'
    ->   )t
    -> );
Query OK, 2 rows affected (0.03 sec)
```

**多表连接查询方式：**

```sql
mysql> WITH tmp AS(
    ->   SELECT empno FROM emp e JOIN dept d ON e.deptno= d.deptno
    ->   WHERE d.dname = 'OPERATIONS' AND hiredate < '2024-12-01'
    -> )
    -> DELETE emp FROM emp JOIN tmp ON emp.empno = tmp.empno;
Query OK, 2 rows affected (0.04 sec)
```

多表删除语法有点奇怪，如下：

```sql
DELETE delete_table_name	-- delete_table_name 要删除的表的别名
FROM table1 JOIN table2     -- table1、table2连接查询的两个表
ON condition				-- condition连接条件
```

其实上面的写法还可以简化一下：

```sql
mysql> DELETE e
    -> FROM emp e
    -> INNER JOIN dept d ON e.deptno = d.deptno
    -> WHERE d.dname = 'OPERATIONS'
    -> AND e.hiredate < '2024-12-01';
Query OK, 0 rows affected (0.00 sec)
```

或者使用EXISTS:

```sql
mysql> DELETE FROM emp e
    -> WHERE EXISTS (
    ->   SELECT 1
    ->   FROM dept d
    ->   WHERE d.deptno = e.deptno
    ->     AND d.dname = 'OPERATIONS'
    -> )
    -> AND e.hiredate < '2024-12-01';
Query OK, 0 rows affected (0.00 sec)
```

# 表管理

## 基础知识

### 表的基本概念

在MySQL数据库中，表是一种很重要的数据库对象，是组成数据库的基本元素，由若干个字段组成，主要用来实现存储数据记录。表的操作包含创建表、查看表、删除表和修改表，这些操作是数据库对象的表管理中最基本、最重要的操作。
通过本节的学习，可以掌握在数据库中操作表，内容包含:

+ 表的相关概念;
+ 表的基本操作:创建、查看、更新和删除; 
+ 表的使用策略。

表是包含数据库中所有数据的数据库对象。数据在表中的组织方式与在电子表格中相似，都是按行和列的格式组织的。其中每一行代表一条唯一的记录，每一列代表记录中的一个字段，如下图所示。

![image-20220303204715202](assets/image-20220303204715202.png)

### 标识符命名规范

1. 数据库名、表名不得超过30个字符，变量名限制为29个
2. 只能包含大写、小写、数字字符以及下划线
3. 同一个MySQL软件中，数据库不能同名；同一个库中，表不能重名；同一个表中，字段不能重名
4. 不能和保留字、函数名冲突
5. 保值字段名和类型的一致性：假如某个字段在一个表里面是整型，那在另一个表里面可就别变成字符串了

### MySQL中的数据类型

| 类型             | 具体类型                                                     |
| ---------------- | ------------------------------------------------------------ |
| 整数类型         | TINYINT、SMALLINT、MEDIUMINT、INT(或INTEGER)、BIGINT         |
| 浮点类型         | FLOAT、DOUBLE                                                |
| 定点数类型       | DECIMAL                                                      |
| 位类型           | BIT                                                          |
| 日期时间类型     | YEAR、TIME、DATE、DATETIME、TIMESTAMP                        |
| 文本字符串类型   | CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT          |
| 枚举类型         | ENUM                                                         |
| 集合类型         | SET                                                          |
| 二进制字符串类型 | BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB、LONGBLOB      |
| json类型         | JSON对象、JSON数组                                           |
| 空间数据类型     | 单值：GEOMETRY、POINT、LINESTRING、POLYGON<br>集合：MULTPOINT、MULTILINESTRING、MULTIPOLGON、GEOMTRYCOLLECTION |

其中，常用的几类类型介绍如下：

| 类型          | 描述                                                         |
| ------------- | ------------------------------------------------------------ |
| INT           | 4个字节                                                      |
| CHAR(size)    | 定长字符数据，若未指定，默认为一个字符，最大长度255          |
| VARCHAR(size) | 可变字符数据，更具字符串实际长度保存，必须指定长度           |
| FLOAT(M,D)    | 单精度，4个字节。M=整数位+小数位，D=小数位（D<=M<=255,0<=D<=30）,默认M+D<=6 |
| DOUBLE(M,D)   | 双精度，8个字节。D<=M<=255,0<=D<=30，默认M+D<=15             |
| DECIMAL(M,D)  | 高精度，M+2个字节。D<=M<=65,0<=D<=30,默认最大取值范围和DOUBLE一样 |
| DATE          | 日期类型，格式‘YYY-MM-DD’                                    |
| BLOD          | 二进制心事的长文本数据，最大可达4G                           |
| TEXT          | 长文本数据，最大可达4G                                       |

## 创建表

创建表需要指定表名、字段名及其数据类型，并可以添加约束条件。创建表的方式有好几种，我们一起来学习它们。

### 常规创建

创建表的基本语法如下：

```mysql
CREATE TABLE [IF NOT EXISTS] 表名(
	字段名 数据类型 [CONSTRAINT] [DEFAULT value] [COMMENT 注释]，
    字段名 数据类型 [CONSTRAINT] [DEFAULT value] [COMMENT 注释]，
    ...
    字段名 数据类型 [CONSTRAINT] [DEFAULT value] [COMMENT 注释]
);
```

例如，创建一个用户表：

```mysql
CREATE TABLE user(
    id INT COMMENT '用户ID',
    username VARCHAR(20) COMMENT '用户名',
    password VARCHAR(128) COMMENT '用户密码',
    create_at DATETIME COMMENT '创建时间',
    is_active BOOLEAN COMMENT '用户是否启用'
);
```

> 注意：`BOOLEAN`并不是原生支持的类型，而是通过`TINYINT`来实现的。`TINYINT`是一个占用1字节的小整数，通常约定使用`0`表示`false`，`1`表示`true`。

接下来插入数据测试一下：

```sql
mysql> INSERT INTO user VALUES(1,'admin','admin',NOW(),TRUE);
Query OK, 1 row affected (0.05 sec)
```

没问题，那如果我只插入一部分数据，没有指定数据的字段将会是什么值呢？

```sql
mysql> INSERT INTO user(username,`password`) VALUES('maye','123456');
Query OK, 1 row affected (0.04 sec)
```

查看一下数据：

```sql
mysql> SELECT * FROM user;
+------+----------+----------+---------------------+-----------+
| id   | username | password | create_at           | is_active |
+------+----------+----------+---------------------+-----------+
|    1 | admin    | admin    | 2025-12-17 18:04:14 |         1 |
| NULL | maye     | 123456   | NULL                |      NULL |
+------+----------+----------+---------------------+-----------+
2 rows in set (0.00 sec)
```

我们发现，没有指定数据的字段默认值都是NULL，那如果我想要修改默认值应该如何处理呢？在创建表时，给字段指定默认值即可！

让我们创建一个图书表：

```sql
CREATE TABLE book(
    id INT COMMENT '图书ID',
    bname VARCHAR(20) COMMENT '图书名',
    author VARCHAR(128) COMMENT '图书作者',
    price DOUBLE DEFAULT 0 COMMENT '图书价格',
    pub_date DATE DEFAULT '2024-06-04' COMMENT '出版时间',
    create_at DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间'
);
```

插入图书试试：

```sql
mysql> INSERT INTO book(id,bname,author)
    -> VALUES
    -> (1,'西游记','吴承恩'),
    -> (2,'水浒传','施耐庵'),
    -> (3,'红楼梦','曹雪芹'),
    -> (4,'三国演义','罗贯中');
Query OK, 4 rows affected (0.04 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

看看数据，发现确实没有指定数据的字段，自动使用了默认值：

```cpp
mysql> SELECT * FROM book;
+------+----------+--------+-------+------------+---------------------+
| id   | bname    | author | price | pub_date   | create_at           |
+------+----------+--------+-------+------------+---------------------+
|    1 | 西游记   | 吴承恩 |     0 | 2024-06-04 | 2025-12-17 18:15:22 |
|    2 | 水浒传   | 施耐庵 |     0 | 2024-06-04 | 2025-12-17 18:15:22 |
|    3 | 红楼梦   | 曹雪芹 |     0 | 2024-06-04 | 2025-12-17 18:15:22 |
|    4 | 三国演义 | 罗贯中 |     0 | 2024-06-04 | 2025-12-17 18:15:22 |
+------+----------+--------+-------+------------+---------------------+
4 rows in set (0.00 sec)
```

### 基于其他表创建

在MySQL中，可以根据已有的表创建一个新表，有几种常见的方法。以下是详细介绍：

#### 使用CREATE TABLE LIKE

这种方法允许你创建一个与现有表结构相同的新表。新表将包含与原始表相同的列、数据类型、索引和约束，但不包含数据。例如：

```sql
mysql> CREATE TABLE new_book LIKE book;
Query OK, 0 rows affected (0.22 sec)
```

这将创建一个名为`new_book`的新表，其结构与`book`相同，但新表中不会包含原始表中的数据。

#### 使用CREATE TABLE AS SELECT

这种方法允许你使用SELECT语句将数据从一个表复制到新表中。新表将具有与原始表相同的结构，并包含复制的数据。例如：

```sql
mysql> CREATE TABLE new_book_1 AS SELECT * FROM book;
Query OK, 4 rows affected (0.22 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

这将创建一个名为`new_book_1`的新表，并将`book`中的所有数据复制到新表中。新表的结构将与原始表相同，并包含数据。

#### 使用CREATE TEMPORARY TABLE

这种方法与`CREATE TABLE AS SELECT`类似，但创建的是一个临时表。临时表在会**话结束时会自动删除**。例如：

```sql
mysql> CREATE TEMPORARY TABLE tmp_book AS SELECT * FROM book;
Query OK, 4 rows affected (0.00 sec)
Records: 4  Duplicates: 0  Warnings: 0
```

也可以手动指定字段名：

```sql
CREATE TEMPORARY TABLE tmp_test(
	id INT,
	name VARCHAR(20)
);

INSERT INTO tmp_test VALUE(1,'hello'),(2,'world');

SELECT * FROM tmp_test;
```

> 通过`SHOW TABLES;`是查看不到临时表的，没有办法可以查看

### 查看表结构

创建表后，需通过工具查看表结构（如字段类型、约束、存储引擎），MySQL 提供两种高频方法，按需选择。

#### DESC/DESCRIBE

*desc* 是 *describe* 的缩写，用于查看数据库表的结构和详细信息。通过使用 *desc 表名* 命令，可以显示表的状态，包括列名、各个列的类型、主外键、默认值等信息。

```mysql
DESC/DESCRIBE table_name;
```

DESC为DESCRIBE的简写形式，更为方便。

```sql
mysql> DESCRIBE user;

+-----------+--------------+------+-----+---------+-------+
| Field     | Type         | Null | Key | Default | Extra |
+-----------+--------------+------+-----+---------+-------+
| id        | int          | YES  |     | NULL    |       |
| username  | varchar(20)  | YES  |     | NULL    |       |
| password  | varchar(128) | YES  |     | NULL    |       |
| create_at | datetime     | YES  |     | NULL    |       |
| is_active | tinyint(1)   | YES  |     | NULL    |       |
+-----------+--------------+------+-----+---------+-------+
5 rows in set (0.00 sec)
```

**结果解析：**

+ Field：字段名；
+ Type：数据类型（如varchar(20)、double(8,2)）；
+ Null：是否允许为空（YES= 允许，NO= 不允许）；
+ Key：索引类型（PRI= 主键，UNI= 唯一索引）；
+ Default：默认值；
+ Extra：额外信息（如AUTO_INCREMENT自增）。

#### SHOW COLUMS

**SHOW COLUMNS** 语句用于显示表中所有列的信息。这个命令非常有用，当你需要查看表的结构或者列的详细信息时。使用 **SHOW COLUMNS** 可以快速获取字段名、类型、是否允许NULL、键类型、默认值等信息。

语法如下：

```sql
SHOW [FULL] COLUMNS FROM table_name;
```

+ 当省略FULL时，和使用`DESC`查看表结构一样；
+ 当使用FULL时，显示的信息更加详细。

```sql
mysql> SHOW FULL COLUMNS FROM user;
+-----------+--------------+--------------------+-...-+---------------------------------+--------------+
| Field     | Type         | Collation          | ... | Privileges                      | Comment      |
+-----------+--------------+--------------------+-...-+---------------------------------+--------------+
| id        | int          | NULL               | ... | select,insert,update,references | 用户ID       |
| username  | varchar(20)  | utf8mb4_0900_ai_ci | ... | select,insert,update,references | 用户名       |
| password  | varchar(128) | utf8mb4_0900_ai_ci | ... | select,insert,update,references | 用户密码     |
| create_at | datetime     | NULL               | ... | select,insert,update,references | 创建时间     |
| is_active | tinyint(1)   | NULL               | ... | select,insert,update,references | 用户是否启用 |
+-----------+--------------+--------------------+-...-+---------------------------------+--------------+
5 rows in set (0.00 sec)
```

#### SHOW CREATE TABLE

`SHOW CREATE TABLE`适用于需要了解**详细建表语句、存储引擎、字符编码**的场景（DESC 无法查看这些信息），推荐用`\g或\G`格式化输出，更易读。

```mysql
SHOW CREATE TABLE table_name;
```

如下，查看一下user表：

```sql
mysql> SHOW CREATE TABLE user\g
+-------+-------------------------------------------------------------------------------------------------------------------+
| Table | Create Table                                                                                                      |
+-------+-------------------------------------------------------------------------------------------------------------------+
| user  | CREATE TABLE `user` (
  `id` int DEFAULT NULL COMMENT '用户ID',
  `username` varchar(20) DEFAULT NULL COMMENT '用户名',
  `password` varchar(128) DEFAULT NULL COMMENT '用户密码',
  `create_at` datetime DEFAULT NULL COMMENT '创建时间',
  `is_active` tinyint(1) DEFAULT NULL COMMENT '用户是否启用'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci                                                          |
+-------+-------------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
```

`\g`格式输出的不是很好看，使用`\G`更加方便：

```sql
mysql> SHOW CREATE TABLE user\G
*************************** 1. row ***************************
       Table: user
Create Table: CREATE TABLE `user` (
  `id` int DEFAULT NULL COMMENT '用户ID',
  `username` varchar(20) DEFAULT NULL COMMENT '用户名',
  `password` varchar(128) DEFAULT NULL COMMENT '用户密码',
  `create_at` datetime DEFAULT NULL COMMENT '创建时间',
  `is_active` tinyint(1) DEFAULT NULL COMMENT '用户是否启用'
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci
1 row in set (0.00 sec)
```

## 修改表结构

当业务需求变化时（如新增字段、修改字段长度），需用ALTER TABLE修改表结构。核心是 “按需调整，不破坏现有数据”，支持 4 类常见操作。

### 增加列(字段)

给已有表新增字段，可指定字段位置（默认加在最后一列）。语法格式如下：

```sql
-- COLUMN关键字可选，FIRST=加在第一列，AFTER 字段名=加在指定字段后
ALTER TABLE 表名 ADD [COLUMN] 字段名 字段类型 [FIRST|AFTER 已有字段名];
```

**追加字段**

给emp表新增一个dname字段，并放在已有字段的后面：

```mysql
ALTER TABLE emp ADD dname VARCHAR(10);
```

**将字段添加到第一列**

```mysql
ALTER TABLE table_name ADD [COLUMN] 字段名 数据类型 FIRST;
```

 **在指字段之后添加新字段**

把字段1 添加到字段2之后：

```mysql
ALTER TABLE table_name ADD [COLUMN] 字段名1 数据类型 AFTER 字段名2;
```

### 删除列(字段)

删除表中冗余字段，**会永久删除该字段的所有数据**，操作前务必确认字段已无用。

```mysql
ALTER TABLE table_name DROP [COLUMN] 字段名;
```

### 修改列(字段)

修改字段的数据类型、长度、默认值或位置（**不能重命名字段**），需确保新类型兼容现有数据。语法格式如下：

```sql
ALTER TABLE 表名 MODIFY [COLUMN] 字段名 新数据类型 [DEFAULT 默认值][FIRST|AFTER 已有字段名];
```

**修改字段的数据类型**

```mysql
ALTER TABLE table_name MODIFY [COLUMN] 字段名 数据类型;
```

**修改字段的顺序**

```mysql
ALTER TABLE table_name MODIFY [COLUMN]	字段名 数据类型 FIRST;
ALTER TABLE table_name MODIFY [COLUMN]	字段名1 数据类型 AFTER 字段名2;	
```

+ 第一个语句：把字段移动到第一个
+ 第二个语句：把字段1 移动到字段2之后

### 修改列名

需同时指定 “旧列名、新列名、新数据类型”（即使数据类型不变，也需重新写），用于优化字段名规范性。

```mysql
ALTER TABLE table_name CHANGE [COLUMN] 旧字段名 新字段名 数据类型;
```

如果数据类型和原来的数据类型一样，则只会修改字段名，如果数据类型不同，则同时会修改数据类型。

## 修改表名

当表名不符合命名规范（如emp改为myemp）时，可通过两种方法重命名，推荐用RENAME TABLE（支持多表批量重命名）。

### RENAME TABLE

官方推荐方式，支持一次重命名多个表，语法简洁。语法规则如下。

```mysql
RENAME TABLE <旧表名> TO <新表名>[,旧表名2 TO 新表名2]
```

**范例：**

```mysql
RENAME memp TO myemp,myemp1 TO memp1;
```

可以同时修改多个表的表名。

### ALTER TABLE

仅支持单表重命名，适用于 MySQL 5.0 之前的旧版本，现在较少使用。语法规则如下：

```mysql
ALTER TABLE <旧表名> RENAME [TO] <新表名>;
```

只能对一张表的表名进行修改。

**范例：**

```mysql
ALTER TABLE myemp RENAME memp;
```

## 删除表

当表完全不再使用时（如测试表、废弃业务表），可删除表。**删除表会永久删除表结构和所有数据，且无法回滚**，务必谨慎。

```mysql
DROP TABLE [IF EXISTS] table_name[,表1,表2...];
```

`IF EXISTS`：表存在则删除，不存在则忽略（推荐，避免报错）



# 数据库管理

## 创建和管理数据库

### 创建数据库

+ 方式1：创建数据库

  ```mysql
  CREATE DATABASE 数据库名;
  ```

+ 方式2：创建数据库并指定字符集

  ```mysql
  CREATE DATABASE 数据库名 CHARACTER SET "uft8";
  ```

+ 方式3：判断数据库是否已经存在，不存在则创建（推荐）

  ```mysql
  CREATE DATABASE IF NOT EXISTS 数据库名;
  ```

  > 注意：数据库不能改名。一些可视化工具可以改名，它是创建新库，然后把所有表复制到新库，再把旧库删掉完成的。

数据库创建完成之后，可以通过`SHOW CREATE DATABASE 数据库名;`查看创建数据库时使用的语句。

### 使用数据库

+ 查看当前连接中有哪些数据库

```mysql
SHOW DATABASES;
```

+  切换数据库

在多个数据库之间切换

```mysql
USE 数据库名;
```

+ 查看当前使用的数据库

```mysql
SHOW DATABASE();
-- 或者
SELECT DATABASE() FROM DUAL;
```

+ 查看指定数据库所有表

```mysql
-- 查看指定数据库所有表
SHOW TABLES FROM 数据库名;
-- 查看当前正在使用的数据库中的表
SHOW TABLES;
```

### 修改数据库

修改数据库字符集

```mysql
ALTER DATABASE 数据库名 CHARACTER SET 字符集;	#比如 gbk、utf8
#查看默认字符集
SHOW VARIABLES LIKE '%character%';
#查看所有字符集
SHOW CHARSET;
```

### 删除数据库

+ 直接删除

  ```mysql
  DROP DATABASE 数据库名;
  ```

+ 如果数据库存在则删除，否则报一个警告(不会报错)

  ```mysql
  DROP DATABASE IF EXISTS 数据库名;
  ```
