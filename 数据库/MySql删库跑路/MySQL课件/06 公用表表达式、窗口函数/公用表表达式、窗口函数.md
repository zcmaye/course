# 公用表表达式

公用表表达式（或通用表表达式）简称为CTE（Common Table Expressions）。CTE是一个命名的临时结果集，作用范围是当前语句，可以在查询中多次引用。所以，可以考虑代替子查询，CTE是处理复杂查询时的理想选择。

依据语法结构和执行方式的不同，公用表表达式分为 `普通公用表表达式` 和`递归公用表达式`2 种。

## 普通公用表表达式

### 语法

普通CTE的语法结构如下：

```mysql
WITH cte_name[(alias,...)] AS (
   SELECT 查询语句
)
SELECT * FROM cte_name;
```

普通公用表表达式类似于子查询，不过，跟子查询不同的是，它可以被多次引用，而且可以被其他的普通公用表达式所引用。

### 示例

比如，我们在子查询用写的一个在FROM子句中的案例：

+ 查询出每个部门的编号、名称、位置、部门人数、平均工资（用在from子句中）

```sql
SELECT dept.deptno,dept.dname,dept.loc,d.count,d.avgsal 
FROM dept LEFT JOIN (
    SELECT deptno,COUNT(*) count,AVG(sal) avgsal  
    FROM emp 
    GROUP BY deptno
) d
ON dept.deptno=d.deptno;
```

这样把子查询放在主查询中，让SQL语句变的复杂，如果可以先把子查询使用某种方式定义一下，在使用的位置直接用定义好的那就非常方便了！CTE就是用来解决这个事情的。

```sql
WITH dept_pcount_avgsal AS(
    SELECT deptno,COUNT(*) count,AVG(sal) avgsal  
    FROM emp 
    GROUP BY deptno
)
SELECT dept.deptno,dept.dname,dept.loc,d.count,d.avgsal 
FROM dept 
LEFT JOIN dept_pcount_avgsal d
ON dept.deptno=d.deptno;
```

我们将子查询定义为CTE，并取名为`dept_pcount_avgsal`，定义之后你就可以把`dept_pcount_avgsal`当做一个表名使用了！后面这个表和dept表做连接查询，大家都学过了！

再来一个案例熟悉一下：

+ 查询出基本工资比ALLEN低的全部员工信息

 ```mysql
SELECT * 
FROM emp 
WHERE sal<(
    SELECT sal 
    FROM emp 
    WHERE ename='ALLEN'
);
 ```

这个查询也可以用普通公用表表达式的方式完成：

```mysql
-- 在WHERE中使用
WITH allen_sal AS (
  SELECT sal 
  FROM emp 
  WHERE ename='ALLEN'
)
SELECT * FROM emp WHERE sal < (SELECT * FROM allen_sal);

-- 在FROM中使用
WITH allen_sal AS (
  SELECT sal 
  FROM emp 
  WHERE ename='ALLEN'
)
SELECT * FROM emp JOIN allen_sal ON emp.sal < allen_sal.sal;
```

公用表表达式可以起到子查询的作用。以后如果遇到需要使用子查询的场景，你可以在查询  之前，先定义公用表表达式，然后在查询中用它来代替子查询。而且，跟子查询相比，公用表表达式有一个优点，就是定义过公用表表达式之后的查询，可以像一个表一样多次引用公用表表达式，而子查询则不能。

## 递归公用表表达式

除了普通的CTE，MySQL还支持递归CTE。递归CTE允许你在查询中引用自身，通常用于处理层次结构数据，例如组织结构或树形结构。

### 语法

递归CTE的语法结构如下：

```mysql
WITH RECURSIVE cte_name[(alias,...)] AS 
(
	initial_query   -- anchor member
    UNION ALL
    recursive_query -- recursive member that references to the CTE name
)
SELECT|DELETE|UPDATE 语句;
```

递归 **CTE** 由三个主要部分组成：

- **initial_query：**形成 *CTE* 结构的基本结果集的初始查询 ，初始查询部分被称为锚成员。
- **UNION ALL：**递归成员由一个 `UNION ALL` 或`UNION DISTINCT`运算符与锚成员相连。
- **recursive_query：**递归查询部分是引用 *CTE* 名称的查询，因此称为递归成员。当递归成员没有返回任何行时，保递归停止。

> 注意，WITH后面必须使用RECURSIVE关键字，否则即使用了递归公用表表达式，也会报错！ERROR 1146 (42S02): Table 'cte_name' doesn't exist

### 示例

#### 计数

+ 来个最简单的计数，假如我需要一个结果集，只有一列，这一列的内容是从0到3，如何实现呢？

```sql
WITH RECURSIVE cte_count
AS (
      SELECT 1 AS n FROM DUAL
    
      UNION ALL
    
      SELECT n + 1 
      FROM cte_count 
      WHERE n < 3
    )
SELECT n 
FROM cte_count;
```

执行时，该语句将生成下面的结果：

```mysql
+------+
| n    |
+------+
|    1 |
|    2 |
|    3 |
+------+
3 rows in set (0.00 sec)
```

**执行过程分析：**

+  **SELECT 1 AS n FROM DUAL：**是初始查询，用于生成n的初始值；`FROM DUAL`中**DUAL 表** 是一个虚拟表，用于在不需要实际表的情况下执行查询。也可以不写，简化为`SELECT 1 AS n`。

+ **SELECT n + 1 FROM cte_count WHERE n < 3：**是递归查询，每次都查询CTE本身`cte_count`，让n+1，直到n不小于3为止。

#### 找下属

针对于我们常用的emp表，包含empno，ename和mgr三个字段。如果a是b的管理者，那么，我们可以把b叫做a的下属。

**找出姓名为`Jones`的员工的所有下属，包括下属的下属！**

```mysql
WITH RECURSIVE cte AS
(
	SELECT empno,ename,mgr,1 AS n FROM emp WHERE  ename = 'JONES'	-- 初始查询
	UNION ALL
	SELECT a.empno,a.ename,a.mgr,n+1 FROM emp AS a JOIN cte ON (a.mgr = cte.empno) -- 递归查询，找出以递归公用表表达式的人为领导的人
)
SELECT empno,ename,mgr,n FROM cte;

+-------+-------+------+------+
| empno | ename | mgr  | n    |
+-------+-------+------+------+
|  7566 | JONES | 7839 |    1 |
|  7788 | SCOTT | 7566 |    2 |
|  7902 | FORD  | 7566 |    2 |
|  7369 | SMITH | 7902 |    3 |
|  7876 | ADAMS | 7788 |    3 |
|  6666 | 顽石   | 7369 |    4 |
+-------+-------+------+------+
6 rows in set (0.00 sec)
```

总之，递归公用表表达式对于查询一个有共同的根节点的树形结构数据，非常有用。它可以不受层级的限制，轻松查出所有节点的数据。如果用其他的查询方式，就比较复杂了。

> cte并不是不受深度限制，而是默认限制深度比较大，可通过`SELECT @@cte_max_recursion_depth;`进行查看。
>
> cte_max_recursion_depth是全局变量，但也可以作为会话变量。

## 小 结

公用表表达式的作用是可以替代子查询，而且可以被多次引用。递归公用表表达式对查询有一个共同根 节点的树形结构数据非常高效，可以轻松搞定其他查询方式难以处理的查询。

# 窗口(分析)函数

MySQL分析函数是一种强大的工具，用于在查询结果中执行复杂的计算和分析。它们允许你在不改变查询结果集的情况下，对数据进行分组、排序和聚合操作。分析函数通常用于生成排名、累计值、移动平均值等高级分析结果。

## 概述

分析函数是SQL中的一类特殊函数，它们可以在查询结果集的基础上执行额外的计算。与普通的聚合函数（如`SUM`、`AVG`）不同，分析函数不会将结果集分组，而是为每一行返回一个值。这使得分析函数非常适合用于生成排名、累计值、移动平均值等复杂的分析结果。

## 为什么要使用窗口函数

假设我现在有这样一个数据表，它显示了某购物网站在每个城市每个区的销售额：

```mysql
CREATE TABLE sales(
	id INT PRIMARY KEY AUTO_INCREMENT, 
    city VARCHAR(15),
	county VARCHAR(15), 
    sales_value DECIMAL
);

INSERT INTO sales(city,county,sales_value) VALUES
('北京','海淀',10.00),
('北京','朝阳',20.00),
('上海','黄埔',30.00),
('上海','长宁',10.00);
```

**需求：**现在计算这个网站在每个城市的销售总额、在全国的销售总额、每个区的销售额占所在城市销售  额中的比率，以及占总销售额中的比率。

如果用分组和聚合函数，就需要分好几步来计算。

**第一步**，计算总销售金额，并存入临时表 a：

```mysql
CREATE TEMPORARY TABLE a	-- 创建临时表
SELECT SUM(sales_value) AS sales_value -- 计算总计金额
FROM sales;
```

查看一下临时表 a ：

```mysql
mysql> SELECT * FROM a;
+-------------+
| sales_value |
+-------------+
|	       70 |
+-------------+
1 row in set (0.00 sec)
```

**第二步**，计算每个城市的销售总额并存入临时表 b：

```mysql
CREATE TEMPORARY TABLE b	-- 创建临时表
SELECT city,SUM(sales_value) AS sales_value -- 计算城市销售合计
FROM sales GROUP BY city;
```

查看临时表 b ：

```mysql
mysql> SELECT * FROM b;
+------+-------------+
| city | sales_value |
+------+-------------+
| 北京 |	         30 |
| 上海 |	         40 |
+------+-------------+
2 rows in set (0.00 sec)
```

**第三步**，计算各区的销售占所在城市的总计金额的比例，和占全部销售总计金额的比例。我们可以通过下面的连接查询获得需要的结果：

```mysql
SELECT s.city AS 城市,s.county AS 区,s.sales_value AS 区销售额,
b.sales_value AS 市销售额,s.sales_value/b.sales_value AS 市比率,
a.sales_value AS 总销售额,s.sales_value/a.sales_value AS 总比率
FROM sales s
JOIN b ON (s.city=b.city) -- 连接市统计结果临时表
JOIN a	-- 连接总计金额临时表
ORDER BY s.city,s.county;
```

结果：

```mysql
+------+------+----------+----------+--------+----------+--------+
| 城 市 | 区	| 区销售额  | 市销售额	| 市比率  | 总销售额  | 总比率  |
+------+------+----------+----------+--------+----------+--------+
| 上海  | 长宁 |	   10 |	40      | 0.2500 |	     70 | 0.1429 |
| 上海  | 黄埔 |	   30 |	40      | 0.7500 |	     70 | 0.4286 |
| 北京  | 朝阳 |	   20 |	30      | 0.6667 |	     70 | 0.2857 |
| 北京  | 海淀 |	   10 |	30      | 0.3333 |	     70 | 0.1429 |
+------+------+----------+----------+--------+----------+--------+
4 rows in set (0.00 sec)
```

结果显示：市销售金额、市销售占比、总销售金额、总销售占比都计算出来了。 同样的查询，如果用窗口函数，就简单多了。我们可以用下面的代码来实现： 

```mysql
SELECT city AS 城市,county AS 区,sales_value AS 区销售额,
SUM(sales_value) OVER(PARTITION BY city) AS 市销售额, -- 计算市销售额
sales_value/SUM(sales_value) OVER(PARTITION BY city) AS 市比率,
SUM(sales_value) OVER() AS 总销售额,	-- 计算总销售额
sales_value/SUM(sales_value) OVER() AS 总比率
FROM sales
ORDER BY city,county;
```

结果显示，我们得到了与上面那种查询同样的结果。

使用窗口函数，只用了一步就完成了查询。而且，由于没有用到临时表，执行的效率也更高了。很显  然，**在这种需要用到分组统计的结果对每一条记录进行计算的场景下，使用窗口函数更好**。

## 语法结构

+ 语法如下：

  ```sql
  function_name (expression) OVER (
      [PARTITION BY partition_expression]
      [ORDER BY sort_expression]
      [ROWS BETWEEN frame_start AND frame_end]
  )
  ```

  - `function_name`: 分析函数的名称，如`ROW_NUMBER`、`RANK`、`SUM`等。
  - `expression`: 要计算的表达式或列。
  - `PARTITION BY`: 可选，用于将数据分组。
  - `ORDER BY`: 可选，用于对分组内的数据进行排序。
  - `ROWS BETWEEN`: 可选，用于定义计算范围。

  [SQL 题目讲解 —— 窗口函数（一）](https://www.bilibili.com/video/BV1g84y1v7iV)

## 窗口函数分类

MySQL从8.0版本开始支持[窗口函数](https://dev.mysql.com/doc/refman/8.0/en/window-function-descriptions.html#function_row-number)。窗口函数的作用类似于在查询中对数据进行分组，不同的是，分组操作会把分组的结果聚合成一条记录，而窗口函数是将结果置于每一条数据记录中。

窗口函数总体上可以分为序号函数、分布函数、前后函数、首尾函数和其他函数，如下表：

![img](assets/wps40.png) 

## 分类讲解

### 1. 序号函数

#### **1.** ROW_NUMBER()函数

ROW_NUMBER()函数能够对数据中的序号进行顺序显示。

+ 查询 emp表中每个部门下工资降序排列的各个员工信息。

```mysql
mysql> SELECT ROW_NUMBER() OVER(PARTITION BY deptno ORDER BY sal DESC) row_num,
deptno,empno,ename,job,sal,hiredate 
FROM emp;

+---------+--------+-------+--------+-----------+---------+------------+
| row_num | deptno | empno | ename  | job       | sal     | hiredate   |
+---------+--------+-------+--------+-----------+---------+------------+
|       1 |     10 |  7839 | KING   | PRESIDENT | 8000.00 | 2011-11-17 |
|       2 |     10 |  7782 | CLARK  | MANAGER   | 5450.00 | 2011-06-09 |
|       3 |     10 |  7934 | MILLER | CLERK     | 4300.00 | 2012-01-23 |
|       1 |     20 |  7566 | JONES  | MANAGER   | 6975.00 | 2011-04-02 |
|       2 |     20 |  7788 | SCOTT  | ANALYST   | 6000.00 | 2017-04-19 |
|       3 |     20 |  7902 | FORD   | ANALYST   | 6000.00 | 2011-12-03 |
|       4 |     20 |  7876 | ADAMS  | CLERK     | 4100.00 | 2017-05-23 |
|       5 |     20 |  7369 | SMITH  | CLERK     | 3800.00 | 2010-12-17 |
|       1 |     30 |  7698 | BLAKE  | MANAGER   | 5850.00 | 2011-05-01 |
|       2 |     30 |  7499 | ALLEN  | SALESMAN  | 4600.00 | 2011-02-20 |
|       3 |     30 |  7844 | TURNER | SALESMAN  | 4500.00 | 2011-09-08 |
|       4 |     30 |  7521 | WARD   | SALESMAN  | 4250.00 | 2011-02-22 |
|       5 |     30 |  7654 | MARTIN | SALESMAN  | 4250.00 | 2011-09-28 |
|       6 |     30 |  7900 | JAMES  | CLERK     | 3950.00 | 2011-12-03 |
+---------+--------+-------+--------+-----------+---------+------------+
14 rows in set (0.00 sec)
```

+ 查询 emp表中30部门工资最高的3个员工信息。 

使用row_number的结果作为条件，直接进行筛选即可！

```sql
SELECT ROW_NUMBER() OVER(PARTITION BY deptno ORDER BY sal DESC) row_num,
deptno,empno,ename,job,sal,hiredate 
FROM emp WHERE deptno = 30 AND row_num <=3;
```

哎嘿，报错了！`1054 - Unknown column 'row_num' in 'where clause'`，因为row_num不能直接在WHERE中使用，所以要用子查询！

```mysql
mysql> SELECT * 
FROM(
  SELECT ROW_NUMBER() OVER(PARTITION BY deptno ORDER BY sal DESC) row_num,
  deptno,empno,ename,job,sal,hiredate 
  FROM emp
)t
WHERE deptno = 30 AND row_num <=3;

+---------+--------+-------+--------+----------+---------+------------+
| row_num | deptno | empno | ename  | job      | sal     | hiredate   |
+---------+--------+-------+--------+----------+---------+------------+
|       1 |     30 |  7698 | BLAKE  | MANAGER  | 5850.00 | 2011-05-01 |
|       2 |     30 |  7499 | ALLEN  | SALESMAN | 4600.00 | 2011-02-20 |
|       3 |     30 |  7844 | TURNER | SALESMAN | 4500.00 | 2011-09-08 |
+---------+--------+-------+--------+----------+---------+------------+
3 rows in set (0.00 sec)
```

在20部门中，有两个员工薪资均为6000元，分别是SCOTT和FORD。两个员工的序号都应该为2（并列第二），而不是一个为2，另一个为3。此时，可以使用RANK()函数或DENSE_RANK()函数解决。

#### **2.** RANK()函数

使用RANK()函数能够对序号进行并列排序，并且会跳过重复的序号，比如序号为1、2、2、4、5，跳过中间的3，打断了序号的连续性。 

+ 使用RANK()函数获取 emp 表中各部门的员工工资从高到低排序的员工信息。

```mysql
mysql>   SELECT RANK() OVER(PARTITION BY deptno ORDER BY sal DESC) row_num,
  deptno,empno,ename,job,sal,hiredate 
  FROM emp;
  
+---------+--------+-------+--------+-----------+---------+------------+
| row_num | deptno | empno | ename  | job       | sal     | hiredate   |
+---------+--------+-------+--------+-----------+---------+------------+
|       1 |     10 |  7839 | KING   | PRESIDENT | 8000.00 | 2011-11-17 |
|       2 |     10 |  7782 | CLARK  | MANAGER   | 5450.00 | 2011-06-09 |
|       3 |     10 |  7934 | MILLER | CLERK     | 4300.00 | 2012-01-23 |
|       1 |     20 |  7566 | JONES  | MANAGER   | 6975.00 | 2011-04-02 |
|       2 |     20 |  7788 | SCOTT  | ANALYST   | 6000.00 | 2017-04-19 |
|       2 |     20 |  7902 | FORD   | ANALYST   | 6000.00 | 2011-12-03 |
|       4 |     20 |  7876 | ADAMS  | CLERK     | 4100.00 | 2017-05-23 |
|       5 |     20 |  7369 | SMITH  | CLERK     | 3800.00 | 2010-12-17 |
|       1 |     30 |  7698 | BLAKE  | MANAGER   | 5850.00 | 2011-05-01 |
|       2 |     30 |  7499 | ALLEN  | SALESMAN  | 4600.00 | 2011-02-20 |
|       3 |     30 |  7844 | TURNER | SALESMAN  | 4500.00 | 2011-09-08 |
|       4 |     30 |  7521 | WARD   | SALESMAN  | 4250.00 | 2011-02-22 |
|       4 |     30 |  7654 | MARTIN | SALESMAN  | 4250.00 | 2011-09-28 |
|       6 |     30 |  7900 | JAMES  | CLERK     | 3950.00 | 2011-12-03 |
+---------+--------+-------+--------+-----------+---------+------------+
14 rows in set (0.00 sec)
```

+ 使用RANK()函数查询 emp表中每个部门下工资最高的3个员工信息。

```mysql
mysql> SELECT * 
FROM(
  SELECT RANK() OVER(PARTITION BY deptno ORDER BY sal DESC) row_num,
  deptno,empno,ename,job,sal,hiredate 
  FROM emp
)t
WHERE row_num <=3;

+---------+--------+-------+--------+-----------+---------+------------+
| row_num | deptno | empno | ename  | job       | sal     | hiredate   |
+---------+--------+-------+--------+-----------+---------+------------+
|       1 |     10 |  7839 | KING   | PRESIDENT | 8000.00 | 2011-11-17 |
|       2 |     10 |  7782 | CLARK  | MANAGER   | 5450.00 | 2011-06-09 |
|       3 |     10 |  7934 | MILLER | CLERK     | 4300.00 | 2012-01-23 |
|       1 |     20 |  7566 | JONES  | MANAGER   | 6975.00 | 2011-04-02 |
|       2 |     20 |  7788 | SCOTT  | ANALYST   | 6000.00 | 2017-04-19 |
|       2 |     20 |  7902 | FORD   | ANALYST   | 6000.00 | 2011-12-03 |
|       1 |     30 |  7698 | BLAKE  | MANAGER   | 5850.00 | 2011-05-01 |
|       2 |     30 |  7499 | ALLEN  | SALESMAN  | 4600.00 | 2011-02-20 |
|       3 |     30 |  7844 | TURNER | SALESMAN  | 4500.00 | 2011-09-08 |
+---------+--------+-------+--------+-----------+---------+------------+
9 rows in set (0.00 sec)
```

可以看到，使用RANK()函数得出的序号为1、2、2、4，相同工资的员工序号相同，后面的员工序号是不连续的，跳过了重复的序号。

#### **3.** DENSE_RANK()函数

DENSE_RANK()函数对序号进行并列排序，并且不会跳过重复的序号，比如序号为1、2、2、3、4，有并列的，序号还是连续的。

+ 使用DENSE_RANK()函数获取 emp数据表中各部门的工资从高到低排序的各员工信息。

```mysql
mysql> SELECT DENSE_RANK() OVER(PARTITION BY deptno ORDER BY sal DESC) row_num,
deptno,empno,ename,job,sal,hiredate 
FROM emp;

+---------+--------+-------+--------+-----------+---------+------------+
| row_num | deptno | empno | ename  | job       | sal     | hiredate   |
+---------+--------+-------+--------+-----------+---------+------------+
|       1 |     10 |  7839 | KING   | PRESIDENT | 8000.00 | 2011-11-17 |
|       2 |     10 |  7782 | CLARK  | MANAGER   | 5450.00 | 2011-06-09 |
|       3 |     10 |  7934 | MILLER | CLERK     | 4300.00 | 2012-01-23 |
|       1 |     20 |  7566 | JONES  | MANAGER   | 6975.00 | 2011-04-02 |
|       2 |     20 |  7788 | SCOTT  | ANALYST   | 6000.00 | 2017-04-19 |
|       2 |     20 |  7902 | FORD   | ANALYST   | 6000.00 | 2011-12-03 |
|       3 |     20 |  7876 | ADAMS  | CLERK     | 4100.00 | 2017-05-23 |
|       4 |     20 |  7369 | SMITH  | CLERK     | 3800.00 | 2010-12-17 |
|       1 |     30 |  7698 | BLAKE  | MANAGER   | 5850.00 | 2011-05-01 |
|       2 |     30 |  7499 | ALLEN  | SALESMAN  | 4600.00 | 2011-02-20 |
|       3 |     30 |  7844 | TURNER | SALESMAN  | 4500.00 | 2011-09-08 |
|       4 |     30 |  7521 | WARD   | SALESMAN  | 4250.00 | 2011-02-22 |
|       4 |     30 |  7654 | MARTIN | SALESMAN  | 4250.00 | 2011-09-28 |
|       5 |     30 |  7900 | JAMES  | CLERK     | 3950.00 | 2011-12-03 |
+---------+--------+-------+--------+-----------+---------+------------+
14 rows in set (0.00 sec)
```

+ 使用DENSE_RANK()函数获取 emp 数据表中30号部门的工资最高的4个员工信息。

```mysql
mysql>  SELECT * 
FROM(
  SELECT DENSE_RANK() OVER(PARTITION BY deptno ORDER BY sal DESC) row_num,
  deptno,empno,ename,job,sal,hiredate 
  FROM emp
)t
WHERE  deptno = 30 AND row_num <= 4;
       
+---------+--------+-------+--------+----------+---------+------------+
| row_num | deptno | empno | ename  | job      | sal     | hiredate   |
+---------+--------+-------+--------+----------+---------+------------+
|       1 |     30 |  7698 | BLAKE  | MANAGER  | 5850.00 | 2011-05-01 |
|       2 |     30 |  7499 | ALLEN  | SALESMAN | 4600.00 | 2011-02-20 |
|       3 |     30 |  7844 | TURNER | SALESMAN | 4500.00 | 2011-09-08 |
|       4 |     30 |  7521 | WARD   | SALESMAN | 4250.00 | 2011-02-22 |
|       4 |     30 |  7654 | MARTIN | SALESMAN | 4250.00 | 2011-09-28 |
+---------+--------+-------+--------+----------+---------+------------+
5 rows in set (0.00 sec)
```

可以看到，使用DENSE_RANK()函数得出的行号为1、2、2、3、4，相同工资的员工序号相同，后面的员工序号是连续的，并且没有跳过重复的序号。

### 2. 分布函数

#### **1.** PERCENT_RANK()函数

PERCENT_RANK()函数是等级值百分比函数。按照如下方式进行计算。

```mysql
(rank - 1) / (rows - 1)
```

其中，rank的值为使用RANK()函数产生的序号，rows的值为当前窗口的总记录数。

+ 计算 emp数据表中30号部门下的员工的PERCENT_RANK值。

```mysql
#写法一：
SELECT 
RANK() OVER(PARTITION BY deptno ORDER BY sal DESC) _rank,
PERCENT_RANK() OVER(PARTITION BY deptno ORDER BY sal DESC) prank,
deptno,empno,ename,job,sal,hiredate 
FROM emp WHERE deptno = 30;

#写法二：
mysql> SELECT 
RANK() OVER w AS _rank,
PERCENT_RANK() OVER w AS prank,
deptno,empno,ename,job,sal,hiredate 
FROM emp WHERE deptno = 30
WINDOW w AS(PARTITION BY deptno ORDER BY sal DESC);

+-------+-------+--------+-------+--------+----------+---------+------------+
| _rank | prank | deptno | empno | ename  | job      | sal     | hiredate   |
+-------+-------+--------+-------+--------+----------+---------+------------+
|     1 |     0 |     30 |  7698 | BLAKE  | MANAGER  | 5850.00 | 2011-05-01 |
|     2 |   0.2 |     30 |  7499 | ALLEN  | SALESMAN | 4600.00 | 2011-02-20 |
|     3 |   0.4 |     30 |  7844 | TURNER | SALESMAN | 4500.00 | 2011-09-08 |
|     4 |   0.6 |     30 |  7521 | WARD   | SALESMAN | 4250.00 | 2011-02-22 |
|     4 |   0.6 |     30 |  7654 | MARTIN | SALESMAN | 4250.00 | 2011-09-28 |
|     6 |     1 |     30 |  7900 | JAMES  | CLERK    | 3950.00 | 2011-12-03 |
+-------+-------+--------+-------+--------+----------+---------+------------+
6 rows in set (0.00 sec)
```

#### **2.** CUME_DIST()函数

CUME_DIST()函数主要用于查询**小于和等于**当前rank值的比例。按照如下方式进行计算。

```sql
小于和等于当前rank值的行数 / 分组内的总行数
```

+ 查询emp数据表中小于或等于当前工资的比例。

 ```mysql
mysql> SELECT ROUND(CUME_DIST() OVER(PARTITION BY deptno ORDER BY sal ASC),2) AS cd,
deptno,empno,ename,job,sal,hiredate 
FROM emp;

+------+--------+-------+--------+-----------+---------+------------+
| cd   | deptno | empno | ename  | job       | sal     | hiredate   |
+------+--------+-------+--------+-----------+---------+------------+
| 0.33 |     10 |  7934 | MILLER | CLERK     | 4300.00 | 2012-01-23 | 1/3
| 0.67 |     10 |  7782 | CLARK  | MANAGER   | 5450.00 | 2011-06-09 | 2/3
|    1 |     10 |  7839 | KING   | PRESIDENT | 8000.00 | 2011-11-17 | 3/3
|  0.2 |     20 |  7369 | SMITH  | CLERK     | 3800.00 | 2010-12-17 |
|  0.4 |     20 |  7876 | ADAMS  | CLERK     | 4100.00 | 2017-05-23 |
|  0.8 |     20 |  7788 | SCOTT  | ANALYST   | 6000.00 | 2017-04-19 |
|  0.8 |     20 |  7902 | FORD   | ANALYST   | 6000.00 | 2011-12-03 |
|    1 |     20 |  7566 | JONES  | MANAGER   | 6975.00 | 2011-04-02 |
| 0.17 |     30 |  7900 | JAMES  | CLERK     | 3950.00 | 2011-12-03 |
|  0.5 |     30 |  7521 | WARD   | SALESMAN  | 4250.00 | 2011-02-22 |
|  0.5 |     30 |  7654 | MARTIN | SALESMAN  | 4250.00 | 2011-09-28 |
| 0.67 |     30 |  7844 | TURNER | SALESMAN  | 4500.00 | 2011-09-08 |
| 0.83 |     30 |  7499 | ALLEN  | SALESMAN  | 4600.00 | 2011-02-20 |
|    1 |     30 |  7698 | BLAKE  | MANAGER   | 5850.00 | 2011-05-01 |
+------+--------+-------+--------+-----------+---------+------------+
14 rows in set (0.00 sec)
 ```

#### **2.** NTILE(n)函数

NTILE(n)函数用于将有序数据集划分为指定数量的桶（buckets），并为每一行分配一个桶编号（从1开始）。

+ 将emp表中的每个部门分成三组。

```mysql
mysql> SELECT NTILE(3) OVER(
  PARTITION BY deptno 
  ORDER BY empno ASC
) AS nt,sal,
deptno,empno,ename,job,hiredate 
FROM emp;

+----+---------+--------+-------+--------+-----------+------------+
| nt | sal     | deptno | empno | ename  | job       | hiredate   |
+----+---------+--------+-------+--------+-----------+------------+
|  1 | 5450.00 |     10 |  7782 | CLARK  | MANAGER   | 2011-06-09 |
|  2 | 8000.00 |     10 |  7839 | KING   | PRESIDENT | 2011-11-17 |
|  3 | 4300.00 |     10 |  7934 | MILLER | CLERK     | 2012-01-23 |
|  1 | 3800.00 |     20 |  7369 | SMITH  | CLERK     | 2010-12-17 |
|  1 | 6975.00 |     20 |  7566 | JONES  | MANAGER   | 2011-04-02 |
|  2 | 6000.00 |     20 |  7788 | SCOTT  | ANALYST   | 2017-04-19 |
|  2 | 4100.00 |     20 |  7876 | ADAMS  | CLERK     | 2017-05-23 |
|  3 | 6000.00 |     20 |  7902 | FORD   | ANALYST   | 2011-12-03 |
|  1 | 4600.00 |     30 |  7499 | ALLEN  | SALESMAN  | 2011-02-20 |
|  1 | 4250.00 |     30 |  7521 | WARD   | SALESMAN  | 2011-02-22 |
|  2 | 4250.00 |     30 |  7654 | MARTIN | SALESMAN  | 2011-09-28 |
|  2 | 5850.00 |     30 |  7698 | BLAKE  | MANAGER   | 2011-05-01 |
|  3 | 4500.00 |     30 |  7844 | TURNER | SALESMAN  | 2011-09-08 |
|  3 | 3950.00 |     30 |  7900 | JAMES  | CLERK     | 2011-12-03 |
+----+---------+--------+-------+--------+-----------+------------+
14 rows in set (0.00 sec)
```

### **3.** 前后函数

#### **1.** LAG(expr)函数

LAG()函数可以用来访问当前行的前一行或多行的数据。这个函数通常用于分析时间序列数据，比如计算相邻行之间的差异或者获取前一个状态等。

LAG函数语法如下：

```sql
LAG(expression [,offset] [,default_value])
```

参数解析：

- `expression`: 要检索的列或表达式。
- `offset`: 指定从当前行向前偏移的行数。默认值为1，即当前行的前一行。
- `default_value`: 当指定偏移量后没有足够的行时返回的默认值。如果未指定，默认为`NULL`。

**示例：**

+ 查询emp数据表每个员工信息，按照薪资升序排列，并追加前一个员工的薪资。

```sql
mysql> SELECT LAG(sal) OVER(PARTITION BY deptno ORDER BY sal ASC) AS prev_sal,sal,
deptno,empno,ename,job,hiredate 
FROM emp;

+----------+---------+--------+-------+--------+-----------+------------+
| prev_sal | sal     | deptno | empno | ename  | job       | hiredate   |
+----------+---------+--------+-------+--------+-----------+------------+
|     NULL | 4300.00 |     10 |  7934 | MILLER | CLERK     | 2012-01-23 |
|  4300.00 | 5450.00 |     10 |  7782 | CLARK  | MANAGER   | 2011-06-09 |
|  5450.00 | 8000.00 |     10 |  7839 | KING   | PRESIDENT | 2011-11-17 |
|     NULL | 3800.00 |     20 |  7369 | SMITH  | CLERK     | 2010-12-17 |
|  3800.00 | 4100.00 |     20 |  7876 | ADAMS  | CLERK     | 2017-05-23 |
|  4100.00 | 6000.00 |     20 |  7788 | SCOTT  | ANALYST   | 2017-04-19 |
|  6000.00 | 6000.00 |     20 |  7902 | FORD   | ANALYST   | 2011-12-03 |
|  6000.00 | 6975.00 |     20 |  7566 | JONES  | MANAGER   | 2011-04-02 |
|     NULL | 3950.00 |     30 |  7900 | JAMES  | CLERK     | 2011-12-03 |
|  3950.00 | 4250.00 |     30 |  7521 | WARD   | SALESMAN  | 2011-02-22 |
|  4250.00 | 4250.00 |     30 |  7654 | MARTIN | SALESMAN  | 2011-09-28 |
|  4250.00 | 4500.00 |     30 |  7844 | TURNER | SALESMAN  | 2011-09-08 |
|  4500.00 | 4600.00 |     30 |  7499 | ALLEN  | SALESMAN  | 2011-02-20 |
|  4600.00 | 5850.00 |     30 |  7698 | BLAKE  | MANAGER   | 2011-05-01 |
+----------+---------+--------+-------+--------+-----------+------------+
14 rows in set (0.00 sec)
```

+ 查询emp数据表中当前员工工资与前一个员工工资的差值。

 ```mysql
mysql> WITH t_diff AS(
  SELECT LAG(sal,1,NULL) OVER(PARTITION BY deptno ORDER BY sal ASC) AS prev_sal,sal,
  deptno,empno,ename,job,hiredate 
  FROM emp
)
SELECT deptno,empno,ename,job,hiredate,sal,t.prev_sal,  sal - t.prev_sal AS sal_diff
FROM t_diff t;

+--------+-------+--------+-----------+------------+---------+----------+----------+
| deptno | empno | ename  | job       | hiredate   | sal     | prev_sal | sal_diff |
+--------+-------+--------+-----------+------------+---------+----------+----------+
|     10 |  7934 | MILLER | CLERK     | 2012-01-23 | 4300.00 |     NULL |     NULL |
|     10 |  7782 | CLARK  | MANAGER   | 2011-06-09 | 5450.00 |  4300.00 |  1150.00 |
|     10 |  7839 | KING   | PRESIDENT | 2011-11-17 | 8000.00 |  5450.00 |  2550.00 |
|     20 |  7369 | SMITH  | CLERK     | 2010-12-17 | 3800.00 |     NULL |     NULL |
|     20 |  7876 | ADAMS  | CLERK     | 2017-05-23 | 4100.00 |  3800.00 |   300.00 |
|     20 |  7788 | SCOTT  | ANALYST   | 2017-04-19 | 6000.00 |  4100.00 |  1900.00 |
|     20 |  7902 | FORD   | ANALYST   | 2011-12-03 | 6000.00 |  6000.00 |     0.00 |
|     20 |  7566 | JONES  | MANAGER   | 2011-04-02 | 6975.00 |  6000.00 |   975.00 |
|     30 |  7900 | JAMES  | CLERK     | 2011-12-03 | 3950.00 |     NULL |     NULL |
|     30 |  7521 | WARD   | SALESMAN  | 2011-02-22 | 4250.00 |  3950.00 |   300.00 |
|     30 |  7654 | MARTIN | SALESMAN  | 2011-09-28 | 4250.00 |  4250.00 |     0.00 |
|     30 |  7844 | TURNER | SALESMAN  | 2011-09-08 | 4500.00 |  4250.00 |   250.00 |
|     30 |  7499 | ALLEN  | SALESMAN  | 2011-02-20 | 4600.00 |  4500.00 |   100.00 |
|     30 |  7698 | BLAKE  | MANAGER   | 2011-05-01 | 5850.00 |  4600.00 |  1250.00 |
+--------+-------+--------+-----------+------------+---------+----------+----------+
14 rows in set (0.00 sec)
 ```

#### **2.** LEAD(expr)函数

LEAD()函数可以用来访问当前行的后一行或多行的数据。这个函数通常用于分析时间序列数据，比如计算相邻行之间的差异或者获取前一个状态等。

LEAD函数语法如下：

```sql
LEAD(expression [,offset] [,default_value])
```

参数解析：

- `expression`: 要检索的列或表达式。
- `offset`: 指定从当前行向后偏移的行数。默认值为1，即当前行的后一行。
- `default_value`: 当指定偏移量后没有足够的行时返回的默认值。如果未指定，默认为`NULL`。

**示例：**

+ 查询emp数据表每个员工信息，按照薪资升序排列，并追加后一个员工的薪资。

```sql
mysql>   SELECT LEAD(sal,1,NULL) OVER(PARTITION BY deptno ORDER BY sal ASC) AS prev_sal,sal,
  deptno,empno,ename,job,hiredate 
  FROM emp;
  
  +----------+---------+--------+-------+--------+-----------+------------+
| prev_sal | sal     | deptno | empno | ename  | job       | hiredate   |
+----------+---------+--------+-------+--------+-----------+------------+
|  5450.00 | 4300.00 |     10 |  7934 | MILLER | CLERK     | 2012-01-23 |
|  8000.00 | 5450.00 |     10 |  7782 | CLARK  | MANAGER   | 2011-06-09 |
|     NULL | 8000.00 |     10 |  7839 | KING   | PRESIDENT | 2011-11-17 |
|  4100.00 | 3800.00 |     20 |  7369 | SMITH  | CLERK     | 2010-12-17 |
|  6000.00 | 4100.00 |     20 |  7876 | ADAMS  | CLERK     | 2017-05-23 |
|  6000.00 | 6000.00 |     20 |  7788 | SCOTT  | ANALYST   | 2017-04-19 |
|  6975.00 | 6000.00 |     20 |  7902 | FORD   | ANALYST   | 2011-12-03 |
|     NULL | 6975.00 |     20 |  7566 | JONES  | MANAGER   | 2011-04-02 |
|  4250.00 | 3950.00 |     30 |  7900 | JAMES  | CLERK     | 2011-12-03 |
|  4250.00 | 4250.00 |     30 |  7521 | WARD   | SALESMAN  | 2011-02-22 |
|  4500.00 | 4250.00 |     30 |  7654 | MARTIN | SALESMAN  | 2011-09-28 |
|  4600.00 | 4500.00 |     30 |  7844 | TURNER | SALESMAN  | 2011-09-08 |
|  5850.00 | 4600.00 |     30 |  7499 | ALLEN  | SALESMAN  | 2011-02-20 |
|     NULL | 5850.00 |     30 |  7698 | BLAKE  | MANAGER   | 2011-05-01 |
+----------+---------+--------+-------+--------+-----------+------------+
14 rows in set (0.00 sec)
```

+ 查询emp数据表中当前员工工资和后一个员工工资的差值。

 ```mysql
mysql> WITH t_diff AS(
  SELECT LEAD(sal,1,NULL) OVER(PARTITION BY deptno ORDER BY sal ASC) AS prev_sal,sal,
  deptno,empno,ename,job,hiredate 
  FROM emp
)
SELECT deptno,empno,ename,job,hiredate,sal,t.prev_sal,  sal - t.prev_sal AS sal_diff
FROM t_diff t;

+--------+-------+--------+-----------+------------+---------+----------+----------+
| deptno | empno | ename  | job       | hiredate   | sal     | prev_sal | sal_diff |
+--------+-------+--------+-----------+------------+---------+----------+----------+
|     10 |  7934 | MILLER | CLERK     | 2012-01-23 | 4300.00 |  5450.00 | -1150.00 |
|     10 |  7782 | CLARK  | MANAGER   | 2011-06-09 | 5450.00 |  8000.00 | -2550.00 |
|     10 |  7839 | KING   | PRESIDENT | 2011-11-17 | 8000.00 |     NULL |     NULL |
|     20 |  7369 | SMITH  | CLERK     | 2010-12-17 | 3800.00 |  4100.00 |  -300.00 |
|     20 |  7876 | ADAMS  | CLERK     | 2017-05-23 | 4100.00 |  6000.00 | -1900.00 |
|     20 |  7788 | SCOTT  | ANALYST   | 2017-04-19 | 6000.00 |  6000.00 |     0.00 |
|     20 |  7902 | FORD   | ANALYST   | 2011-12-03 | 6000.00 |  6975.00 |  -975.00 |
|     20 |  7566 | JONES  | MANAGER   | 2011-04-02 | 6975.00 |     NULL |     NULL |
|     30 |  7900 | JAMES  | CLERK     | 2011-12-03 | 3950.00 |  4250.00 |  -300.00 |
|     30 |  7521 | WARD   | SALESMAN  | 2011-02-22 | 4250.00 |  4250.00 |     0.00 |
|     30 |  7654 | MARTIN | SALESMAN  | 2011-09-28 | 4250.00 |  4500.00 |  -250.00 |
|     30 |  7844 | TURNER | SALESMAN  | 2011-09-08 | 4500.00 |  4600.00 |  -100.00 |
|     30 |  7499 | ALLEN  | SALESMAN  | 2011-02-20 | 4600.00 |  5850.00 | -1250.00 |
|     30 |  7698 | BLAKE  | MANAGER   | 2011-05-01 | 5850.00 |     NULL |     NULL |
+--------+-------+--------+-----------+------------+---------+----------+----------+
14 rows in set (0.00 sec)
 ```

### 4. 首尾函数

#### **1.** FIRST_VALUE(expr)函数

FIRST_VALUE(expr)函数返回分区中第一个expr的值。

+ 按照工资排序，查询第1个员工的工资信息。

 ```mysql
mysql> SELECT FIRST_VALUE(sal) OVER(PARTITION BY deptno ORDER BY sal ASC) AS first_sal,sal,
deptno,empno,ename,job,hiredate 
FROM emp;

+----------+---------+--------+-------+--------+-----------+------------+
| first_sal | sal     | deptno | empno | ename  | job       | hiredate   |
+----------+---------+--------+-------+--------+-----------+------------+
|  4300.00 | 4300.00 |     10 |  7934 | MILLER | CLERK     | 2012-01-23 |
|  4300.00 | 5450.00 |     10 |  7782 | CLARK  | MANAGER   | 2011-06-09 |
|  4300.00 | 8000.00 |     10 |  7839 | KING   | PRESIDENT | 2011-11-17 |
|  3800.00 | 3800.00 |     20 |  7369 | SMITH  | CLERK     | 2010-12-17 |
|  3800.00 | 4100.00 |     20 |  7876 | ADAMS  | CLERK     | 2017-05-23 |
|  3800.00 | 6000.00 |     20 |  7788 | SCOTT  | ANALYST   | 2017-04-19 |
|  3800.00 | 6000.00 |     20 |  7902 | FORD   | ANALYST   | 2011-12-03 |
|  3800.00 | 6975.00 |     20 |  7566 | JONES  | MANAGER   | 2011-04-02 |
|  3950.00 | 3950.00 |     30 |  7900 | JAMES  | CLERK     | 2011-12-03 |
|  3950.00 | 4250.00 |     30 |  7521 | WARD   | SALESMAN  | 2011-02-22 |
|  3950.00 | 4250.00 |     30 |  7654 | MARTIN | SALESMAN  | 2011-09-28 |
|  3950.00 | 4500.00 |     30 |  7844 | TURNER | SALESMAN  | 2011-09-08 |
|  3950.00 | 4600.00 |     30 |  7499 | ALLEN  | SALESMAN  | 2011-02-20 |
|  3950.00 | 5850.00 |     30 |  7698 | BLAKE  | MANAGER   | 2011-05-01 |
+----------+---------+--------+-------+--------+-----------+------------+
14 rows in set (0.00 sec)
 ```

 

#### **2.** LAST_VALUE(expr)函数

LAST_VALUE(expr)函数返回分区中最后一个expr的值。

举例：查询所有员工信息，按照工资升序排列，并显示最后一个员工的工资信息。

 ```mysql
mysql> SELECT LAST_VALUE(sal) OVER(
  PARTITION BY deptno 
  ORDER BY sal ASC
) AS last_sal,sal,
deptno,empno,ename,job,hiredate 
FROM emp;

+----------+---------+--------+-------+--------+-----------+------------+
| last_sal | sal     | deptno | empno | ename  | job       | hiredate   |
+----------+---------+--------+-------+--------+-----------+------------+
|  4300.00 | 4300.00 |     10 |  7934 | MILLER | CLERK     | 2012-01-23 |
|  5450.00 | 5450.00 |     10 |  7782 | CLARK  | MANAGER   | 2011-06-09 |
|  8000.00 | 8000.00 |     10 |  7839 | KING   | PRESIDENT | 2011-11-17 |
|  3800.00 | 3800.00 |     20 |  7369 | SMITH  | CLERK     | 2010-12-17 |
|  4100.00 | 4100.00 |     20 |  7876 | ADAMS  | CLERK     | 2017-05-23 |
|  6000.00 | 6000.00 |     20 |  7788 | SCOTT  | ANALYST   | 2017-04-19 |
|  6000.00 | 6000.00 |     20 |  7902 | FORD   | ANALYST   | 2011-12-03 |
|  6975.00 | 6975.00 |     20 |  7566 | JONES  | MANAGER   | 2011-04-02 |
|  3950.00 | 3950.00 |     30 |  7900 | JAMES  | CLERK     | 2011-12-03 |
|  4250.00 | 4250.00 |     30 |  7521 | WARD   | SALESMAN  | 2011-02-22 |
|  4250.00 | 4250.00 |     30 |  7654 | MARTIN | SALESMAN  | 2011-09-28 |
|  4500.00 | 4500.00 |     30 |  7844 | TURNER | SALESMAN  | 2011-09-08 |
|  4600.00 | 4600.00 |     30 |  7499 | ALLEN  | SALESMAN  | 2011-02-20 |
|  5850.00 | 5850.00 |     30 |  7698 | BLAKE  | MANAGER   | 2011-05-01 |
+----------+---------+--------+-------+--------+-----------+------------+
14 rows in set (0.00 sec)
 ```

我们发现，last_sal列，都是当前行的薪资，而不是当前部门最后一个员工的薪资。很让人疑惑吧~

首先需要明白，窗口函数不是在**整个结果集**上操作，而是在**当前行的窗口框架**内操作。

为什么要这样设计呢？

1. **性能优化**：默认框架限制计算范围，避免每次都要扫描整个分区
2. **累加计算**：适合移动平均、累计求和等场景
3. **SQL标准**：遵循 SQL:2003 标准规范

如何让 `LAST_VALUE()` 返回真正的最后值？只需要指明窗口范围即可！

没有指定窗口范围时，默认是：

```sql
ROW BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
```

指定本组所有数据：

```sql
ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
```

再次测试：

```sql
mysql> SELECT LAST_VALUE(sal) OVER(
  PARTITION BY deptno 
  ORDER BY sal ASC
  ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
) AS last_sal,sal,
deptno,empno,ename,job,hiredate 
FROM emp;

+----------+---------+--------+-------+--------+-----------+------------+
| last_sal | sal     | deptno | empno | ename  | job       | hiredate   |
+----------+---------+--------+-------+--------+-----------+------------+
|  8000.00 | 4300.00 |     10 |  7934 | MILLER | CLERK     | 2012-01-23 |
|  8000.00 | 5450.00 |     10 |  7782 | CLARK  | MANAGER   | 2011-06-09 |
|  8000.00 | 8000.00 |     10 |  7839 | KING   | PRESIDENT | 2011-11-17 |
|  6975.00 | 3800.00 |     20 |  7369 | SMITH  | CLERK     | 2010-12-17 |
|  6975.00 | 4100.00 |     20 |  7876 | ADAMS  | CLERK     | 2017-05-23 |
|  6975.00 | 6000.00 |     20 |  7788 | SCOTT  | ANALYST   | 2017-04-19 |
|  6975.00 | 6000.00 |     20 |  7902 | FORD   | ANALYST   | 2011-12-03 |
|  6975.00 | 6975.00 |     20 |  7566 | JONES  | MANAGER   | 2011-04-02 |
|  5850.00 | 3950.00 |     30 |  7900 | JAMES  | CLERK     | 2011-12-03 |
|  5850.00 | 4250.00 |     30 |  7521 | WARD   | SALESMAN  | 2011-02-22 |
|  5850.00 | 4250.00 |     30 |  7654 | MARTIN | SALESMAN  | 2011-09-28 |
|  5850.00 | 4500.00 |     30 |  7844 | TURNER | SALESMAN  | 2011-09-08 |
|  5850.00 | 4600.00 |     30 |  7499 | ALLEN  | SALESMAN  | 2011-02-20 |
|  5850.00 | 5850.00 |     30 |  7698 | BLAKE  | MANAGER   | 2011-05-01 |
+----------+---------+--------+-------+--------+-----------+------------+
14 rows in set (0.00 sec)
```

ok!完工~

#### 3. NTH_VALUE(expr,n)函数

NTH_VALUE(expr,n)函数返回第n个expr的值。

+ 测试

```mysql
mysql> SELECT NTH_VALUE(sal,2) OVER(
  PARTITION BY deptno 
  ORDER BY sal ASC
) AS last_sal,sal,
deptno,empno,ename,job,hiredate 
FROM emp;

+----------+---------+--------+-------+--------+-----------+------------+
| last_sal | sal     | deptno | empno | ename  | job       | hiredate   |
+----------+---------+--------+-------+--------+-----------+------------+
|     NULL | 4300.00 |     10 |  7934 | MILLER | CLERK     | 2012-01-23 |
|  5450.00 | 5450.00 |     10 |  7782 | CLARK  | MANAGER   | 2011-06-09 |
|  5450.00 | 8000.00 |     10 |  7839 | KING   | PRESIDENT | 2011-11-17 |
|     NULL | 3800.00 |     20 |  7369 | SMITH  | CLERK     | 2010-12-17 |
|  4100.00 | 4100.00 |     20 |  7876 | ADAMS  | CLERK     | 2017-05-23 |
|  4100.00 | 6000.00 |     20 |  7788 | SCOTT  | ANALYST   | 2017-04-19 |
|  4100.00 | 6000.00 |     20 |  7902 | FORD   | ANALYST   | 2011-12-03 |
|  4100.00 | 6975.00 |     20 |  7566 | JONES  | MANAGER   | 2011-04-02 |
|     NULL | 3950.00 |     30 |  7900 | JAMES  | CLERK     | 2011-12-03 |
|  4250.00 | 4250.00 |     30 |  7521 | WARD   | SALESMAN  | 2011-02-22 |
|  4250.00 | 4250.00 |     30 |  7654 | MARTIN | SALESMAN  | 2011-09-28 |
|  4250.00 | 4500.00 |     30 |  7844 | TURNER | SALESMAN  | 2011-09-08 |
|  4250.00 | 4600.00 |     30 |  7499 | ALLEN  | SALESMAN  | 2011-02-20 |
|  4250.00 | 5850.00 |     30 |  7698 | BLAKE  | MANAGER   | 2011-05-01 |
+----------+---------+--------+-------+--------+-----------+------------+
14 rows in set (0.00 sec)
```

## 小 结

窗口函数的特点是可以分组，而且可以在分组内排序。另外，窗口函数不会因为分组而减少原表中的行  数，这对我们在原表数据的基础上进行统计和排序非常有用。


