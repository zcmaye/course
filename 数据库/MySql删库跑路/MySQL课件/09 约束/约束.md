# 约束

## 1. 约束(Constraint)概念

### 1.1 为什么需要约束 

对于已经创建好的表，虽然字段的数据类型决定了所能存储的数据类型，但是表中所存储的数据是否合法并没有进行检查。在具体使用MySQL 软件时，如果想针对表中的数据做一些完整性检查操作，可以通过表的约束来完成。

数据完整性（Data Intergrity）是指数据的精确性（Accuracy）和可靠性（Reliability）。他是防止数据库中存在不符合语义规定的数据和防止因错误信息的输入输出造成无效操作或错误信息而提出来的。

为了保证数据的完整性，SQL规范以约束的方式**对表数据进行额外的条件限制**，主要从以下四个方面考虑：

+ <font style="color:rgb(200,132,75)">实体完整性（Entity Integrity）</font>如：同一张表中，不能存在两条完全相同无法区分的记录
+ <font style="color:rgb(200,132,75)">域完整性（Domain Integrity）</font>如：年龄范围0-120，性别范围 “男/女”
+ <font style="color:rgb(200,132,75)">引用完整性（Referential Integrity）</font>如：员工所在部门，必须要在部门表中存在
+ <font style="color:rgb(200,132,75)">用户自定义完整性（User-defined Integrity）</font>如：用户名唯一、密码不能为空等

### 1.2 什么是约束

在MySQL中，约束（Constraints）是用来确保数据库表中数据的准确性和可靠性的规则。约束的主要目的是防止无效数据的输入，从而保护数据的完整性。MySQL支持多种类型的约束，每种约束都有其特定的用途和规则。

可以在创建表时规定约束（通过CREATE TABLE语句），或者在表创建之后通过ALTER T ABLE语句规定约束。

### 1.3 约束分类

#### 1.3.1 根据约束的作用分类

| 完整性约束关键字 | 说明                                           |
| ---------------- | ---------------------------------------------- |
| NOT NULL(NK)     | 约束字段的值不能为空                           |
| DEFAULT          | 设置字段的默认值                               |
| UNIQUE KEY(UK)   | 约束字段的值是唯一(同一列不能出现相同的值)     |
| PRIMARAY KEY(PK) | 约束字段为表的主键，可以作为该表记录的唯一标识 |
| AUTO_INCREMENT   | 约束字段的值为自动增加                         |
| FOREIGN KEY(FK)  | 约束字段为表的外键                             |
| CHECK(条件)      | 检查约束                                       |

#### 1.3.2 根据约束的字段分类

+ 单列约束
+ 多列(复合)约束

#### 1.3.3 根据约束的作用范围分类

+ 列级约束：`NOT NULL` | `DEFAULT` | `PRIMARY KEY` | `UNIQUE` | `CHECK`
+ 表级约束：`PRIMARY KEY` | `UNIQUE` | `CHECK` | `FOREIGN KEY`

**区别**

① 位置不同 ：列级约束是写在列的后面，表级约束时写在所有字段的最后面

② 支持的约束类型不同：列级约束可以支持除外键之外所有的约束类型，表级约束不能支持非空和默认

③ 列级约束不可以起约束名，表记约束可以起约束名（主键除外，主键使用的PRIMARY KEY）

### 查看表约束

#### DESC

此方法适合快速查看列的基本约束（如主键、唯一键）。

```sql
mysql> desc tb_user1;
+----------+--------------+------+-----+---------+-------+
| Field    | Type         | Null | Key | Default | Extra |
+----------+--------------+------+-----+---------+-------+
| id       | int          | NO   |     | NULL    | NULL  |
| username | varchar(32)  | NO   |     | NULL    | NULL  |
| password | varchar(128) | NO   |     | NULL    | NULL  |
+----------+--------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```

#### SHOW KEYS FROM

SHOW KEYS命令用于显示数据表中所有索引的信息，包括索引的名称、类型、列名以及索引的基数（即索引列的唯一值数量）。通过分析这些信息，您可以更好地理解数据表的索引结构，从而优化查询性能。

```sql
SHOW KEYS FROM tb_name;
SHOW INDEX FROM tb_name;
SHOW INDEXES FROM tb_name;
```

#### TABLE_CONSTRAINTS

此方法适用于需要更详细的约束信息。

```sql
SELECT  * FROM information_schema.TABLE_CONSTRAINTS
WHERE table_name='emp';
```

## 2. 非空约束(NK)

 非空约束（NOT NULL）指字段的值不能为空。对于使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。

### **2.2 特点**

+ 非空约束的字段不允许为NULL
+ 一个表可以有很多字段指定非空约束
+ 空串" "不等于NULL，0也不等于NULL，NULL也不等于NULL

### 2.3 添加非空约束

可以通过 `CREATE TABLE` 或 `ALTER TABLE` 语句实现。在表中某个列的定义后加上关键字 NOT NULL 作为限定词，来约束该列的取值不能为空。

```mysql
CREATE TABLE table_name(
	字段名 数据类型 NOT NULL,
    ...
);
```

例如，创建数据表`tb_user1`，指定用户名不能为空，SQL语句和运行结果如下：

```sql
mysql> CREATE TEMPORARY TABLE tb_user1(
    ->   id INT NOT NULL COMMENT 'ID',                  -- 非空约束
    ->   username VARCHAR(32) NOT NULL COMMENT '姓名',   -- 非空约束
    ->   password VARCHAR(128) NULL COMMENT '密码'       -- 允许为NULL
    -> );
Query OK, 0 rows affected (0.00 sec)

mysql> DESC tb_user1;
+----------+--------------+------+-----+---------+-------+
| Field    | Type         | Null | Key | Default | Extra |
+----------+--------------+------+-----+---------+-------+
| id       | int          | NO   |     | NULL    | NULL  |
| username | varchar(32)  | NO   |     | NULL    | NULL  |
| password | varchar(128) | YES  |     | NULL    | NULL  |
+----------+--------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```

插入数据进行测试：

1. 插入正常的数据，没问题：

```sql
mysql> INSERT INTO tb_user1 VALUES(1,'maye','123456');
Query OK, 1 row affected (0.00 sec)
```

2. `username`字段自定`NULL`插入：

```sql
mysql> INSERT INTO tb_user1 VALUES(2, NULL,'123456');
ERROR 1048 (23000): Column 'username' cannot be null
```

报错了，因为username字段添加了非空约束，不能插入NULL。

3. `password`字段没有设置非空约束，所以能插入NULL：

```sql
mysql> INSERT INTO tb_user1 VALUES(2, 'admin',NULL);
Query OK, 1 row affected (0.00 sec)
```

但是密码也是不能为空的，所以我们也需要给`password`字段添加非空约束，在创建表之后添加约束，语法如下：

```mysql
ALTER TABLE <表名> MODIFY 字段名 数据类型 约束;
```

具体使用如下：

```sql
mysql> ALTER TABLE tb_user1 MODIFY `password` VARCHAR(128) NOT NULL;
ERROR 1265 (01000): Data truncated for column 'password' at row 2
```

**哎嘿，报错了！**为啥呢？

因为`password`列存在为NULL的记录，所以设置非空约束失败，那么必须先把所有为NULL的值，修改一下！我们可以把NULL修改为空字符串`' '`：

```sql
mysql> UPDATE tb_user1 SET password = ' ' WHERE password IS NULL;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
```

然后再执行，添加非空约束的语句：

```sql
mysql> ALTER TABLE tb_user1 MODIFY `password` VARCHAR(128) NOT NULL;
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0
```

### 2.4 删除非空约束

有非空约束的列，如果没有指定默认值，则必须插入，不能省略：

```sql
mysql> INSERT INTO tb_user1(id,username) VALUES(3, 'hdy');
ERROR 1364 (HY000): Field 'password' doesn't have a default value
```

可以设置默认值：

```sql
mysql> ALTER TABLE tb_user1 MODIFY password varchar(128) NOT NULL DEFAULT 'hdy123';
Query OK, 2 rows affected (0.00 sec)
Records: 2  Duplicates: 0  Warnings: 0

mysql> desc tb_user1;
+----------+--------------+------+-----+---------+-------+
| Field    | Type         | Null | Key | Default | Extra |
+----------+--------------+------+-----+---------+-------+
| id       | int          | NO   |     | NULL    | NULL  |
| username | varchar(32)  | NO   |     | NULL    | NULL  |
| password | varchar(128) | NO   |     | hdy123  | NULL  |
+----------+--------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```

也可以删除非空约束：

```sql
mysql> ALTER TABLE tb_user1 MODIFY password VARCHAR(128) NULL;
Query OK, 3 rows affected (0.00 sec)
Records: 3  Duplicates: 0  Warnings: 0

mysql> desc tb_user1;
+----------+--------------+------+-----+---------+-------+
| Field    | Type         | Null | Key | Default | Extra |
+----------+--------------+------+-----+---------+-------+
| id       | int          | NO   |     | NULL    | NULL  |
| username | varchar(32)  | NO   |     | NULL    | NULL  |
| password | varchar(128) | YES  |     | NULL    | NULL  |
+----------+--------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```

## 3. 唯一约束(UK)

唯一约束（Unique Key）是指所有记录中字段的值不能重复出现。例如，为 id 字段加上唯一性约束后，每条记录的 id 值都是唯一的，不能出现重复的情况。如果其中一条记录的 id 值为‘0001’，那么该表中就不能出现另一条记录的 id 值也为‘0001’。

### 3.1 特点

+ 同一个表可以有多个唯一约束
+ 唯一约束允许值为NULL
+ 在创建唯一约束的时候，如果不给唯一约束命名，那么约束名就和字段名相同

### 3.2 单列唯一约束

#### 创建表时添加

可以通过 `CREATE TABLE` 或 `ALTER TABLE` 语句实现。在表中某个列的定义后加上关键字 `UNIQUE [KEY] `作为限定词，来约束该列的取值不能重复。

```mysql
CREATE TABLE table_name(
	字段名 数据类型 UNIQUE KEY,			 #列级约束
    ...
    [CONSTRAINT uk_name] UNIQUE KEY(字段名)	#表级约束
);
```

例如，创建数据表`tb_user2`，指定`id`、`username`列不能为空并且唯一，`password`列不能为空，SQL语句和运行结果如下：

```sql
CREATE TABLE tb_user2(
  id INT UNIQUE KEY NOT NULL COMMENT 'ID',         -- 非空约束
  username VARCHAR(32)  NOT NULL COMMENT '姓名',   -- 非空约束
  password VARCHAR(128) NULL COMMENT '密码',       -- 允许为NULL
  CONSTRAINT uk_name UNIQUE KEY(username)          -- 表级约束，并指定约束名
  -- UNIQUE KEY(username)                          -- 表级约束，字段名作为约束名
);
```

查看一下约束：

```sql
mysql> DESC tb_user2;
+----------+--------------+------+-----+---------+-------+
| Field    | Type         | Null | Key | Default | Extra |
+----------+--------------+------+-----+---------+-------+
| id       | int          | NO   | PRI | NULL    | NULL  |
| username | varchar(32)  | NO   | UNI | NULL    | NULL  |
| password | varchar(128) | YES  |     | NULL    | NULL  |
+----------+--------------+------+-----+---------+-------+
3 rows in set (0.00 sec)
```

插入重复数据试试：

```sql
mysql> INSERT INTO tb_user2 
	   VALUES
	   (1,'maye','123'),
	   (1,'admin','12345');
1062 - Duplicate entry '1' for key 'tb_user2.id'
```

结果报错了，提示id列数据为`1`的重复了！

#### 创建表后添加

+ 方法一

```mysql
ALTER TABLE <表名> MODIFY 字段名 数据类型 UNIQUE;
```

+ 方法二

```mysql
ALTER TABLE <表名> ADD [CONSTRAINT 约束名] UNIQUE [KEY](字段名);
```

### 3.4 复合唯一约束

复合约束是指**在多个列上施加约束条件，以增强数据完整性**。 随着应用程序对数据模型的复杂性要求的提升，复合约束的使用变得愈加重要。 当我们开发一个复杂的数据库应用时，常常会遇到需要对多个字段进行约束的场景。 例如，一个订单系统可能需要确保同一用户在同一时间只能创建一个订单。 为了实现这一需求，使用复合约束可以确保数据的一致性与合法性。

复合唯一约束只能是表级约束。

```mysql
CREATE TABLE table_name(
	field1 type,
    field2 type
    ...
    CONSTRAINT uk_1_2 UNIQUE KEY(field1,field2)	#表级约束
);
```

例如，创建数据表`tb_order`，指定`order_id`列不能为空并且唯一，`user_id`和`order_at`列不能为空，SQL语句和运行结果如下：

```sql
CREATE TABLE tb_order(
  order_id INT COMMENT '订单ID',
  user_id INT NOT NULL COMMENT '用户ID',
  order_time DATETIME COMMENT '下单时间',
  UNIQUE KEY(order_id),
  UNIQUE KEY(user_id,order_time)
);
```

查看约束：

```sql
mysql> SELECT * FROM information_schema.TABLE_CONSTRAINTS WHERE TABLE_NAME = 'tb_order';
+--------------------+-------------------+-----------------+--------------+------------+-----------------+----------+
| CONSTRAINT_CATALOG | CONSTRAINT_SCHEMA | CONSTRAINT_NAME | TABLE_SCHEMA | TABLE_NAME | CONSTRAINT_TYPE | ENFORCED |
+--------------------+-------------------+-----------------+--------------+------------+-----------------+----------+
| def                | hdy               | order_id        | hdy          | tb_order   | UNIQUE          | YES      |
| def                | hdy               | user_id         | hdy          | tb_order   | UNIQUE          | YES      |
+--------------------+-------------------+-----------------+--------------+------------+-----------------+----------+
2 rows in set (0.00 sec)
```

咦~怎么只有`order_id`和`user_id`有约束，不是复合约束吗？`order_time`列应该也有约束呀！记住：如果是复合约束，只显示第一个字段的约束，要想完成查看，必须使用如下语句：

```sql
SHOW KEYS FROM 表名;
SHOW INDEX FROM 表名;
SHOW INDEXES FROM 表名;
```

三者的语法结构和使用方式完全相同，官方文档中将它们归为**同义词（Synonyms）**，可以互相替换使用，不会改变查询结果。

```sql
mysql> SHOW KEYS FROM tb_order;
+----------+------------+----------+--------------+-------------+-...-+------+------------+-...-+
| Table    | Non_unique | Key_name | Seq_in_index | Column_name | ... | Null | Index_type | ... |
+----------+------------+----------+--------------+-------------+-...-+------+------------+-...-+
| tb_order |          0 | order_id |            1 | order_id    | ... | YES  | BTREE      | ... |
| tb_order |          0 | user_id  |            1 | user_id     | ... |      | BTREE      | ... |
| tb_order |          0 | user_id  |            2 | order_time  | ... | YES  | BTREE      | ... |
+----------+------------+----------+--------------+-------------+-...-+------+------------+-...-+
3 rows in set (0.00 sec)
```

+ Table：表示索引所属数据表名
+ Non_unique：表示该索引是否为**非唯一索引**，取值为 `0` 或 `1`
  + `0`：唯一索引（包括主键索引），索引列的值必须唯一，不允许重复（主键索引是特殊的唯一索引）。
  + `1`：非唯一索引，索引列的值可以重复。
+ Key_name：索引的名称，是创建索引时指定的名字（若未指定，数据库会自动生成）。
+ Seq_in_index：表示索引列在**联合索引**中的位置（序号），取值从 `1` 开始：
  - 单列索引：该值固定为 `1`。
  - 联合索引：按创建索引时的列顺序，依次为 `1`、`2`、`3`...
+ Column_name：成索引的列名称，即该索引是基于哪个 / 哪些字段创建的。
+ Null：表示索引列是否允许存储 `NULL` 值，取值为 `YES` 或 `NO`：
  + `YES`：索引列可以为 `NULL`。
  + `NO`：索引列不允许为 `NULL`（如主键列、设置了 `NOT NULL` 的列）。

接下来，**插入数据进行测试**：

```sql
mysql> INSERT INTO tb_order VALUES(1,1001,'2026-12-30 15:30:45');
Query OK, 1 row affected (0.06 sec)
```

将`order_id`修改为2再执行一次：

```sql
mysql> INSERT INTO tb_order VALUES(2,1001,'2026-12-30 15:30:45');
ERROR 1062 (23000): Duplicate entry '1001-2026-12-30 15:30:45' for key 'tb_order.user_id'
```

重复键入 `'1001-2026-12-30 15:30:45' `致使 `tb_order.user_id` 错误，也就是说`user_id`和`order_time`重复了！

那修改一下`user_id`或者`order_time`呢？

```sql
mysql> INSERT INTO tb_order VALUES(2,1002,'2026-12-30 15:30:45');
Query OK, 1 row affected (0.07 sec)
```

可以了，也就是说复合唯一约束，只要约束的多个字段没有一起重复即可！

### 3.4 删除唯一约束

删除唯一性约束，必须要使用唯一约束名（未指定名称则是字段名；复合约束是第一个字段名）。

有两种方式可以删除唯一约束。

第一种是使用`ALTER TABLE`语句：

```mysql
ALTER TABLE tb_name DROP INDEX idx_name;
```

第二种是使用`DROP INDEX`语句：

```sql
DROP INDEX idx_name ON tb_name
```

## 4. 主键约束(PK)

**主键（Primary Key）[用于唯一标识表中的每一行记录，必须**唯一且非空]，并会自动创建索引以提升查询性能。

### 4.1 特点

+ 主键约束相当于 **唯一约束+非空约束**，意味着不允许重复和NULL值

+ 主键约束对应着表中的一列或者多列(复合主键)
+ 如果是多列组合的复合主键约束，那么这些列都不允许为NULL值，并且组合的值不允许重复
+ MySQL的主键名总是PRIMARY，就算自己命名了主键约束名也没用
+ 当创建主键约束时，系统默认会在所在的列或组合上建立对应的主键索引（能够根据主键查询的，就根据主键查询，效率更高），如果删除主键约束，主键约束对应的索引就自动删除了
+ 需要注意一点的是，不要修改主键字段的值。因为主键是数据记录的唯一标识，如果修改了主键的值，就有可能会破坏数据的完整性。

### 4.2 单字段主键

可以通过 `CREATE TABLE` 或 `ALTER TABLE` 语句实现。在表中某个列的定义后加上关键字 `PRIMARY KEY`作为限定词，来约束该列的取值不能重复也不能为空。

#### 创建表时设置

```mysql
CREATE TABLE table_name(
	字段名 数据类型 PRIMARY KEY,			 #列级约束
    ...
    PRIMARY KEY(course_id)				 #表级约束
);
```

例如，创建数据表`tb_course`，指定`id`列为主键，SQL语句和运行结果如下：

```sql
CREATE TEMPORARY TABLE tb_course(
  course_id INT  COMMENT '课程ID',
  course_name VARCHAR(32)  COMMENT '课程名',
  course_code VARCHAR(32)  COMMENT '课程代码',
  PRIMARY KEY(course_id)
);
```

插入数据测试：

```sql
mysql> INSERT INTO tb_course VALUES(1,'C','code_c');
Query OK, 1 row affected (0.00 sec)
```

再执行一次，报错了：

```sql
mysql> INSERT INTO tb_course VALUES(1,'C','code_c');
ERROR 1062 (23000): Duplicate entry '1' for key 'tb_course.PRIMARY'
```

重复录入`1` 致使主键 `tb_course.PRIMARY` 冲突，主键不允许重复。

#### ALTER TABLE添加主键

```mysql
ALTER TABLE <表名> ADD PRIMARY KEY(字段名);
```

### 4.4 多字段主键(复合主键)

当主键有多个字段组合而成时，需要通过SQL语句`CONSTRAINT`来实现，语法形式如下：

```mysql
CREATE TABLE table_name(
	字段名 数据类型，
    ...
    PRIMARY KEY(字段1，字段2...)
);
```

在上述语句中，在字段定义完之后统一设置主键，PRIMARY KEY关键字括号中的字段可以有多个，需要通过逗号分割，用来实现设置多字段主键。

### 4.5 删除主键

```mysql
ALTER TABLE <表名> DROP PRIMARY KEY;
```



### 4.5  设置字段值自动增加(AUTO_INCREMENT)

#### 4.5.1 概念

AUTO_INCREMENT是 MySQL 唯一扩展的完整性约束，当为数据库表中插入新记录时，字段上的值会自动生成唯一的ID。在具体设置AUTO_INCREMENT约束时，一个数据库表中只能有一个字段使用该约束，该字段的数据类型必须是整数类型。由于设置AUTO_INCREMENT约束后的字段会生成唯一的ID，所以该字段也经常会设置成PK主键。

#### 4.5.2 特点

+ 一个表最多只能有一个自增长列
+ 当需要产生唯一标识符或者顺序值时，可设置自增长
+ 自增长列约束的列必须是键列(主键列，唯一键列)
+ 自增约束的列的数据类型必须是整数类型
+ 如果自增列指定了0或NULL，会在当前最大值的基础上自增；如果自增列手动指定了具体值，直接赋值为具体值。

#### 4.5.3 指定自增约束

1. 方法一：创建表时指定

```mysql
CREATE TABLE table_name(
	字段名 数据类型 (PRIMARY KEY|UNIQUE) AUTO_INCREMENT,
    ...
);
```

2. 方法二：通过ALTER TABLE添加

```mysql
ALTER TABLE <表名> MODIFY 字段名 数据类型 AUTO_INCREMENT;
```

#### 4.5.3 删除自增约束

```mysql
ALTER TABLE <表名> MODIFY 字段名 数据类型;
```

## 5. 外键约束(FOREIGN KEY,FK)

前面介绍的完整性约束都是在单表中进行设置，而外键约束则保证多个表(通常为两个表）之间的参照完整性，即构建于两个表的两个字段之间的参照关系。

### 5.1 概念

设置外键约束的两个表之间会具有父子关系，即子表中某个字段的取值范围由父表所决定。例如，表示一种部门和雇员关系，即每个部门有多个雇员。首先应该有两个表：部门表和雇员表，然后雇员表中有一个表示部门编号的字段deptno，其依赖于部门表的主键，这样字段deptno就是雇员表的外键，通过该字段部门表和雇员表建立了关系。

对于两个具有关联关系的表而言，相关联字段中主键所在的表就是主表（父表），外键所在的表就是从表（子表）。

在具体设置FK约束时，设置FK约束的字段必须依赖于数据库中已经存在的父表的主键，同时外键可以为NULL。

![image-20220407150556938](assets/image-20220407150556938.png)

### 5.2 特点

+ 从表的外键列必须引用(参考)主表的主键或唯一约束的列：因为参考的值必须是唯一的
+ 在创建外键约束时，如果不给外键约束命名，默认名不是列名，而是自动产生一个外键名，如emp11_ibfk_1，也可以指定外键约束名
+ 创建表时必须先创建主表，再创建从表
+ 删除表是必须先删除从表(或先删除外键约束)，再删除主表
+ 当主表的记录被从表参照时，主表的记录将不允许删除，如果要删除数据，需要先删除从表中依赖该字段的记录，然后才可以删除主表中的记录
+ 当创建外键约束时，系统默认会在所在的列上建立对应的普通索引；删除外键约束之后，必须`手动`删除对应的索引

### 5.3 添加外键约束

设置表中某字段的FK 约束非常简单，其语法形式如下:

```mysql
CREATE TABLE table_name(
	字段名 数据类型，
    字段名 数据类型，
    ...
    CONSTRAINT 外键约束名 FOREIGN KEY (字段名1)
    	REFERENCES 主表名 (字段名2)
);
```

在上述语句中，“外键约束名”用来标识约束名，“字段名1”是子表中设置外键的字段名，“字段2”是子表参照的父表中字段名。

**（1）建表时添加**

```mysql
CREATE TABLE 主表名
(
	字段名 数据类型 PRIMARY KEY,
    字段名 数据类型，
    ...
);

CREATE TABLE 从表名
(
    字段名 数据类型 PRIMARY KEY,
    字段名 数据类型，
    ...
    CONSTRAINT 约束名 FOREIGN KEY(外键约束字段名)
    REFERENCES 主表(参考字段名)
);
```

**（1）建表后添加**

一般情况下，表与表的关联都是提前设计好的，因此，会在创建表的时候就把外键约束定义好。不过，如果需要修改表的设计（比如添加新的字段，增加新的关联关系），但是没有预先定义外键约束，那么，就要用修改表的方式来补充定义。

格式：

```mysql
ALTER TABLE 从表名 ADD [CONSTRAINT 约束名] FOREIGN KEY(从表字段名) REFERENCES 主表名(被参考字段) [ON UPDATE XX][ON DELETE XX];
```

范例：

```mysql
ALTER TABLE emp ADD [CONSTRAINT fk_emp_deptno] FOREIGN KEY(deptno) REFERENCES dept(deptno);
```

### 5.4 演示

#### 5.4.1 创建表

```mysql
#新建数据库
CREATE DATABASE db_maye;
USE db_maye;

#创建表
CREATE TABLE dept
(
	deptno INT PRIMARY KEY COMMENT '部门编号',
	dname VARCHAR(20) NOT NULL  COMMENT '部门名称',
	loc   VARCHAR(20)  COMMENT '部门所在位置'
);

CREATE TABLE emp
(
	empno INT PRIMARY KEY  COMMENT '员工编号',
	ename VARCHAR(10) NOT NULL  COMMENT '员工姓名',
	deptno INT  COMMENT '员工所在部门编号',	#外键必须使用表级约束
	CONSTRAINT fk_emp_deptno FOREIGN KEY(deptno) REFERENCES dept(deptno)
);
#必须先创建dept表，再创建emp表，如果没有指定外键，那么随便先创建哪个都行
```

#### 5.4.2 操作表

+ 添加记录

```mysql
#给员工表添加一条记录
INSERT INTO emp(empno,ename,deptno) VALUES(1234,'顽石',10);
-- 在dept表中不存在10号部门，所以错误->error:无法添加或更新子行:外键约束失败(' db_maye ')。 外键约束:fk_emp_deptno (' deptno ')

#先给dept添加记录，再执行上面的插入语句即可
INSERT INTO dept(deptno,dname,loc) VALUES(10,'C/C++','长沙');
```

+ 删除记录

```mysql
#删除主表dept中的记录
DELETE FROM dept WHERE deptno=10;
-- 在从表emp中有部门编号为10的，所以错误->Cannot delete or update a parent row: a foreign key constraint fails...

#先删除从表emp中参考指定值的记录,再执行上面的删除语句即可
DELETE FROM emp WHERE deptno=10;
```

+ 修改记录

```mysql
#修改主表dept中的部门编号(把部门编号为10的改为20)
UPDATE dept SET deptno=20 WHERE deptno=10;
-- 在emp表中有参考dept表的deptno的外键，所以不能修改-> Cannot delete or update a parent row: a foreign key constraint fails...

#可以先删除从表emp中参考指定值的记录，再执行上面的语句
DELETE FROM emp WHERE deptno=10;
```

+ 创建完表后添加外键约束

```mysql
ALTER TABLE emp ADD [CONSTRAINT fk_emp_deptno] FOREIGN KEY(deptno) REFERENCES dept(deptno);
```

+ 删除约束和索引

```mysql
#先查看约束名
SELECT * FROM information_schema.TABLE_CONSTRAINTS
WHERE table_name='emp1';

#删除外键约束
ALTER TABLE emp1 DROP FOREIGN KEY fk_emp1_deptno;

#查看指定表的索引
SHOW INDEX FROM emp1;
#最后手动删除索引
ALTER TABLE emp1 DROP INDEX fk_emp1_deptno;
```



### 5.5 开发场景

**<font style='color:rgb(86,23,21)'>Ques 1：如果两个表之间有关系(一对一，一对多)，比如员工表和部门表（一对多），他们之间是否一定要建立外键约束？</font>**

Answer：不是的，前面我们学习的emp和dept表就没有外键约束，照样用的好好的！！



**<font style='color:rgb(86,23,21)'>Ques 2：建不建外键约束有什么区别？</font>**

Answer：

+ 建立外键约束，你的操作（创建表、删除表，添加、修改、删除数据）会受到限制。
  + 例如：在员工表中不可能添加一个员工信息，如果他的部门的编号在部门表找不到。

+ 不建立外键约束，你的操作（创建表、删除表，添加、修改、删除数据）不会受到限制，但也要保证数据的引用完整性，只能依靠`程序员的自觉`或者`在访问的时候进行限定`。
  + 列如在员工表中，可以添加一个员工信息，即使他的部门不在部门表中

**<font style='color:rgb(86,23,21)'>Ques 3：那么建不建外键约束和查询有没有关系？</font>**

Answer：没有

> 在MySQL里，外键约束是有成本的，需要消耗系统资源。对于大并发的SQL操作，有可能会不适合。比如大型网站的中央数据库，可能会`因为外键约束的系统开销而变得非常慢`。所以，MySQL允许你不使用系统自带的外键约束，在`应用层面`完成检查数据一致性的逻辑。也就是说，即使你不用外键约束，也要想办法通过应用层免得附加逻辑来实现外键约束的功能，确保数据的一致性。

### 5.6 阿里开发规范

【强制】不得使用外键与级联，一切外键概念必须在应用层解决。

> 说明：部门表dept中的deptno是主键，那么员工表emp中的empno则为外键。如果更新部门表中的deptno，同时触发员工表中的deptno更新，即为级联更新。外键与级联更新适用于`单机低并发`，不适合`分布式、高并发集群`；级联更新是强阻塞，存在数据库`更新风暴`的风险；外键影响数据库的插入速度。

### 5.7 级联操作

当我们需要删除部门表(主表)信息时，必须先删除员工表(从表)中关联的数据，很麻烦！！！

这时候我们就可以用到级联操作：级联操作指的就是，当你操作主表时，自动操作从表

**两种级联操作**

+ 级联删除：当删除主表数据时自动删除从表中相关数据
+ 级联更新：当主表外键约束字段(一般是主键)更新时，自动更新从表的数据

**五种级联方式**

定义从表的外键时指定的ON UPDATE/ON DELETE子句, InnoDB支持５种方式，分列如下 ：

+ CASCADE 级联方式
  + 在主表上update/delete记录时，同步update/delete掉从表的匹配记录 

+ SET NULL 设置为NULL
  + 在主表上update/delete记录时，将从表上匹配记录的列为NULL
+ NO ACTION 不允许更新和删除
  + 如果从表中有匹配的记录，则不允许对主表的关联字段更新
+ RESTRICT 限制
  + 同NO ACTION
+ SET DEFAULT
  + 主表有变更时，子表将外键列设置成一个默认的值，但Innodb不能识别...

**范例：**

```mysql
CREATE TABLE emp
(
	empno INT PRIMARY KEY  COMMENT '员工编号',
	ename VARCHAR(10) NOT NULL  COMMENT '员工姓名',
	deptno INT  COMMENT '员工所在部门编号',	#外键必须使用表级约束
	CONSTRAINT fk_emp_deptno FOREIGN KEY(deptno) REFERENCES dept(deptno)
    ON UPDATE CASCADE ON DELETE RESTRICT
);
```



## 6.1 检查约束（Check）

**检查约束（CHECK Constraint）** 用于限制列中值的范围，确保数据符合指定的条件（如数值范围、字符串格式、逻辑表达式等）。不过 MySQL 对 CHECK 约束的支持经历了版本变化，**MySQL 8.0.16 及以上版本才正式完整支持 CHECK 约束**，而在 8.0.16 之前的版本中，CHECK 约束仅被语法解析，但不会实际生效（会被忽略）。

### 添加检查约束

CHECK 约束可在**创建表（CREATE TABLE）** 时定义，也可在**修改表（ALTER TABLE）** 时添加，支持列级约束和表级约束两种形式。

#### 创建表时设置

##### 列级约束

直接在列定义后添加 `CHECK(条件)`，仅作用于当前列：

```sql
CREATE TABLE stu
(
	 id INT PRIMARY KEY AUTO_INCREMENT,
	 name VARCHAR(10),
	 gender CHAR CHECK(gender IN('男','女'))
);
```

##### 表级约束

当约束涉及多个列时，需定义为表级约束，可指定约束名称（便于后续管理）：

```mysql
CREATE TABLE stu
(
	 id INT PRIMARY KEY AUTO_INCREMENT,
	 name VARCHAR(10),
	 gender CHAR CHECK(gender IN('男','女')),
    
	 age TINYINT,
	 sal DECIMAL(10,2),
	 CONSTRAINT ck_stu_sal CHECK(sal>200),
	 CONSTRAINT ck_stu_age CHECK(age BETWEEN 18 AND 120)
);
```

+ 再举例

```mysql
age TINYINT check(age>20) 
或
age TINYINT check(age BETWEEN 18 AND 120) 
```

#### 创建表后添加检查约束

对已存在的表添加 CHECK 约束，使用 `ALTER TABLE`：

```mysql
ALTER TABLE stu ADD CONSTRAINT ck_stu_sal CHECK(sal>2000);
```



### 删除检查约束

通过约束名称删除（若创建时未指定名称，MySQL 会自动生成一个，需先查询）：

```mysql
ALTER TABLE stu DROP CHECK ck_stu_sal;
```

## 6.2 默认值约束(Default)

**默认约束（DEFAULT Constraint）** 用于为数据表的列指定**默认值**。当向表中插入数据时，如果未显式为该列赋值，数据库会自动将默认值填入该列，从而保证数据的完整性和一致性。

默认约束是 MySQL 中最常用的约束之一，支持在**创建表**和**修改表**时定义，且适配大多数数据类型（如数值、字符串、日期等）。

### 创建表时定义默认约束

在列定义后通过 `DEFAULT <默认值>` 指定，仅支持**列级约束**（默认约束仅为列级，无表级形式）。

```sql
CREATE TABLE 表名 (
    列名 数据类型 [NOT NULL/NULL] DEFAULT 默认值,
    -- 其他列定义
);
```

### 修改表时添加默认约束

对已存在的列添加默认约束，使用 `ALTER TABLE` 的 `ALTER COLUMN` 或 `MODIFY COLUMN` 子句：

```sql
-- 语法1：ALTER COLUMN（简洁版，MySQL 8.0+ 推荐）
ALTER TABLE 表名 ALTER COLUMN 列名 SET DEFAULT 默认值;

-- 语法2：MODIFY COLUMN（兼容低版本，需重写列的完整属性）
ALTER TABLE 表名 MODIFY COLUMN 列名 数据类型 [NOT NULL/NULL] DEFAULT 默认值;
```

### 删除默认约束

移除列的默认值，使用 `ALTER COLUMN ... DROP DEFAULT`：

```mysql
ALTER TABLE 表名 ALTER COLUMN 列名 DROP DEFAULT;
```

## 7. 综合实战

### 7.1 建立数据表

#### 7.1.1 表字段描述

到了秋天，为了让同学们增加体育锻炼，所以学校开始筹备学生运动会的活动，为了方便保存比赛成绩信息，所以定义了如下的几张数据表。

+ 运动员表（sporter）：
  + 运动员编号sporterno、运动员姓名name、运动员性别gender、所属系号deptno
+ 体育项目表（item）：
  + 项目编号itemno、项目名称iname、比赛地点loc
+ 成绩表（grade）：
  + 运动员编号sporterno、项目编号itemno、得分mark

![](assets/Diagram.jpg)

在成绩表之中包含了两个外键：分别是运动员的编号、项目的编号，之所以这样设计，是因为一个运动员可以参加多个项目，一个项目可以有多个运动员参加，每个运动员针对不同的项目有自己的成绩。所以运动员和项目之间是属于多对多关系。而之前所学的emp-dept是属于一对多的关系。

#### 7.1.2 表中的约束

![image-20220409184051723](assets/image-20220409184051723.png)



#### 7.1.3 SQL语句

```mysql
-- 删除数据库
DROP DATABASE IF EXISTS games;

-- 创建数据库
CREATE DATABASE IF NOT EXISTS games;

-- 选择数据库
USE games;

-- 创建表
DROP TABLE IF EXISTS sporter;
CREATE TABLE sporter
(
	sporterno INT,
	name 			VARCHAR(30) NOT NULL,
	gender 		CHAR				NOT NULL,
	deptname 	VARCHAR(30)	NOT NULL,
	CONSTRAINT pk_sporterno PRIMARY KEY(sporterno),
	CONSTRAINT ck_gender CHECK(gender IN('男','女'))
)COMMENT '运动员表';

DROP TABLE IF EXISTS item;
CREATE TABLE item
(
	itemno 		INT AUTO_INCREMENT,
	itemname 	VARCHAR(30)	NOT NULL,
	loc 			VARCHAR(30)	NOT NULL,
	CONSTRAINT pk_itemno PRIMARY KEY(itemno) 
)COMMENT '运动项目表';

DROP TABLE IF EXISTS grade;
CREATE TABLE grade
(
	sporterno INT,
	itemno INT,
	mark INT,
	CONSTRAINT fk_sporterno FOREIGN KEY(sporterno) REFERENCES sporter(sporterno),
	CONSTRAINT fk_itemno FOREIGN KEY(itemno) REFERENCES item(itemno)
)COMMENT '远动员积分表';


--  添加测试数据
INSERT INTO sporter(sporterno,name,gender,deptname) VALUES(1001,'微笑','男','计算机系');
INSERT INTO sporter(sporterno,name,gender,deptname) VALUES(1002,'莫影','男','数学系');
INSERT INTO sporter(sporterno,name,gender,deptname) VALUES(1003,'修语','男','计算机系');
INSERT INTO sporter(sporterno,name,gender,deptname) VALUES(1004,'顽石','男','物理系');
INSERT INTO sporter(sporterno,name,gender,deptname) VALUES(1005,'空弦','女','心理系');
INSERT INTO sporter(sporterno,name,gender,deptname) VALUES(1006,'苏苏','女','数学系');

INSERT INTO item(itemno,itemname,loc) VALUES(1,'男子五千米','一操场');
INSERT INTO item(itemno,itemname,loc) VALUES(2,'男子标枪','一操场');
INSERT INTO item(itemno,itemname,loc) VALUES(3,'男子跳远','二操场');
INSERT INTO item(itemno,itemname,loc) VALUES(4,'女子跳高','二操场');
INSERT INTO item(itemno,itemname,loc) VALUES(5,'女子三千米','三操场');

INSERT INTO grade(sporterno,itemno,mark) VALUES(1001,1,6);
INSERT INTO grade(sporterno,itemno,mark) VALUES(1002,1,4);
INSERT INTO grade(sporterno,itemno,mark) VALUES(1003,1,2);
INSERT INTO grade(sporterno,itemno,mark) VALUES(1004,1,0);
INSERT INTO grade(sporterno,itemno,mark) VALUES(1001,3,4);
INSERT INTO grade(sporterno,itemno,mark) VALUES(1002,3,6);
INSERT INTO grade(sporterno,itemno,mark) VALUES(1004,3,2);
INSERT INTO grade(sporterno,itemno,mark) VALUES(1003,3,0);
INSERT INTO grade(sporterno,itemno,mark) VALUES(1005,4,6);
INSERT INTO grade(sporterno,itemno,mark) VALUES(1006,4,4);
INSERT INTO grade(sporterno,itemno,mark) VALUES(1001,4,2);
INSERT INTO grade(sporterno,itemno,mark) VALUES(1002,4,0);
INSERT INTO grade(sporterno,itemno,mark) VALUES(1003,2,6);
INSERT INTO grade(sporterno,itemno,mark) VALUES(1005,2,4);
INSERT INTO grade(sporterno,itemno,mark) VALUES(1006,2,2);
INSERT INTO grade(sporterno,itemno,mark) VALUES(1001,2,0);
```



### 7.2 数据操作

**第一题：**求出目前总积分最高的系名及其积分。

```mysql

```

**第二题：**找出在一操场进行比赛的各项目名称极其冠军的姓名。

```mysql

```

**第三题：**找出参加了莫影所参加过的项目的其他同学的姓名。

```mysql

```

**第四题：**经查莫影因为使用了违禁药品，其成绩都记为0分，请在数据库中做出相应的修改。

```mysql

```

**第五题：**经组委会协商，需要删除女子跳高比赛项目。

```mysql

```