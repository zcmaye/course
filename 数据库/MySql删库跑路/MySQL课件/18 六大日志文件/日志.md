# 数据库日志

对于线上数据库应用系统，突然遭遇数据库宕机怎么办？在这种情况下，定位宕机的原因就非常关键。我们可以查看数据库的错误日志。因为日志中记录了数据库运行中的诊断信息，包括了错误、警告和注释等信息。比如：从日志中发现某个连接中的SQL操作发生了死循环，导致内存不足，被系统强行终止了。明确了原因，处理起来也就轻松了，系统很快就恢复了运行。

除了发现错误，日志在数据复制、数据恢复、操作审计，以及确保数据的永久性和一致性等方面，都有着不可替代的作用。

干万不要小看日志。很多看似奇怪的问题，答案往往就藏在日志里。很多情况下，只有通过查看日志才能发现问题的原因，真正解决问题。所以，一定要学会查看日志，养成检查日志的习惯，对提升你的数据库应用开发能力至关重要。

MySQL8.+官网日志地址：[MySQL :: MySQL 8.4 Reference Manual :: 7.4 MySQL Server Logs](https://dev.mysql.com/doc/refman/8.4/en/server-logs.html)

## 1. MySQL支持的日志

MySQL 服务器有多个日志文件，可帮助您了解正在进行的活动。

### 日志类型

主要有六大日志：

+ **慢查询日志（Slow query log）：**记录所有执行时间超过`long_query_time`的所有查询，方便我们对查询进行优化。
+ **通用查询日志（General query log）：**记录所有连接的起始时间和终止时间，以及连接发送给数据库服务器的所有指令，对我们复原操作的实际场景、发现问题，甚至是对数据库操作的审计都有很大的帮助。
+ **错误日志（Error log）：**记录MySQL服务的启动、运行或停止MySQL服务时出现的问题，方便我们了解服务器的状态，从而对服务器进行维护。
+ **二进制日志（Binary log）：**记录所有更改数据的语句，可以用于主从服务器之间的数据同步，以及服务器遇到故障时数据的无损失恢复。
+ **中继日志（Relay log）：**用于主从服务器架构中，从服务器用来存放主服务器二进制日志内容的一个中间文件。从服务器通过读取中继日志的内容，来同步主服务器上的操作。
+ **DDL语句日志（DDL log）：**记录数据定义语句执行的元数据操作。

除二进制日志、中继日志外，其他日志都是**文本文件** 。默认情况下，所有日志创建于 MySQL数据目录中。

### 日志弊端

+ 日志功能会降低MySQL数据库的性能。例如，在查询非常频繁的MySQL数据库系统中，如果开启了通用查询日志和慢查询日志，MySQL数据库会花费很多时间记录日志。
+ 日志会占用大量的磁盘空间。对于用户量非常大、操作非常频繁的数据库，日志文件需要的存储空间设置比数据库文件需要的存储空间还要大。

## 2. 慢查询日志（slow query log）

慢查询日志在《16 性能分析(慢查询、执行计划)》已经详细讲过。

## 3. 通用查询日志（general query log）

通用查询日志是MySQL服务器所做工作的通用记录。包括客户端连接或断开连接时时间，并记录从客户端接收到的每个 SQL 语句。当您怀疑客户端存在错误并想确切了解客户端发送给服务器的内容时，通用查询日志会非常有用。

MySQL会按照接收到的顺序将语句写入查询日志，而这些语句的执行顺序可能与接收顺序不同。这种日志记录顺序与二进制日志不同，对于二进制日志而言，语句是在执行完毕后、释放任何锁之前才被写入的。此外，查询日志中可能包含仅用于查询(SELECT)数据的语句，因为这类语句永远不会被写入二进制日志中。

### 查看日志状态

默认情况下，**通用查询日志是禁用的**。

```sql
mysql> SHOW VARIABLES LIKE 'general_log%';
+------------------+-------------------------------+
| Variable_name    | Value                         |
+------------------+-------------------------------+
| general_log      | OFF                           |
| general_log_file | /var/lib/mysql/maye-vm-pc.log |
+------------------+-------------------------------+
2 rows in set (0.04 sec)
```

`general_log`是通用日志启用状态，`general_log_file`是通用日志文件。

### 启用通用日志

若要明确指定初始的通用查询日志状态，请使用 --general_log[={0|1}]。不提供参数或提供参数 1 时，--general_log 会启用日志。提供参数 0 时，此选项会禁用日志。若要指定日志文件名，请使用 --general_log_file=file_name。若要指定日志输出目的地，请使用 log_output 系统变量。

#### 直接设置变量

+ 开启通用日志

```sql
SET GLOBAL general_log = ON;
SET PERSIST general_log = ON;	-- 持久化
```

+ 设置日志文件保存位置

```sql
SET GLOBAL general_log_file='path/filename';
```

#### 配置文件

修改`mysqld.cnf`或`my.ini`配置文件来设置，在`[mysqld]`组下加入选项，并重启MySQL服务器：

```ini
[mysqld]
general_log=ON
general_log_file=path
```

> Linux配置文件一般在：/etc/mysql/mysql.conf.d/mysqld.cnf

### 查看日志

通用查询日志是以**文本文件**的形式存储在文件系统中的，可以使用**文本编辑器**直接打开日志文件。每台MySQL服务器的通用查询日志内容是不同的。

+ 在Windows操作系统中，使用文本文件查看器；

+ 在Linux系统中，可以使用vi工具或者gedit工具查看；

+ 在Mac OSX系统中，可以使用文本文件查看器或者vi等工具查看。

从`SHOW VARIABLES LIKE 'general_log%';` 结果中可以看到通用查询日志的位置。

启用查询日志之后，可以执行一些语句看是否记录到了日志中：

```sql
mysql> SELECT * FROM emp;
mysql> DELETE FROM emp WHERE empno = 7934;
mysql> INSERT INTO emp VALUES(1001,'HDY','TEACHER',NULL,NOW(),8000,NULL,40);
mysql> UPDATE emp SET comm=300 WHERE empno=1001;
```

查看通用查询日志，可以看到如下信息：

```css
root@maye-vm-pc:~# cat /var/lib/mysql/maye-vm-pc.log
/usr/sbin/mysqld, Version: 8.4.7 (MySQL Community Server - GPL). started with:
Tcp port: 3306  Unix socket: /var/run/mysqld/mysqld.sock
Time                 Id Command    Argument
2026-01-14T06:40:10.517995Z        29 Quit
2026-01-14T06:40:28.075596Z        30 Connect   root@localhost on  using Socket
2026-01-14T06:40:28.075728Z        30 Query     select @@version_comment limit 1
2026-01-14T06:40:39.389252Z        30 Query     SELECT DATABASE()
2026-01-14T06:40:39.389468Z        30 Init DB   hdy
2026-01-14T06:40:39.390361Z        30 Query     show databases
2026-01-14T06:40:39.390906Z        30 Query     show tables
2026-01-14T06:40:39.391936Z        30 Field List        bonus 
2026-01-14T06:40:39.392660Z        30 Field List        dept 
2026-01-14T06:40:39.392795Z        30 Field List        emp 
2026-01-14T06:40:39.392935Z        30 Field List        salgrade 
2026-01-14T06:40:41.092726Z        30 Query     SELECT * FROM emp
2026-01-14T06:40:48.236301Z        30 Query     DELETE FROM emp WHERE empno = 7934
2026-01-14T06:40:56.924343Z        30 Query     INSERT INTO emp VALUES(1001,'HDY','TEACHER',NULL,NOW(),8000,NULL,40)
2026-01-14T06:41:01.948334Z        30 Query     UPDATE emp SET comm=300 WHERE empno=1001
```

在通用查询日志里面，我们可以清楚地看到，什么时候开启了新的客户端登陆数据库，登录之后做了什么 SQL 操作，针对的是哪个数据表等信息。

### 删除/刷新日志

如果数据的使用非常频繁，那么通用查询日志会占用服务器非常大的磁盘空间。数据管理员可以删除很长时间之前的查询日志，以保证MySQL服务器上的硬盘空间。

#### 手动删除日志文件

直接使用命令手动删除日志文件即可！

```bash
sudo rm /var/lib/mysql/maye-vm-pc.log
```

但是注意，删除之后再执行SQL查询语句时，不会自动创建文件！而且自己创建同名文件之后，日志也不会被记录到文件中！！坑！！

#### 刷新日志文件

所以，删除文件之后必须使用mysql的工具来刷新日志，会自动创建日志文件(前提是`general_log`必须是ON)。

```bash
sudo mysqladmin -uroot -p flush-logs general
```

当然，这个也可以直接截断日志文件，也就是说不需要手动删除了！

## 4. 错误日志（Error log）

错误日志记录了MySQL服务器启动、停止运行的时间，以及系统启动、运行和停止过程中的诊断信息，包括错误、警告和提示等。

通过错误日志可以查看系统的运行状态，便于即时发现故障、修复故障。如果MySQL服务出现异常，错误日志是发现问题、解决故障的首选。

### 查看日志

在MySQL数据库中，错误日志功能是无法被关闭的，也就是说错误必须被记录 。

```sql
mysql> SHOW VARIABLES LIKE 'log_error%';
+----------------------------+----------------------------------------+
| Variable_name              | Value                                  |
+----------------------------+----------------------------------------+
| log_error                  | /var/log/mysql/error.log               |
| log_error_services         | log_filter_internal; log_sink_internal |
| log_error_suppression_list |                                        |
| log_error_verbosity        | 2                                      |
+----------------------------+----------------------------------------+
4 rows in set (0.00 sec)
```

从输出结果可以看出，错误日志文件在默认在` /var/log/mysql `目录中，名称默认为 `error.log` （Linux系统）。如果需要指定文件名，则需要在`mysqld.cnf`或者`my.ini`中做如下配置：

```ini
[mysqld]
log-error=[path/[filename]]
```

查看日志文件内容：

```sql
root@maye-vm-pc:~# cat /var/log/mysql/error.log 
2026-01-09T07:29:58.414788Z 0 [System] [MY-015017] [Server] MySQL Server Initialization - start.
2026-01-09T07:29:58.416194Z 0 [System] [MY-013169] [Server] /usr/sbin/mysqld (mysqld 8.4.7) initializing of server in progress as process 9824
2026-01-09T07:29:58.438104Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started.
2026-01-09T07:29:58.949010Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended.
2026-01-09T07:30:00.494741Z 6 [Warning] [MY-010453] [Server] root@localhost is created with an empty password ! Please consider switching off the --initialize-insecure option.
2026-01-09T07:30:02.809059Z 0 [System] [MY-015018] [Server] MySQL Server Initialization - end.
2026-01-09T07:30:02.859699Z 0 [System] [MY-015015] [Server] MySQL Server - start.
2026-01-09T07:30:03.073917Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.4.7) starting as process 9867
2026-01-09T07:30:03.081694Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started.
2026-01-09T07:30:03.927704Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended.
2026-01-09T07:30:04.577834Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed.
2026-01-09T07:30:04.577879Z 0 [System] [MY-013602] [Server] Channel mysql_main configured to support TLS. Encrypted connections are now supported for this channel.
```

### 删除/刷新日志

对于很久以前的错误日志，数据库管理员查看这些错误日志的可能性不大，可以将这些错误日志删除，以保证MySQL服务器上的硬盘空间 。MySQL的错误日志是以文本文件的形式存储在文件系统中的，可以直接删除 。

+ 错误日志文件，必须要手动删除或备份一下：

```bash
mv /var/log/mysql/error.log /var/log/mysql/error.log.1
```

+ 然后，刷新日志文件。

```sql
mysqladmin -uroot -p flush-logs error
```

这样，又会创建一个新的日志文件了。

## 5. 二进制日志（binlog）

binlog可以说是MySQL中比较重要的日志了，在日常开发及运维过程中，经常会遇到。

binlog即binary log，二进制日志文件，也叫作变更日志（update log）。它记录了数据库所有执行的DDL和DML等数据库更新事件的语句，但是不包含没有修改任何数据的语句（如数据查询语句select、show等）。

它以事件形式记录并保存在二进制文件中。通过这些信息，我们可以再现数据更新操作的全过程。

**binlog主要应用场景：**

+ 一是用于**数据恢复**，如果MySQL数据库意外停止，可以通过二进制日志文件来查看用户执行了哪些操作，对数据库服务器文件做了哪些修改，然后根据二进制日志文件中的记录来恢复数据库服务器。
+  二是用于**数据复制**，由于日志的延续性和时效性，master把它的二进制日志传递给slaves来达到master-slave数据一致的目的。

可以说MysQL数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保证数据一致性。

![image-20260114154012322](./assets/image-20260114154012322.png)

### 查看日志默认情况

默认情况下，二进制日志是开启的：

```sql
mysql> SHOW VARIABLES LIKE 'log_bin%';
+---------------------------------+-----------------------------+
| Variable_name                   | Value                       |
+---------------------------------+-----------------------------+
| log_bin                         | ON                          |
| log_bin_basename                | /var/lib/mysql/binlog       |
| log_bin_index                   | /var/lib/mysql/binlog.index |
| log_bin_trust_function_creators | OFF                         |
+---------------------------------+-----------------------------+
4 rows in set (0.00 sec)
```

+ **log_bin_basename：**是binlog日志的基本文件名，后面会追加表示来表示每一个文件；
+ **log_bin_index：**是binglog文件的索引文件，这个文件管理所有的binglog文件的列表；

+ **log_bin_trust_function_creators：**限制存储过程，前面我们已经讲过了，这是因为二进制日志的一个重要功能是用于主从复制，而存储函数有可能导致主从的数据不一致。所以当开启二进制日志后，需要限制存储函数的创建、修改、调用。

### 日志参数设置

#### 配置文件

通过配置文件修改二进制日志相关参数：

```ini
[mysqld]
log-bin=hdy-bin
binlog_expire_logs_seconds=2591000
max_binlog_size=100M
```

+ **log-bin：**用于指定生成的二进制日志文件名，比如：将`log-bin`设置为`hdy-bin`，那么最后的日志文件名将是 `/var/lib/mysql/hdy-bin.xxxx`

+ **binlog_expire_logs_seconds：**是二进制日志保存的时长，超过时长则会自动清除过期的文件；默认是`2592000s`，即30天；
+ **max_binlog_size：**控制单个二进制日志大小，当前日志文件大小超过此变量时，执行切换动作。此参数的最大和**默认值是1GB**，该设置并不能严格控制Binlog的大小，尤其是Binlog比较靠近最大值而又遇到一个比较大事务时，为了保证事务的完整性，可能不做切换日志的动作，只能将该事务的所有SQL都记录进当前日志，直到事务结束。一般情况下可采取默认值。

使用`systemctl restart mysql`命令重启服务器，然后查看二进制日志信息：

```sql
mysql> SHOW VARIABLES LIKE 'log_bin%';
+---------------------------------+------------------------------+
| Variable_name                   | Value                        |
+---------------------------------+------------------------------+
| log_bin                         | ON                           |
| log_bin_basename                | /var/lib/mysql/hdy-bin       |
| log_bin_index                   | /var/lib/mysql/hdy-bin.index |
| log_bin_trust_function_creators | OFF                          |
+---------------------------------+------------------------------+
4 rows in set (0.00 sec)
```

然后查看一下日志文件：

```bash
root@maye-vm-pc:~# ls -lsh /var/lib/mysql
4.0K -rw-r----- 1 mysql mysql  158  1月 14 16:01  hdy-bin.000001
4.0K -rw-r----- 1 mysql mysql   17  1月 14 16:01  hdy-bin.index
```

可以发现已经创建了，新的binlog日志文件。

**修改日志文件目录和名称**

如果想要改变日志文件的目录和名称，可以直接在`log-bin`选项后面写上路径：

```ini
log-bin="/var/lib/mysql/binlog/hdy-bin"
```

然后重启服务器，会发现报错了：

```sql
root@maye-vm-pc:~# systemctl restart mysql
Job for mysql.service failed because the control process exited with error code.
See "systemctl status mysql.service" and "journalctl -xeu mysql.service" for details.
```

这个时候，我们可以查看一下错误日志：

```sql
root@maye-vm-pc:~# cat /var/log/mysql/error.log
2026-01-14T08:09:10.727488Z 0 [System] [MY-015015] [Server] MySQL Server - start.
2026-01-14T08:09:10.934602Z 0 [System] [MY-010116] [Server] /usr/sbin/mysqld (mysqld 8.4.7) starting as process 4841
mysqld: File '/var/lib/mysql/binlog/hdy-bin.index' not found (OS errno 2 - No such file or directory)
2026-01-14T08:09:10.937328Z 0 [ERROR] [MY-010119] [Server] Aborting
2026-01-14T08:09:10.938336Z 0 [System] [MY-010910] [Server] /usr/sbin/mysqld: Shutdown complete (mysqld 8.4.7)  MySQL Community Server - GPL.
```

从错误日志文件中可以看出，是没有`/var/lib/mysql/binlog/hdy-bin.index`这样的文件或者目录，看吧，错误日志文件还是有用的！！！

先创建`binlog`目录：

```bash
mkdir /var/lib/mysql/binlog
```

然后修改`binglog`目录的所有者：

```bash
chown -R -v mysql:mysql /var/lib/mysql/binlog
```

接着再重启服务器，即可成功：

```bash
systemctl restart mysql
```

最后查看一下日志信息，发现日志文件路径和名称都变了：

```sql
mysql> SHOW VARIABLES LIKE 'log_bin%';
+---------------------------------+-------------------------------------+
| Variable_name                   | Value                               |
+---------------------------------+-------------------------------------+
| log_bin                         | ON                                  |
| log_bin_basename                | /var/lib/mysql/binlog/hdy-bin       |
| log_bin_index                   | /var/lib/mysql/binlog/hdy-bin.index |
| log_bin_trust_function_creators | OFF                                 |
+---------------------------------+-------------------------------------+
4 rows in set (0.04 sec)
```

> **提示：**数据库文件最好不要与日志文件放在同一个磁盘上！这样，当数据库文件所在的磁盘发生故障时，可以使用日志文件恢复数据。

#### 临时修改

直接在服务器启动之后，通过变量去设置就好了，不再赘述。

### 查看日志

当MySQL创建二进制日志文件时，先创建一个以“filename”为名称、以“index”为后缀的文件，再创建一个以“filename”为名称、以“.0000o1”为后缀的文件。

MySQL服务重新启动一次，以“000001”为后缀的文件就会增加一个，并且后缀名按1递增。即日志文件的个数与MySQL服务启动的次数相同；如果日志长度超过了`max_binlog_size`的上限（默认是1GB），就会创建一个新的日志文件。

#### 日志文件列表及大小

查看当前的二进制日志文件列表及大小。指令如下：

```sql
mysql> SHOW BINARY LOGS;
+----------------+-----------+-----------+
| Log_name       | File_size | Encrypted |
+----------------+-----------+-----------+
| hdy-bin.000001 |       181 | No        |
| hdy-bin.000002 |       158 | No        |
+----------------+-----------+-----------+
2 rows in set (0.00 sec)
```

查看当前正在使用的日志文件：

```sql
mysql> SHOW BINARY LOG STATUS;
+----------------+----------+--------------+------------------+-------------------+
| File           | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+----------------+----------+--------------+------------------+-------------------+
| hdy-bin.000002 |     169 |              |                  |                   |
+----------------+----------+--------------+------------------+-------------------+
1 row in set (0.00 sec)
```

接下来我们先做点数据的更新，然后查看日志内容：

```sql
mysql> SELECT * FROM emp;
+-------+--------+-----------+------+------------+---------+------+--------+
| empno | ename  | job       | mgr  | hiredate   | sal     | comm | deptno |
+-------+--------+-----------+------+------------+---------+------+--------+
|  1001 | HDY    | TEACHER   | NULL | 2026-01-14 | 8000.00 |  300 |     40 |
|  7369 | SMITH  | CLERK     | 7902 | 2010-12-17 | 3800.00 | NULL |     20 |
|  7499 | ALLEN  | SALESMAN  | 7698 | 2011-02-20 | 4600.00 |  300 |     30 |
|  7521 | WARD   | SALESMAN  | 7698 | 2011-02-22 | 4250.00 |  500 |     30 |
|  7566 | JONES  | MANAGER   | 7839 | 2011-04-02 | 6975.00 | NULL |     20 |
|  7654 | MARTIN | SALESMAN  | 7698 | 2011-09-28 | 4250.00 | 1400 |     30 |
|  7698 | BLAKE  | MANAGER   | 7839 | 2011-05-01 | 5850.00 | NULL |     30 |
|  7782 | CLARK  | MANAGER   | 7839 | 2011-06-09 | 5450.00 | NULL |     10 |
|  7788 | SCOTT  | ANALYST   | 7566 | 2017-04-19 | 6000.00 | NULL |     20 |
|  7839 | KING   | PRESIDENT | NULL | 2011-11-17 | 8000.00 | NULL |     10 |
|  7844 | TURNER | SALESMAN  | 7698 | 2011-09-08 | 4500.00 |    0 |     30 |
|  7876 | ADAMS  | CLERK     | 7788 | 2017-05-23 | 4100.00 | NULL |     20 |
|  7900 | JAMES  | CLERK     | 7698 | 2011-12-03 | 3950.00 | NULL |     30 |
|  7902 | FORD   | ANALYST   | 7566 | 2011-12-03 | 6000.00 | NULL |     20 |
+-------+--------+-----------+------+------------+---------+------+--------+
14 rows in set (0.02 sec)

mysql> INSERT INTO emp VALUE(1002,'maye','teacher',NULL,NOW(),6000,NULL,40);
Query OK, 1 row affected, 1 warning (0.00 sec)

mysql> UPDATE emp SET ename = 'zc' WHERE empno=1002;
Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0
```

然后再次查看日志文件列表及大小：

```sql
mysql> SHOW BINARY LOGS;
+----------------+-----------+-----------+
| Log_name       | File_size | Encrypted |
+----------------+-----------+-----------+
| hdy-bin.000001 |       181 | No        |
| hdy-bin.000002 |       819 | No        |
+----------------+-----------+-----------+
2 rows in set (0.00 sec)
```

发现文件变大了，也就是操作已经记录到日志中了。

#### 查看日志文件内容

##### mysqlbinlog

但binlog是二进制文件，无法直接查看，想要更直观的观测它就要借助`mysqlblnlog`命令工具了。指令如下：

```bash
mysqlbinlog -v "/var/lib/mysql/binlog/hdy-bin.000002"
```

输出内容部分如下：

```sql
# at 158
#260114 16:53:42 server id 1  end_log_pos 237 CRC32 0x5f7274d0  Anonymous_GTID  last_committed=0        sequence_number=1       rbr_only=yes    original_committed_timestamp=1768380822867517  immediate_commit_timestamp=1768380822867517      transaction_length=318
/*!50718 SET TRANSACTION ISOLATION LEVEL READ COMMITTED*//*!*/;
# original_commit_timestamp=1768380822867517 (2026-01-14 16:53:42.867517 CST)
# immediate_commit_timestamp=1768380822867517 (2026-01-14 16:53:42.867517 CST)
/*!80001 SET @@session.original_commit_timestamp=1768380822867517*//*!*/;
/*!80014 SET @@session.original_server_version=80407*//*!*/;
/*!80014 SET @@session.immediate_server_version=80407*//*!*/;
SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
# at 237
#260114 16:53:42 server id 1  end_log_pos 319 CRC32 0x9c38dc59  Query   thread_id=8     exec_time=0     error_code=0
SET TIMESTAMP=1768380822/*!*/;
SET @@session.pseudo_thread_id=8/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
SET @@session.sql_mode=1168113696/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C utf8mb4 *//*!*/;
SET @@session.character_set_client=255,@@session.collation_connection=255,@@session.collation_server=255/*!*/;
SET @@session.time_zone='SYSTEM'/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
/*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;
BEGIN
/*!*/;
# at 319
#260114 16:53:42 server id 1  end_log_pos 385 CRC32 0x1f4be817  Table_map: `hdy`.`emp` mapped to number 94
# has_generated_invisible_primary_key=0
# at 385
#260114 16:53:42 server id 1  end_log_pos 445 CRC32 0xe94411f3  Write_rows: table id 94 flags: STMT_END_F

BINLOG '
lllnaRMBAAAAQgAAAIEBAAAAAF4AAAAAAAEAA2hkeQADZW1wAAgCDw8CCvYCAgYoACQABwL+AQEA
AgP8/wAX6Esf
lllnaR4BAAAAPAAAAL0BAAAAAF4AAAAAAAEAAgAI/0jqAwRtYXllB3RlYWNoZXIu1A+AF3AAKADz
EUTp
'/*!*/;
# at 445
#260114 16:53:42 server id 1  end_log_pos 476 CRC32 0xd920707f  Xid = 17
COMMIT/*!*/;
# at 476
```

执行结果可以看到，这是一个简单的日志文件，日志中记录了用户的一些操作，这里并没有出现具体的SQL语句，这是因为binlog关键字后面的内容是经过编码后的二进制日志。

这里一个`INSERT`语句包含如下事件

+ Query事件负责开始一个事务（BEGIN）
+ Table_map事件负责映射需要的表
+ Update_rows事件负责写入数据
+ Xid事件负责结束事务

下面命令将行事件以伪SQL的形式表现出来

```bash
mysqlbinlog -v "/var/lib/mysql/binlog/hdy-bin.000002"

# at 237
#260114 16:53:42 server id 1  end_log_pos 319 CRC32 0x9c38dc59  Query   thread_id=8     exec_time=0     error_code=0
SET TIMESTAMP=1768380822/*!*/;
SET @@session.pseudo_thread_id=8/*!*/;
SET @@session.foreign_key_checks=1, @@session.sql_auto_is_null=0, @@session.unique_checks=1, @@session.autocommit=1/*!*/;
SET @@session.sql_mode=1168113696/*!*/;
SET @@session.auto_increment_increment=1, @@session.auto_increment_offset=1/*!*/;
/*!\C utf8mb4 *//*!*/;
SET @@session.character_set_client=255,@@session.collation_connection=255,@@session.collation_server=255/*!*/;
SET @@session.time_zone='SYSTEM'/*!*/;
SET @@session.lc_time_names=0/*!*/;
SET @@session.collation_database=DEFAULT/*!*/;
/*!80011 SET @@session.default_collation_for_utf8mb4=255*//*!*/;
BEGIN
/*!*/;
# at 319
#260114 16:53:42 server id 1  end_log_pos 385 CRC32 0x1f4be817  Table_map: `hdy`.`emp` mapped to number 94
# has_generated_invisible_primary_key=0
# at 385
#260114 16:53:42 server id 1  end_log_pos 445 CRC32 0xe94411f3  Write_rows: table id 94 flags: STMT_END_F

BINLOG '
lllnaRMBAAAAQgAAAIEBAAAAAF4AAAAAAAEAA2hkeQADZW1wAAgCDw8CCvYCAgYoACQABwL+AQEA
AgP8/wAX6Esf
lllnaR4BAAAAPAAAAL0BAAAAAF4AAAAAAAEAAgAI/0jqAwRtYXllB3RlYWNoZXIu1A+AF3AAKADz
EUTp
'/*!*/;
### INSERT INTO `hdy`.`emp`
### SET
###   @1=1002
###   @2='maye'
###   @3='teacher'
###   @4=NULL
###   @5='2026:01:14'
###   @6=6000.00
###   @7=NULL
###   @8=40
# at 445
#260114 16:53:42 server id 1  end_log_pos 476 CRC32 0xd920707f  Xid = 17
COMMIT/*!*/;
# at 476
```

还有其他的一些选项：

+ `--base64-output=DECODE-ROWS`选项，不显示binglog格式的SQL语句(其实是base64编码格式)。

```bash
mysqlbinlog -v --base64-output=DECODE-ROWS "/var/lib/mysql/binlog/hdy-bin.000002"
```

+ 结合`-vv`选项，显示完整的DML语句，并注释掉这些语句。

```bash
mysqlbinlog -vv --base64-output=DECODE-ROWS "/var/lib/mysql/binlog/hdy-bin.000002"
```

输出如下：

```sql
#260114 16:53:42 server id 1  end_log_pos 445 CRC32 0xe94411f3  Write_rows: table id 94 flags: STMT_END_F
### INSERT INTO `hdy`.`emp`
### SET
###   @1=1002 /* SHORTINT meta=0 nullable=0 is_null=0 */
###   @2='maye' /* VARSTRING(40) meta=40 nullable=1 is_null=0 */
###   @3='teacher' /* VARSTRING(36) meta=36 nullable=1 is_null=0 */
###   @4=NULL /* SHORTINT meta=0 nullable=1 is_null=1 */
###   @5='2026:01:14' /* DATE meta=0 nullable=1 is_null=0 */
###   @6=6000.00 /* DECIMAL(7,2) meta=1794 nullable=1 is_null=0 */
###   @7=NULL /* SHORTINT meta=0 nullable=1 is_null=1 */
###   @8=40 /* SHORTINT meta=0 nullable=1 is_null=0 */
# at 445
#260114 16:53:42 server id 1  end_log_pos 476 CRC32 0xd920707f  Xid = 17
COMMIT/*!*/;
```

+ 查看最后20行记录

```bash
mysqlbinlog --no-defaults -vv --base64-output=DECODE-ROWS "/var/lib/mysql/binlog/hdy-bin.000002" | tail -20
```

##### SHOW BINLOG

上面这种办法读取出binlog日志的全文内容比较多，不容易分辨查看到pos点信息，下面介绍一种更为方便的SQL查询命令，`SHOW BINLOG EVENTS` 是一个 MySQL 命令，用于查看二进制日志中的事件信息。

```sql
SHOW BINLOG EVENTS [IN 'log_name'] [FROM pos] [LIMIT [offset,] row_count];
```

+ **IN 'log_name' ：**指定要查询的binlog文件名（不指定就是第一个binlog文件）　

+ **FROM pos ：**指定从哪个pos起始点开始查起（不指定就是从整个文件首个pos点开始算）

+ **LIMIT [offset] ：**偏移量(不指定就是0)

+ **row_count ：**查询总条数（不指定就是所有行）

###### 基本使用

查看指定binlog日志的事件，一个事件

```sql
mysql> SHOW BINLOG EVENTS IN 'hdy-bin.000002';
+----------------+-----+----------------+-----------+-------------+--------------------------------------+
| Log_name       | Pos | Event_type     | Server_id | End_log_pos | Info                                 |
+----------------+-----+----------------+-----------+-------------+--------------------------------------+
| hdy-bin.000002 |   4 | Format_desc    |         1 |         127 | Server ver: 8.4.7, Binlog ver: 4     |
| hdy-bin.000002 | 127 | Previous_gtids |         1 |         158 |                                      |
| hdy-bin.000002 | 158 | Anonymous_Gtid |         1 |         237 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' |
| hdy-bin.000002 | 237 | Query          |         1 |         319 | BEGIN                                |
| hdy-bin.000002 | 319 | Table_map      |         1 |         385 | table_id: 94 (hdy.emp)               |
| hdy-bin.000002 | 385 | Write_rows     |         1 |         445 | table_id: 94 flags: STMT_END_F       |
| hdy-bin.000002 | 445 | Xid            |         1 |         476 | COMMIT /* xid=17 */                  |
| hdy-bin.000002 | 476 | Anonymous_Gtid |         1 |         555 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' |
| hdy-bin.000002 | 555 | Query          |         1 |         638 | BEGIN                                |
| hdy-bin.000002 | 638 | Table_map      |         1 |         704 | table_id: 94 (hdy.emp)               |
| hdy-bin.000002 | 704 | Update_rows    |         1 |         788 | table_id: 94 flags: STMT_END_F       |
| hdy-bin.000002 | 788 | Xid            |         1 |         819 | COMMIT /* xid=18 */                  |
+----------------+-----+----------------+-----------+-------------+--------------------------------------+
12 rows in set (0.00 sec)
```

**各字段说明**

| 字段名          | 说明                                            |
| :-------------- | :---------------------------------------------- |
| **Log_name**    | 二进制日志文件名（如：mysql-bin.000001）        |
| **Pos**         | 事件在日志中的起始位置                          |
| **Event_type**  | 事件类型（Query, Table_map, Write_rows, Xid等） |
| **Server_id**   | 产生事件的服务器ID                              |
| **End_log_pos** | 事件结束位置（下一个事件开始位置）              |
| **Info**        | 事件详细信息                                    |

###### 从指定行开始查看

```sql
mysql> SHOW BINLOG EVENTS IN 'hdy-bin.000002' FROM 158;
+----------------+-----+----------------+-----------+-------------+--------------------------------------+
| Log_name       | Pos | Event_type     | Server_id | End_log_pos | Info                                 |
+----------------+-----+----------------+-----------+-------------+--------------------------------------+
| hdy-bin.000002 | 158 | Anonymous_Gtid |         1 |         237 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' |
| hdy-bin.000002 | 237 | Query          |         1 |         319 | BEGIN                                |
| hdy-bin.000002 | 319 | Table_map      |         1 |         385 | table_id: 94 (hdy.emp)               |
| hdy-bin.000002 | 385 | Write_rows     |         1 |         445 | table_id: 94 flags: STMT_END_F       |
| hdy-bin.000002 | 445 | Xid            |         1 |         476 | COMMIT /* xid=17 */                  |
| hdy-bin.000002 | 476 | Anonymous_Gtid |         1 |         555 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' |
| hdy-bin.000002 | 555 | Query          |         1 |         638 | BEGIN                                |
| hdy-bin.000002 | 638 | Table_map      |         1 |         704 | table_id: 94 (hdy.emp)               |
| hdy-bin.000002 | 704 | Update_rows    |         1 |         788 | table_id: 94 flags: STMT_END_F       |
| hdy-bin.000002 | 788 | Xid            |         1 |         819 | COMMIT /* xid=18 */                  |
+----------------+-----+----------------+-----------+-------------+--------------------------------------+
10 rows in set (0.00 sec)
```

###### 限制返回行数

```sql
mysql> SHOW BINLOG EVENTS IN 'hdy-bin.000002' FROM 158 LIMIT 5;
+----------------+-----+----------------+-----------+-------------+--------------------------------------+
| Log_name       | Pos | Event_type     | Server_id | End_log_pos | Info                                 |
+----------------+-----+----------------+-----------+-------------+--------------------------------------+
| hdy-bin.000002 | 158 | Anonymous_Gtid |         1 |         237 | SET @@SESSION.GTID_NEXT= 'ANONYMOUS' |
| hdy-bin.000002 | 237 | Query          |         1 |         319 | BEGIN                                |
| hdy-bin.000002 | 319 | Table_map      |         1 |         385 | table_id: 94 (hdy.emp)               |
| hdy-bin.000002 | 385 | Write_rows     |         1 |         445 | table_id: 94 flags: STMT_END_F       |
| hdy-bin.000002 | 445 | Xid            |         1 |         476 | COMMIT /* xid=17 */                  |
+----------------+-----+----------------+-----------+-------------+--------------------------------------+
5 rows in set (0.00 sec)
```

##### binlog格式

上面我们讲了这么多都是基于binlog的默认格式，我们查看一下binlog格式：

```sql
mysql> SHOW VARIABLES LIKE 'binlog_format';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| binlog_format | ROW   |
+---------------+-------+
1 row in set (0.05 sec)
```

除此之外，binlog还有2种格式，分别是`Statement`和`Mixed`。

### 使用日志恢复数据

#### 场景描述

我们先对数据库进行操作，插入数据之后然后删掉，最后进行恢复。

+ 先查看emp表中的原始数据：

```sql
mysql> SELECT * FROM emp;
+-------+--------+-----------+------+------------+---------+------+--------+
| empno | ename  | job       | mgr  | hiredate   | sal     | comm | deptno |
+-------+--------+-----------+------+------------+---------+------+--------+
|  7369 | SMITH  | CLERK     | 7902 | 2010-12-17 | 3800.00 | NULL |     20 |
|  7499 | ALLEN  | SALESMAN  | 7698 | 2011-02-20 | 4600.00 |  300 |     30 |
|  7521 | WARD   | SALESMAN  | 7698 | 2011-02-22 | 4250.00 |  500 |     30 |
|  7566 | JONES  | MANAGER   | 7839 | 2011-04-02 | 6975.00 | NULL |     20 |
|  7654 | MARTIN | SALESMAN  | 7698 | 2011-09-28 | 4250.00 | 1400 |     30 |
|  7698 | BLAKE  | MANAGER   | 7839 | 2011-05-01 | 5850.00 | NULL |     30 |
|  7782 | CLARK  | MANAGER   | 7839 | 2011-06-09 | 5450.00 | NULL |     10 |
|  7788 | SCOTT  | ANALYST   | 7566 | 2017-04-19 | 6000.00 | NULL |     20 |
|  7839 | KING   | PRESIDENT | NULL | 2011-11-17 | 8000.00 | NULL |     10 |
|  7844 | TURNER | SALESMAN  | 7698 | 2011-09-08 | 4500.00 |    0 |     30 |
|  7876 | ADAMS  | CLERK     | 7788 | 2017-05-23 | 4100.00 | NULL |     20 |
|  7900 | JAMES  | CLERK     | 7698 | 2011-12-03 | 3950.00 | NULL |     30 |
|  7902 | FORD   | ANALYST   | 7566 | 2011-12-03 | 6000.00 | NULL |     20 |
|  7934 | MILLER | CLERK     | 7782 | 2012-01-23 | 4300.00 | NULL |     10 |
+-------+--------+-----------+------+------------+---------+------+--------+
14 rows in set (0.00 sec)
```

+ 然后插入几条新的数据：

```sql
INSERT INTO emp VALUES(8000,'maye','TEACHER',NULL,NOW(),6000,NULL,40);
INSERT INTO emp VALUES(8001,'zc','TEACHER',8000,NOW(),7000,NULL,40);
INSERT INTO emp VALUES(8002,'jack','TEACHER',8001,NOW(),7300,NULL,40);
INSERT INTO emp VALUES(8003,'jerry','TEACHER',8002,NOW(),7400,NULL,40);
```

+ 然后查看一下，添加的数据已经进来了：

```sql
mysql> SELECT * FROM emp;
+-------+--------+-----------+------+------------+---------+------+--------+
| empno | ename  | job       | mgr  | hiredate   | sal     | comm | deptno |
+-------+--------+-----------+------+------------+---------+------+--------+
|  7369 | SMITH  | CLERK     | 7902 | 2010-12-17 | 3800.00 | NULL |     20 |
...
|  7934 | MILLER | CLERK     | 7782 | 2012-01-23 | 4300.00 | NULL |     10 |
|  8000 | maye   | TEACHER   | NULL | 2026-01-19 | 6000.00 | NULL |     40 |
|  8001 | zc     | TEACHER   | 8000 | 2026-01-19 | 7000.00 | NULL |     40 |
|  8002 | jack   | TEACHER   | 8001 | 2026-01-19 | 7300.00 | NULL |     40 |
|  8003 | jerry  | TEACHER   | 8002 | 2026-01-19 | 7400.00 | NULL |     40 |
+-------+--------+-----------+------+------------+---------+------+--------+
18 rows in set (0.00 sec)
```

+ 接下来模拟误操作，假设我们一不小心把empno大于等于8000的员工全部删除了：

```sql
DELETE FROM emp WHERE empno >= 8000;
```

因为我们没有使用事务，所以无法进行回滚！那怎么办呢？使用binlog日志进行回滚即可！

#### 恢复数据原理

之所以能通过binlog日志恢复记录，是因为它记录了数据库中所有的DDL和DML语句（不包括SELECT和其他不修改数据的操作），并以二进制的形式存储在磁盘上。

在`Row`格式下，它记录的是哪些记录被修改，而不是SQL语句的上下文信息。

我们先查看一下最新的binlog日志文件：

```sql
mysql> SHOW BINARY LOGS;
+----------------+-----------+-----------+
| Log_name       | File_size | Encrypted |
+----------------+-----------+-----------+
| hdy-bin.000001 |       181 | No        |
| hdy-bin.000002 |       819 | No        |
| hdy-bin.000003 |       158 | No        |
| hdy-bin.000004 |     13312 | No        |
+----------------+-----------+-----------+
4 rows in set (0.02 sec)
```

接下来通过查看`binlog`日志内容来查看修改的记录：

```sql
mysqlbinlog -v "/var/lib/mysql/binlog/hdy-bin.000004"
```

输入内容如下(这里只列出，我们刚才删除数据的操作)：

```sql
SET @@SESSION.GTID_NEXT= 'ANONYMOUS'/*!*/;
# at 13001
#260119 13:46:39 server id 1  end_log_pos 13075 CRC32 0x3652cadc        Query   thread_id=8     exec_time=0     error_code=0
SET TIMESTAMP=1768801599/*!*/;
BEGIN
/*!*/;
# at 13075
#260119 13:46:39 server id 1  end_log_pos 13141 CRC32 0xb909ec18        Table_map: `hdy`.`emp` mapped to number 105
# has_generated_invisible_primary_key=0
# at 13141
#260119 13:46:39 server id 1  end_log_pos 13281 CRC32 0x25263dd1        Delete_rows: table id 105 flags: STMT_END_F

BINLOG '
P8VtaRMBAAAAQgAAAFUzAAAAAGkAAAAAAAEAA2hkeQADZW1wAAgCDw8CCvYCAgYoACQABwL+AQEA
AgP8/wAY7Am5
P8VtaSABAAAAjAAAAOEzAAAAAGkAAAAAAAEAAgAI/0hAHwRtYXllB1RFQUNIRVIz1A+AF3AAKABA
QR8CemMHVEVBQ0hFUkAfM9QPgBtYACgAQEIfBGphY2sHVEVBQ0hFUkEfM9QPgByEACgAQEMfBWpl
cnJ5B1RFQUNIRVJCHzPUD4Ac6AAoANE9JiU=
'/*!*/;
### DELETE FROM `hdy`.`emp`
### WHERE
###   @1=8000
###   @2='maye'
###   @3='TEACHER'
###   @4=NULL
###   @5='2026:01:19'
###   @6=6000.00
###   @7=NULL
###   @8=40
### DELETE FROM `hdy`.`emp`
### WHERE
###   @1=8001
###   @2='zc'
###   @3='TEACHER'
###   @4=8000
###   @5='2026:01:19'
###   @6=7000.00
###   @7=NULL
###   @8=40
### DELETE FROM `hdy`.`emp`
### WHERE
###   @1=8002
###   @2='jack'
###   @3='TEACHER'
###   @4=8001
###   @5='2026:01:19'
###   @6=7300.00
###   @7=NULL
###   @8=40
### DELETE FROM `hdy`.`emp`
### WHERE
###   @1=8003
###   @2='jerry'
###   @3='TEACHER'
###   @4=8002
###   @5='2026:01:19'
###   @6=7400.00
###   @7=NULL
###   @8=40
# at 13281
#260119 13:46:39 server id 1  end_log_pos 13312 CRC32 0xe8f412cc        Xid = 167
COMMIT/*!*/;
SET @@SESSION.GTID_NEXT= 'AUTOMATIC' /* added by mysqlbinlog */ /*!*/;
DELIMITER ;
# End of log file
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
```

上面的DELETE语句咱们删除了四条记录，而从binlog日志中可以看到，删除的四条记录对应的SQL语句，而且是每个字段的值都记录了！这样我们就可以从删除语句中反推插入语句，然后进行数据恢复！

#### 创建新的binlog文件

为了防止我们在恢复数据时，binlog日志中还有记录不断地写入，减小我们查找的复杂度，我们可以先对binlog日志进行刷新，也就是重新创建一个binlog日志文件，让新的日志写入到新的文件中，这样我们要恢复的日志就不会改变了！

```sql
FLUSH LOGS;
```

这样就创建了一个新的日志文件，我们操作的时候还是操作原来的日志文件：

```sql
mysql> SHOW binary logs;
+----------------+-----------+-----------+
| Log_name       | File_size | Encrypted |
+----------------+-----------+-----------+
| hdy-bin.000001 |       181 | No        |
| hdy-bin.000002 |       819 | No        |
| hdy-bin.000003 |       158 | No        |
| hdy-bin.000004 |     13357 | No        |
| hdy-bin.000005 |       158 | No        |
+----------------+-----------+-----------+
5 rows in set (0.00 sec)
```

#### 恢复数据

如果MySQL服务器启用了二进制日志，在数据库出现意外丢失数据时，可以使用MySQLbinlog工具从指定的时间点开始（例如，最后一次备份）直到现在或另一个指定的时间点的日志中恢复数据。`mysqlbinlog` 工具有两种主要的恢复数据方式：**按时间恢复**和**按位置恢复**。

##### 按时间恢复

通过指定开始时间和结束时间来恢复特定时间段内的二进制日志内容，日志文件中`#260119 13:46:39`这种就是时间。

+ 语法如下：

```bash
# 恢复特定时间段的日志
mysqlbinlog --start-datetime="2024-06-04 00:00:00" \
            --stop-datetime="2024-10-12 11:00:00" \
            binlog.000001 | mysql -u root -p

# 恢复从某个时间点之后的所有日志
mysqlbinlog --start-datetime="2024-06-04 10:00:00" \
            binlog.000001 binlog.000002 | mysql -u root -p

# 恢复到某个时间点之前
mysqlbinlog --stop-datetime="2024-06-04 11:00:00" \
            binlog.000001 | mysql -u root -p
```

##### 按位置恢复

通过指定二进制日志中的具体位置（Position）来精确恢复数据，日志文件中`# at 13281`这种就是位置。

语法如下：

```bash
# 恢复指定位置范围的日志
mysqlbinlog --start-position=123456 \
            --stop-position=789012 \
            binlog.000001 | mysql -u root -p

# 恢复从某个位置开始到文件结束
mysqlbinlog --start-position=123456 \
            binlog.000001 binlog.000002 | mysql -u root -p

# 恢复到某个位置之前
mysqlbinlog --stop-position=789012 \
            binlog.000001 | mysql -u root -p
```

>  注意：使用mysqlbinlog命令进行恢复操作时，必须是编号小的先恢复，例如hdy-bin.000001必须在hdy-bin.000002之前恢复。

##### 方法一：手动创建INSERT语句

先按照时间或位置导出删除语句：

+ 按时间

```bash
mysqlbinlog -v --start-datetime="2026-01-19 13:46:39" --stop-datetime="2026-01-19 13:46:40" --database="hdy" "/var/lib/mysql/binlog/hdy-bin.000004" > recovery.sql
```

+ 按位置

```bash
mysqlbinlog -v --start-position=13001 --stop_position=13281 --database="hdy" "/var/lib/mysql/binlog/hdy-bin.000004" > recovery.sql
```

然后查看`recovery.sql`文件：

```sql
...
BEGIN
/*!*/;
# at 13075
#260119 13:46:39 server id 1  end_log_pos 13141 CRC32 0xb909ec18        Table_map: `hdy`.`emp` mapped to number 105
# at 13141
#260119 13:46:39 server id 1  end_log_pos 13281 CRC32 0x25263dd1        Delete_rows: table id 105 flags: STMT_END_F

BINLOG '
P8VtaRMBAAAAQgAAAFUzAAAAAGkAAAAAAAEAA2hkeQADZW1wAAgCDw8CCvYCAgYoACQABwL+AQEA
AgP8/wAY7Am5
P8VtaSABAAAAjAAAAOEzAAAAAGkAAAAAAAEAAgAI/0hAHwRtYXllB1RFQUNIRVIz1A+AF3AAKABA
QR8CemMHVEVBQ0hFUkAfM9QPgBtYACgAQEIfBGphY2sHVEVBQ0hFUkEfM9QPgByEACgAQEMfBWpl
cnJ5B1RFQUNIRVJCHzPUD4Ac6AAoANE9JiU=
'/*!*/;
### DELETE FROM `hdy`.`emp`
### WHERE
###   @1=8000
###   @2='maye'
###   @3='TEACHER'
###   @4=NULL
###   @5='2026:01:19'
###   @6=6000.00
###   @7=NULL
###   @8=40
### DELETE FROM `hdy`.`emp`
### WHERE
###   @1=8001
###   @2='zc'
###   @3='TEACHER'
###   @4=8000
###   @5='2026:01:19'
###   @6=7000.00
###   @7=NULL
###   @8=40
### DELETE FROM `hdy`.`emp`
### WHERE
###   @1=8002
###   @2='jack'
###   @3='TEACHER'
###   @4=8001
###   @5='2026:01:19'
###   @6=7300.00
###   @7=NULL
###   @8=40
### DELETE FROM `hdy`.`emp`
### WHERE
###   @1=8003
###   @2='jerry'
###   @3='TEACHER'
###   @4=8002
###   @5='2026:01:19'
###   @6=7400.00
###   @7=NULL
###   @8=40
ROLLBACK /* added by mysqlbinlog */ /*!*/;
SET @@SESSION.GTID_NEXT= 'AUTOMATIC' /* added by mysqlbinlog */ /*!*/;
DELIMITER ;
# End of log file
/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;
```

根据DELETE记录手动创建INSERT语句：

```sql
-- 恢复被删除的4条记录
INSERT INTO `hdy`.`emp` VALUES 
(8000, 'maye', 'TEACHER', NULL, '2026-01-19', 6000.00, NULL, 40),
(8001, 'zc', 'TEACHER', 8000, '2026-01-19', 7000.00, NULL, 40),
(8002, 'jack', 'TEACHER', 8001, '2026-01-19', 7300.00, NULL, 40),
(8003, 'jerry', 'TEACHER', 8002, '2026-01-19', 7400.00, NULL, 40);
```

##### 方法二：直接重放binlog日志中的插入语句

如果要恢复的数据的插入或更新语句在binlog日志中能找到，那么则可以直接重放SQL语句，实现恢复。

+ 先根据时间或位置找到要重放的SQL语句

```bash
mysqlbinlog -v --start-position=11724 --stop_position=12922 --database="hdy" "/var/lib/mysql/binlog/hdy-bin.000004" > recovery.sql
```

+ 确认无误后，使用如下命令即可！

```bash
mysql -u root -p < recovery.sql
```

或者一步到位，将`mysqlbinlog`的结果直接传递给mysql命令（因为不需要自己看，可以不用加-v）：

```bash
mysqlbinlog --start-position=11724 --stop_position=12922 --database="hdy" "/var/lib/mysql/binlog/hdy-bin.000004" | mysql -u root -p
```

### 删除日志

MySQL的二进制文件可以配置自动删除，同时MySQL也提供了安全的手动删除二进制文件的方法。`PURGE MASTER LOGS` 只删除指定部分的二进制日志文件， `RESET MASTER` 删除所有的二进制日志文件。

#### 自动删除

自动删除通过设置过期时间实现：

```sql
-- 查看当前设置
SHOW VARIABLES LIKE 'binlog_expire_logs_seconds';

-- 设置二进制日志保留时间为7天（604800秒）
SET GLOBAL binlog_expire_logs_seconds = 604800;

-- 永久生效，修改配置文件
-- 在 my.cnf 或 my.ini 中添加：
[mysqld]
binlog_expire_logs_seconds = 604800
```

#### 手动删除

##### 删除指定时间之前的日志

```sql
-- 删除3天前的二进制日志
PURGE BINARY LOGS BEFORE DATE_SUB(NOW(), INTERVAL 3 DAY);

-- 删除指定日期前的日志
PURGE BINARY LOGS BEFORE '2026-01-01 00:00:00';
```

#####  删除指定文件之前的日志

```sql
-- 查看当前二进制日志文件
SHOW BINARY LOGS;

-- 删除指定文件之前的所有日志（保留该文件及之后的）
PURGE BINARY LOGS TO 'mysql-bin.000010';

-- 删除mysql-bin.000009之前的所有日志
PURGE BINARY LOGS BEFORE 'mysql-bin.000010';
```

##### 重置二进制日志

```sql
-- 删除所有二进制日志并重新开始
RESET MASTER;	-- 旧版
RESET BINARY LOGS AND GTIDS; -- 新版

-- ⚠️ 警告：这将删除所有二进制日志，包括当前正在使用的
-- 只应在测试环境或确定不需要恢复时使用
```

#### 推荐做法

1. **设置自动过期**：`binlog_expire_logs_seconds = 604800`
2. **定期手动清理**：`PURGE BINARY LOGS BEFORE ...`
3. **删除前备份**：重要环境的日志先备份再删除
4. **监控磁盘**：避免日志占满磁盘

#### 绝对不要

- ❌ 直接rm删除正在使用的二进制日志
- ❌ 在生产高峰时段执行RESET MASTER
- ❌ 删除主从复制中从库还未应用的日志
- ❌ 不备份就删除可能有恢复需求的日志

## 6. 中继日志

中继日志只在主从服务器架构的从服务器上存在。从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入本地的日志文件中，这个从服务器本地的日志文件就叫中继日志。然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的数据同步。

搭建好主从服务器之后，中继日志默认会保存在从服务器的数据目录下。

文件名的格式是：`从服务器名-relay-bin.序号`。中继日志还有一个索引文件：`从服务器名-relay-bin.index`，用来定位当前正在使用的中继日志。

### 查看中继日志

中继日志与二进制日志的格式相同，可以用mysqlbinlog工具进行查看。
